////////////////////////////////////////////////////////////////////////
// Class:       MuRSChecker
// Module Type: analyzer
// File:        MuRSChecker_module.cc
//
// Generated at Thu Aug 13 11:47:42 2015 by Ryan Linehan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"
#include "LArIATDataProducts/MuonRangeStackHits.h"
#include <TH1F.h>

class MuRSChecker;

class MuRSChecker : public art::EDAnalyzer {
public:
  explicit MuRSChecker(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MuRSChecker(MuRSChecker const &) = delete;
  MuRSChecker(MuRSChecker &&) = delete;
  MuRSChecker & operator = (MuRSChecker const &) = delete;
  MuRSChecker & operator = (MuRSChecker &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.
  std::string fMuRSBuilderLabel;
  TH1F*       fPenetrationDepth;
  TH1F*       fArrivalTime;

};


MuRSChecker::MuRSChecker(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  this->reconfigure(p);

}

void MuRSChecker::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  
  //Retrieving the MuonRangeStackHits Ojbects from the sliced event
  art::Handle< std::vector<ldp::MuonRangeStackHits> > MuRSHitsHandle;
  e.getByLabel(fMuRSBuilderLabel,MuRSHitsHandle);
  
  //Basic printing of track info
  for( size_t iMuRS = 0; iMuRS < MuRSHitsHandle->size(); ++iMuRS ){
    std::cout << "////////////////////////////////////////////////////////////" << std::endl;
    std::cout << "                    NEW MURS OBJECT FORMED                  " << std::endl;
    std::cout << "////////////////////////////////////////////////////////////" << std::endl;
    ldp::MuonRangeStackHits theMuRS = MuRSHitsHandle->at(iMuRS);
    for( size_t iTrack = 0; iTrack < theMuRS.NTracks() ; ++iTrack ){
      std::cout << "<------------------------- NEW TRACK: " << iTrack << " -------------------------->" << std::endl;
      std::cout << "Arrival Time: " << theMuRS.GetArrivalTime(iTrack) << std::endl;
      std::cout << "Penetration Depth: " << theMuRS.GetPenetrationDepth(iTrack) << std::endl;
      fPenetrationDepth->Fill(theMuRS.GetPenetrationDepth(iTrack)+1);
      fArrivalTime->Fill(theMuRS.GetArrivalTime(iTrack));
    }
  }
}


void MuRSChecker::beginJob()
{
  // Implementation of optional member function here.
  art::ServiceHandle<art::TFileService> tfs;
  fPenetrationDepth = tfs->make<TH1F>("PenetrationDepth","Penetration Depth of Track (in Paddles)",4,1,5);
  fArrivalTime = tfs->make<TH1F>("ArrivalTime","Arrival Time of Track (in Ticks)",3072,0,3072);
  
}

void MuRSChecker::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void MuRSChecker::beginSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void MuRSChecker::endJob()
{
  // Implementation of optional member function here.
}

void MuRSChecker::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void MuRSChecker::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void MuRSChecker::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  fMuRSBuilderLabel = p.get<std::string>("MuRSBuilderLabel","murs");
}

void MuRSChecker::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void MuRSChecker::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void MuRSChecker::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void MuRSChecker::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(MuRSChecker)
