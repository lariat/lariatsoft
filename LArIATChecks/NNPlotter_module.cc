////////////////////////////////////////////////////////////////////////
// Class:       NNPlotter
// Module Type: filter
// File:        NNPlotter_module.cc
//
// Daniel Smith
// Boston University
// dansmith@bu.edu
//
// Module to plot the NN classifier output for either hits or all points
//  in a data event. Needs to be passed a 3-category classifier
//
////////////////////////////////////////////////////////////////////////

#include "larreco/RecoAlg/ImagePatternAlgs/Tensorflow/PointIdAlg/PointIdAlg.h"
#include "lardata/ArtDataHelper/MVAWriter.h"

#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "larsim/MCCheater/BackTracker.h"
#include "larevt/Filters/ChannelFilter.h"
#include "RawDataUtilities/TriggerDigitUtility.h"

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Persistency/Common/FindOneP.h" 
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "fhiclcpp/types/Atom.h"
#include "fhiclcpp/types/Table.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "LArIATDataProducts/WCTrack.h"
#include "LArIATDataProducts/AuxDetParticleID.h"
#include "art/Framework/Services/Optional/TFileService.h"

// Framework includes
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "canvas/Utilities/InputTag.h"
#include "larcore/CoreUtils/ServiceUtil.h" 

// LArSoft includes
#include "larcorealg/Geometry/ChannelMapAlg.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/TPCGeo.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"

#include "lardataobj/Simulation/SimChannel.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include "nusimdata/SimulationBase/MCParticle.h"

// ROOT & C++
#include <memory>
#include "TCanvas.h"
#include <TH2F.h>
#include <TH1F.h>

#include "larsim/Simulation/LArG4Parameters.h"
#include "larevt/CalibrationDBI/Interface/ChannelStatusService.h"
#include "larevt/CalibrationDBI/Interface/ChannelStatusProvider.h"

#include <sys/stat.h>
#include <iostream>
#include "lardata/ArtDataHelper/MVAReader.h"

#define MVA_LENGTH 4

using namespace keras;

class NNPlotter;

class NNPlotter : public art::EDFilter {
public:

  struct Config {
    using Name = fhicl::Name;
    using Comment = fhicl::Comment;

    fhicl::Table<nnet::PointIdAlg::Config> PointIdAlg { Name("PointIdAlg") };     

    fhicl::Atom<art::InputTag> WireLabel { Name("WireLabel"),     
	Comment("tag of deconvoluted ADC on wires (recob::Wire)") };

    fhicl::Atom<art::InputTag> HitModuleLabel { Name("HitModuleLabel"),      
	Comment("tag of hit finding module") };

    fhicl::Atom<art::InputTag> TrackModuleLabel { Name("TrackModuleLabel"),     
	Comment("track label") };

    fhicl::Sequence<int> SelectedEvent { Name("SelectedEvent"),       
	Comment("Event to run plotter on") };

    fhicl::Atom<bool> EntireImage { Name("EntireImage"),      
	Comment("Boolean to determine to plot either (True) the full image or (False) just hits") };

  };
  
  using Parameters = art::EDProducer::Table<Config>;

  explicit NNPlotter(Parameters const & p);

  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  NNPlotter(NNPlotter const &) = delete;
  NNPlotter(NNPlotter &&) = delete;
  NNPlotter & operator = (NNPlotter const &) = delete;
  NNPlotter & operator = (NNPlotter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;

private:

  // Declare member data here.

  TH2F* fMap0;
  TH2F* fMap1;
  TH2F* fMap2;

  TH1F* fProbHit0;
  TH1F* fProbHit1;
  TH1F* fProbHit2;

  nnet::PointIdAlg fPointIdAlg;
  art::InputTag fWireProducerLabel;
  art::InputTag fHitModuleLabel;
  art::InputTag fTrackModuleLabel;
  std::vector<int> iSelectedEvent;
  bool bEntireImage;

};


//NNPlotter::NNPlotter(fhicl::ParameterSet const & p)
NNPlotter::NNPlotter(NNPlotter::Parameters const & config)
  : fPointIdAlg(config().PointIdAlg()),
    fWireProducerLabel(config().WireLabel()),
    fHitModuleLabel(config().HitModuleLabel()),
    fTrackModuleLabel(config().TrackModuleLabel()),
    iSelectedEvent(config().SelectedEvent()),
    bEntireImage(config().EntireImage())
{
  // Call appropriate produces<>() functions here.
}

bool NNPlotter::filter(art::Event & event)
{ 

  // Selected event
  if(iSelectedEvent.size() != 0) {
    if(int(event.event()) != iSelectedEvent[0]) { return false; }
  }

  // Wire info
  art::Handle< std::vector<recob::Wire> > WireHandle;
  std::vector< art::Ptr<recob::Wire> > Wirelist;

  if(event.getByLabel(fWireProducerLabel, WireHandle))
    art::fill_ptr_vector(Wirelist, WireHandle);

  fPointIdAlg.setWireDriftData(*WireHandle, 1, 0, 0);
  
  // Plot NN output for each pixel in image ... warning, very slow
  if(bEntireImage) { 

    // Hard coded values for wires and time samples and step size, all things that need to be fixed
    for(size_t iWire = 0.; iWire < 280; iWire += 1) {
      for(size_t iTime = 0; iTime < 3000; iTime += 16) {

	std::cout << "(iTime, iWire) = (" << iTime << ", " << iWire << ") | ";

	std::vector<float> results = fPointIdAlg.predictIdVector(iWire, iTime);

	fProbHit0->Fill(results[0]);
	fProbHit1->Fill(results[1]);
	fProbHit2->Fill(results[2]);

	fMap0->Fill(iWire, iTime, results[0]);
	fMap1->Fill(iWire, iTime, results[1]);
	fMap2->Fill(iWire, iTime, results[2]);	

      }
      std::cout << "\n";
    } // End of hitlist.size

  } else {

    std::cout << " Mehr" << std::endl;

    // Plotting from Hits, not entire Image
    // Much faster

    // Track info
    art::Handle< std::vector<recob::Track> > TrackHandle;
    std::vector< art::Ptr<recob::Track> > Tracklist;

    if(event.getByLabel(fTrackModuleLabel, TrackHandle))
      art::fill_ptr_vector(Tracklist, TrackHandle);

    // Hit info
    art::Handle< std::vector<recob::Hit> > HitHandle;
    std::vector< art::Ptr<recob::Hit> > Hitlist;

    if(event.getByLabel(fHitModuleLabel, HitHandle))
      art::fill_ptr_vector(Hitlist, HitHandle);

    // Association between Tracks and 2d Hits
    art::FindManyP<recob::Track> ass_trk_hits(HitHandle,   event, fTrackModuleLabel);

    fPointIdAlg.setWireDriftData(*WireHandle, 1, 0, 0);
    
    for(size_t iHit = 0; iHit < Hitlist.size(); ++iHit) {

      //if(ass_trk_hits.at(iHit).size() == 0) continue; 
      if(Hitlist[iHit]->View() != 1) continue;


      int wireID = Hitlist[iHit]->WireID().Wire;
      int hitTime = Hitlist[iHit]->PeakTime();
  
      std::vector<float> results = fPointIdAlg.predictIdVector(wireID, hitTime);  

      fProbHit0->Fill(results[0] / (results[0] + results[1]));
      fProbHit1->Fill(results[1] / (results[0] + results[1]));
      fProbHit2->Fill(results[2]);

      fMap0->Fill(wireID, hitTime, results[0] / (results[0] + results[1]));
      fMap1->Fill(wireID, hitTime, results[1] / (results[0] + results[1]));
      fMap2->Fill(wireID, hitTime, results[2]);

    } // End of hitlist.size
  }


  // Save image
  return true;   

}

void NNPlotter::beginJob()
{
  // Implementation of optional member function here.
  art::ServiceHandle<art::TFileService> tfs;

  fProbHit0 = tfs->make<TH1F>("fProbHit0","Track-like NN Output",50, 0.0, 1.0);
  fProbHit1 = tfs->make<TH1F>("fProbHit1","Shower-like NN Output",50, 0.0, 1.0);
  fProbHit2 = tfs->make<TH1F>("fProbHit2","Michel-like NN Output",50, 0.0, 1.0);

  fMap0 = tfs->make<TH2F>("fMap0","Track-like NN Output",250, 0.0, 250.0, 188, 0.0, 3000.); 
  fMap1 = tfs->make<TH2F>("fMap1","Shower-like NN Output",250, 0.0, 250.0, 188, 0.0, 3000.); 
  fMap2 = tfs->make<TH2F>("fMap2","Michel-like NN Output",250, 0.0, 250.0, 188, 0.0, 3000.); 


  fMap0->GetZaxis()->SetRangeUser(0.0, 1.0);
  fMap1->GetZaxis()->SetRangeUser(0.0, 1.0);
  fMap2->GetZaxis()->SetRangeUser(0.0, 1.0);

}

DEFINE_ART_MODULE(NNPlotter)
