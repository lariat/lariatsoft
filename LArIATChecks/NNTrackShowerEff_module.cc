////////////////////////////////////////////////////////////////////////
// Daniel Smith
// dansmith@bu.edu
//
// Module that tests the efficiencies of a 3-class neural network classifier on data
// Requires eyescanning the event beforehand to act as the 'truth' information
//
////////////////////////////////////////////////////////////////////////

#include "larreco/RecoAlg/ImagePatternAlgs/PointIdAlg/PointIdAlg.h"
#include "lardata/ArtDataHelper/MVAWriter.h"

#include "LArIATDataProducts/WCTrack.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"
#include "canvas/Persistency/Common/FindOneP.h" 
#include "canvas/Persistency/Common/FindManyP.h" 
#include "lardata/Utilities/AssociationUtil.h"

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h" 
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"

// LArSoft Libraries
#include "lardataobj/RawData/AuxDetDigit.h"

//ROOT Libraries
#include "TTree.h"
#include "TMath.h"
#include <TH1F.h>
#include <TGraph.h>

#include <iostream>
#include <fstream>

using namespace keras;

class NNTrackShowerEff;

class NNTrackShowerEff : public art::EDAnalyzer {
public:

  struct Config {
    using Name = fhicl::Name;
    using Comment = fhicl::Comment;

    fhicl::Table<nnet::PointIdAlg::Config> PointIdAlg {
      Name("PointIdAlg")
	};

    fhicl::Atom<art::InputTag> WireLabel {
      Name("WireLabel"),
	Comment("tag of deconvoluted ADC on wires (recob::Wire)")
	};

    fhicl::Atom<art::InputTag> HitModuleLabel {
      Name("HitModuleLabel"),
	Comment("tag of hits to be EM/track tagged")
	};

    fhicl::Atom<art::InputTag> ClusterModuleLabel {
      Name("ClusterModuleLabel"),
	Comment("tag of clusters to be used as a source of EM/track tagged new clusters (incl. single-hit clusters ) using accumulated results from hits")
	};

    fhicl::Atom<art::InputTag> TrackModuleLabel {
      Name("TrackModuleLabel"),
	Comment("Track label")
	};

    fhicl::Atom<art::InputTag> WC2TPCModuleLabel {
      Name("WC2TPCModuleLabel"),
	Comment("WCto TPC track match module") 
	};

    fhicl::Atom<art::InputTag> WCTrackLabel {
      Name("WCTrackLabel"),
	Comment("WCTrack label")
	};

    fhicl::Atom<std::string> EyeScanFile {
      Name("EyeScanFile"),
	Comment("File with information for eyescanned events ")
	};
  
  };
  
  using Parameters = art::EDAnalyzer::Table<Config>;

  explicit NNTrackShowerEff(Parameters const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  NNTrackShowerEff(NNTrackShowerEff const &) = delete;
  NNTrackShowerEff(NNTrackShowerEff &&) = delete;
  NNTrackShowerEff & operator = (NNTrackShowerEff const &) = delete;
  NNTrackShowerEff & operator = (NNTrackShowerEff &&) = delete;
  void beginJob() override;
  void endJob() override;
  //  void  reconfigure(fhicl::ParameterSet const & p) ;
  
  // Required functions.
  void analyze(art::Event const & e) override;


private:
  
  nnet::PointIdAlg fPointIdAlg;
  art::InputTag fWireProducerLabel;
  art::InputTag fHitModuleLabel;
  art::InputTag fClusterModuleLabel;
  art::InputTag fTrackModuleLabel;
  art::InputTag fWC2TPCModuleLabel;
  art::InputTag fWCTrackLabel;

  std::string fEyeScanFile;

  TH1F* ProbTrackGivenTrack;
  TH1F* ProbTrackGivenShower;

  TH1F* ProbShowerGivenTrack;
  TH1F* ProbShowerGivenShower;

  TH1F* ProbTrack;
  TH1F* ProbShower;
  TH1F* ProbNothing;

  TGraph* roc;

  std::vector< std::vector<int> > file_information;

};


NNTrackShowerEff::NNTrackShowerEff(NNTrackShowerEff::Parameters const & config) :
  EDAnalyzer(config),
  fPointIdAlg(config().PointIdAlg()),
  fWireProducerLabel(config().WireLabel()),
  fHitModuleLabel(config().HitModuleLabel()),
  fClusterModuleLabel(config().ClusterModuleLabel()),
  fTrackModuleLabel(config().TrackModuleLabel()),
  fWC2TPCModuleLabel(config().WC2TPCModuleLabel()),
  fWCTrackLabel(config().WCTrackLabel()),
  fEyeScanFile(config().EyeScanFile())
 // More initializers here.
{ 
  std::cout << "Job Started, all fhicl stuff passed." << std::endl;

  std::ifstream file;
  file.open(fEyeScanFile);
  
  if(!file.is_open()) { 
    std::cout << "Eyescane file not found" << std::endl;
  }

  // This is all to parse the eyescane file
  std::string s;
 
  std::vector<int> running;

  while(getline( file, s)) {

    std::istringstream ss( s );
    //    std::vector<int> record;

    while (ss) {
      std::string sr;
      if (!getline( ss, sr, ',' )) break;
      running.push_back( std::stoi(sr) );
    }
  }

  file.close();

  std::vector<int> record;
  for(size_t i = 1; i <= running.size(); i++) {
    record.push_back(running[i-1]);
    if(i % 6 == 0) {
      file_information.push_back( record );
      record.clear();
    }
  }


}

void NNTrackShowerEff::beginJob() {

  art::ServiceHandle<art::TFileService> tfs;

  ProbTrackGivenTrack = tfs->make<TH1F>("ProbTrackGivenTrack","ProbTrackGivenTrack",150, 0.0, 1.0);
  ProbTrackGivenShower = tfs->make<TH1F>("ProbTrackGivenShower","ProbTrackGivenShower",150, 0.0, 1.0);

  ProbShowerGivenTrack = tfs->make<TH1F>("ProbShowerGivenTrack","ProbShowerGivenTrack",150, 0.0, 1.0);
  ProbShowerGivenShower = tfs->make<TH1F>("ProbShowerGivenShower","ProbShowerGivenShower",150, 0.0, 1.0);

  ProbTrack = tfs->make<TH1F>("fProbHit0","fProbHit0",50, 0.0, 1.0);
  ProbShower = tfs->make<TH1F>("fProbHit1","fProbHit1",50, 0.0, 1.0);
  ProbNothing = tfs->make<TH1F>("fProbHit3","fProbHit3",50, 0.0, 1.0);

  roc = tfs->makeAndRegister<TGraph>("roc", "roc", 1200);

}

void NNTrackShowerEff::analyze(art::Event const & event) {
  // Implementation of required member function here.

  // Gets what type of event this is from the eye scan file
  int iShower = 0;
  int iTrack = 0;
  int iSkip = 0;

  for(size_t i = 0; i < file_information.size(); i++) {
    if(file_information[i][0] == int(event.run()) and
       file_information[i][2] == int(event.event())) {
      std::cout << " its in the file!" << std::endl;
      iShower = file_information[i][3];
      iTrack = file_information[i][4];
      iSkip = file_information[i][5];
      break;
    }
  }

  if(iSkip) {
    return;
  }

  if(!iSkip and !iTrack and !iShower) {
    std::cout << "Not EyeScanned. " << event.run() << " " << event.event() << std::endl;

    if(file_information.size() == 0) {
      std::cout << "No eyescan file given - assume all is track. " << std::endl;
      iTrack = 1;
    } else {
      return;
    }
  }




  // WC info
  art::Handle< std::vector<ldp::WCTrack> > wctrackHandle;
  std::vector<art::Ptr<ldp::WCTrack> > wctrack;
   
  if(event.getByLabel(fWCTrackLabel, wctrackHandle))
    {art::fill_ptr_vector(wctrack, wctrackHandle);}

  // Wire info
  art::Handle< std::vector<recob::Wire> > WireHandle;
  std::vector< art::Ptr<recob::Wire> > Wirelist;

  if(event.getByLabel(fWireProducerLabel, WireHandle))
    art::fill_ptr_vector(Wirelist, WireHandle);

  // Track info
  art::Handle< std::vector<recob::Track> > TrackHandle;
  std::vector< art::Ptr<recob::Track> > Tracklist;

  if(event.getByLabel(fTrackModuleLabel, TrackHandle))
    art::fill_ptr_vector(Tracklist, TrackHandle);

  // Hit info
  art::Handle< std::vector<recob::Hit> > HitHandle;
  std::vector< art::Ptr<recob::Hit> > Hitlist;

  if(event.getByLabel(fHitModuleLabel, HitHandle))
    art::fill_ptr_vector(Hitlist, HitHandle);

  // === Association between Tracks and 2d Hits ===
  art::FindManyP<recob::Track> ass_trk_hits(HitHandle,   event, fTrackModuleLabel);

  // === Association between Tracks and WC event ===
  art::FindOneP<recob::Track> fWC2TPC(wctrackHandle, event, fWC2TPCModuleLabel);

  // Requiring one WC-TPC match
  if(fWC2TPC.size() != 1) { return; }

  // Get the TPC track
  cet::maybe_ref<recob::Track const> trackWC2TPC(*fWC2TPC.at(0));

  // If no match, we gotta get out of here
  if(!trackWC2TPC) { return; }

  recob::Track const& matchedTrack(trackWC2TPC.ref()); 
  std::cout << "We gotta WC-TPC match! ID()="  << matchedTrack.ID() << std::endl;	    

  fPointIdAlg.setWireDriftData(*WireHandle, 1, 0, 0);


  // For a shower, we create a cylinder and find the NN-output for hits int that cylinder
  if(iShower) {

    std::vector< float > probs (4, 0.);
    int numHits = 0;

    int lowest_index = -1;

    for(size_t iHit = 0; iHit < Hitlist.size(); ++iHit) {
      if(Hitlist[iHit]->View() != 1) { continue; }    
      if(ass_trk_hits.at(iHit).size() == 0) { continue; }
      if(ass_trk_hits.at(iHit)[0]->ID() != matchedTrack.ID()) { continue; }
      lowest_index = iHit;
      break;
    }

    if(lowest_index == -1) {
      std::cout << "never found a single hit in the matched thing ... " << std::endl;
      return;
    }

    for(size_t iHit = 0; iHit < Hitlist.size(); ++iHit) {
      if(Hitlist[iHit]->View() != 1) { continue; }    
      if(ass_trk_hits.at(iHit).size() == 0) { continue; }
      if(ass_trk_hits.at(iHit)[0]->ID() != matchedTrack.ID()) { continue; }

      if(Hitlist[iHit]->WireID().Wire < Hitlist[lowest_index]->WireID().Wire) {
	lowest_index = iHit;
      }
    }

    float inter = Hitlist[lowest_index]->PeakTime();
    float offset = Hitlist[lowest_index]->WireID().Wire;

    std::cout << "(" << offset << ", " << inter << ")" << std::endl;

    for(size_t iHit = 0; iHit < Hitlist.size(); ++iHit) {
      if(Hitlist[iHit]->View() != 1) { continue; }    

      int wireID = Hitlist[iHit]->WireID().Wire;
      if(wireID > (offset+100) or wireID < offset) { continue; }

      int hitTime = Hitlist[iHit]->PeakTime();

      // Cylinder
      if(hitTime < inter + 250 and hitTime > inter - 250) {
	std::cout << "Hit at " << hitTime << " " << inter << " ";
      } else { continue; }

      std::vector<float> results = fPointIdAlg.predictIdVector(wireID, hitTime);
    

      numHits += 1;
      probs[0] += results[0];
      probs[1] += results[1];
      probs[2] += results[2];

      ProbTrackGivenShower->Fill(results[0]);
      ProbShowerGivenShower->Fill(results[1]);

      ProbTrack->Fill(results[0]);
      ProbShower->Fill(results[1]);
      ProbNothing->Fill(results[2]);

    } // End of hitlist.size

    /*
    std::cout << "results for matched track:" << std::endl;
    for(size_t j = 0; j < probs.size(); j++) {
      std::cout << probs[j] / float(numHits) << " ";    
    }
    */


  } else {


    std::vector< float > probs (4, 0.);
    int numHits = 0;
    for(size_t iHit = 0; iHit < Hitlist.size(); ++iHit) {

      if(ass_trk_hits.at(iHit).size() == 0) { continue; }
      if(ass_trk_hits.at(iHit)[0]->ID() != matchedTrack.ID()) { continue; }

      int wireID = Hitlist[iHit]->WireID().Wire;
      int hitTime = Hitlist[iHit]->PeakTime();

      if(Hitlist[iHit]->View() != 1) { continue; }    

      std::vector<float> results = fPointIdAlg.predictIdVector(wireID, hitTime);

      numHits += 1;
      probs[0] += results[0];
      probs[1] += results[1];
      probs[2] += results[2];

      ProbTrackGivenTrack->Fill((results[0]));
      ProbShowerGivenTrack->Fill(results[1]);

      ProbTrack->Fill(results[0]);
      ProbShower->Fill(results[1]);
      ProbNothing->Fill(results[2]);

    } // End of hitlist.size

    /*
    std::cout << "results for matched track:" << std::endl;
    for(size_t j = 0; j < probs.size(); j++) {
      std::cout << probs[j] / float(numHits) << " ";    
    }
    */

  } // End of If not Shower

}

void NNTrackShowerEff::endJob() {

  // Making the roc plot
  ProbTrackGivenTrack->Scale(1./ProbTrackGivenTrack->Integral());
  ProbTrackGivenShower->Scale(1./ProbTrackGivenShower->Integral());

  roc->SetPoint(roc->GetN(), 1,1);

  // Thresh is track thesh
  // 1 - Thresh is shower thesh

  // if move_Thresh is above Thresh, it gets accepted as a track
  // if move_Thresh is above Thresh, it gets accepted as a shower

  for(int Thresh = 0; Thresh <= ProbTrackGivenTrack->GetNbinsX(); Thresh++) {
    
    float numMiss_shower = 0; // Miss-match
    float numMiss_track = 0; // Miss-match
    float numCorr_shower = 0; // Correct match
    float numCorr_track = 0; // Correct match

    float bins_lim = ProbTrackGivenTrack->GetNbinsX();

    for(int move_Thresh = 0; move_Thresh <= bins_lim; move_Thresh++) {

      if(move_Thresh < Thresh) {
	numMiss_track += ProbTrackGivenTrack->GetBinContent(move_Thresh); // Tracks rejected
      } else {
	numCorr_track += ProbTrackGivenTrack->GetBinContent(move_Thresh); // Tracks accepted
      }

      if(move_Thresh < Thresh) {
	numCorr_shower += ProbTrackGivenShower->GetBinContent(move_Thresh); // Showers accepted
      } else {
	numMiss_shower += ProbTrackGivenShower->GetBinContent(move_Thresh); // Showers rejected
      }

    }

    double false_pos = double(numMiss_shower); // / double(total_shower);
    double true_pos  = double(numCorr_track); // / double(total_track);

    std::cout << "false_pos " << false_pos << " true_pos " << true_pos << std::endl;
    std::cout << "numCorr " << numCorr_track << " numMiss " << numMiss_shower << std::endl;

    roc->SetPoint(roc->GetN(), false_pos, true_pos);

  }

  roc->SetPoint(roc->GetN(), 0,0);

}



DEFINE_ART_MODULE(NNTrackShowerEff)
