////////////////////////////////////////////////////////////////////////
//
// Daniel Smith
// dansmith@bu.edu
// 
// Module that creates the efficiency for a 3 category classifier on MC
// 
// ******** WARNING - REQUIRES A MODIFIED VERSION OF LARRECO  ******
// Please email me for more instructions if you are curious! 
//
////////////////////////////////////////////////////////////////////////

#include "larreco/RecoAlg/ImagePatternAlgs/PointIdAlg/PointIdAlg.h"
#include "lardata/ArtDataHelper/MVAWriter.h"

#include "LArIATDataProducts/WCTrack.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"
#include "canvas/Persistency/Common/FindOneP.h" 
#include "canvas/Persistency/Common/FindManyP.h" 
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "lardataobj/MCBase/MCShower.h"
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h" 
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"

// LArSoft Libraries
#include "lardataobj/RawData/AuxDetDigit.h"

//ROOT Libraries
#include "TTree.h"
#include <TH1F.h>
#include <TGraph.h>

#include <iostream>
#include <fstream>

using namespace keras;

class NNMCTrackShowerEff;

class NNMCTrackShowerEff : public art::EDAnalyzer {
public:

  struct Config {
    using Name = fhicl::Name;
    using Comment = fhicl::Comment;

    fhicl::Table<nnet::PointIdAlg::Config> PointIdAlg {
      Name("PointIdAlg")
	};

    fhicl::Atom<art::InputTag> WireLabel {
      Name("WireLabel"),
	Comment("tag of deconvoluted ADC on wires (recob::Wire)")
	};

    fhicl::Atom<art::InputTag> SimChanLabel {
      Name("SimChanLabel"),
	Comment("")
	};
  
  };
  
  using Parameters = art::EDAnalyzer::Table<Config>;

  explicit NNMCTrackShowerEff(Parameters const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  NNMCTrackShowerEff(NNMCTrackShowerEff const &) = delete;
  NNMCTrackShowerEff(NNMCTrackShowerEff &&) = delete;
  NNMCTrackShowerEff & operator = (NNMCTrackShowerEff const &) = delete;
  NNMCTrackShowerEff & operator = (NNMCTrackShowerEff &&) = delete;
  void beginJob() override;
  void endJob() override;
  //  void  reconfigure(fhicl::ParameterSet const & p) override;
  
  // Required functions.
  void analyze(art::Event const & e) override;


private:

  
  nnet::PointIdAlg fPointIdAlg;
  art::InputTag fWireProducerLabel;
  art::InputTag fSimChanLabel;

  TH1F* ProbTrackGivenTrack;
  TH1F* ProbTrackGivenShower;

  TH1F* ProbShowerGivenTrack;
  TH1F* ProbShowerGivenShower;

  TH1F* ProbTrack;
  TH1F* ProbShower;
  TH1F* ProbNothing;

  TGraph* roc;


};


NNMCTrackShowerEff::NNMCTrackShowerEff(NNMCTrackShowerEff::Parameters const & config) :
  EDAnalyzer(config),
  fPointIdAlg(config().PointIdAlg()),
  fWireProducerLabel(config().WireLabel()),
  fSimChanLabel(config().SimChanLabel())

 // More initializers here.
{ 


}

void NNMCTrackShowerEff::beginJob() {

  art::ServiceHandle<art::TFileService> tfs;

  ProbTrackGivenTrack = tfs->make<TH1F>("ProbTrackGivenTrack","ProbTrackGivenTrack",150, 0.0, 1.0);
  ProbTrackGivenShower = tfs->make<TH1F>("ProbTrackGivenShower","ProbTrackGivenShower",150, 0.0, 1.0);

  ProbShowerGivenTrack = tfs->make<TH1F>("ProbShowerGivenTrack","ProbShowerGivenTrack",150, 0.0, 1.0);
  ProbShowerGivenShower = tfs->make<TH1F>("ProbShowerGivenShower","ProbShowerGivenShower",150, 0.0, 1.0);

  ProbTrack = tfs->make<TH1F>("fProbHit0","fProbHit0",50, 0.0, 1.0);
  ProbShower = tfs->make<TH1F>("fProbHit1","fProbHit1",50, 0.0, 1.0);
  ProbNothing = tfs->make<TH1F>("fProbHit3","fProbHit3",50, 0.0, 1.0);

  roc = tfs->makeAndRegister<TGraph>("roc", "roc", 1200);

}

void NNMCTrackShowerEff::analyze(art::Event const & event) {

  // === ParticleInventoryService service ===
  art::ServiceHandle<cheat::ParticleInventoryService> pi_serv;
  const sim::ParticleList& plist = pi_serv->ParticleList();

  // Implementation of required member function here.

  // Wire info
  art::Handle< std::vector<recob::Wire> > WireHandle;
  std::vector< art::Ptr<recob::Wire> > Wirelist;
  if(event.getByLabel(fWireProducerLabel, WireHandle))
    art::fill_ptr_vector(Wirelist, WireHandle);

  art::Handle< std::vector<sim::SimChannel> > SimHandle;
  std::vector< art::Ptr<sim::SimChannel> > Simlist;
  if(event.getByLabel(fSimChanLabel, SimHandle))
    art::fill_ptr_vector(Simlist, SimHandle);

  // --- Here be the NN! ---
  fPointIdAlg.setWireDriftData(*WireHandle, 1, 0, 0);
  // --- --- --- --- --- ---

  std::cout << "second " << std::endl;

  int numHits = 0;
  std::vector< float > probs (4, 0.);

  std::cout <<"Simlist size " <<  Simlist.size() << std::endl;

  for(size_t i = 0; i < Simlist.size(); i++) {
    std::cout <<"Simlist "<< i << " size " <<  (Simlist[i])->TrackIDEs(0, 3000).size();
    
    float max = 0.;
    int imax_tdc = 0;
    for(size_t iTDC = 0; iTDC < 3000; iTDC++) {
      if(Simlist[i]->Charge(iTDC) > max) { max = Simlist[i]->Charge(iTDC); imax_tdc = iTDC; }
    }

    if(max == 0. or imax_tdc < 15 or imax_tdc > 2985) { continue; } 



    float total_charge = 0.0;
    for(size_t iTDC = imax_tdc-10; int(iTDC) < imax_tdc+10; iTDC++) {
      total_charge += Simlist[i]->Energy(iTDC); 
    }
    std::cout << " max " << max << " total charge " << total_charge << std::endl;
    if(total_charge < 0.25) { continue; } 




    std::vector<sim::TrackIDE> tracks = Simlist[i]->TrackIDEs(imax_tdc-10, imax_tdc+10);

    if(tracks.size() != 1) { continue; } 
    std::cout << " One associated track with id : " << tracks[0].trackID << std::endl;

    bool bFound = false; 
    bool bShower = false;

    for(size_t p = 0; p < plist.size(); ++p) { 
      if(abs(tracks[0].trackID) == plist.Particle(p)->TrackId()){
	bFound = true; 

	std::cout << "second p " << p << " pdg = " << plist.Particle(p)->PdgCode() << std::endl;    

	if(plist.Particle(p)->PdgCode() == -11 or plist.Particle(p)->PdgCode() == 11 or 	     
	   plist.Particle(p)->PdgCode() == 2112 or plist.Particle(p)->PdgCode() == 22) {	     	  
	  bShower = true;
	} 	 

	break; 
      }
    } // plist for loop 

    if(!bFound) { std::cout << "No plist match. " << std::endl; continue; } // Didn't find a match .. 

    if(bShower) { std::cout << "Its a shower!" << std::endl; }
    else { std::cout << "Its a track! " << std::endl; } 

    // Now to confirm that channel is correct view
    int wire_id = 0;
    bool passed = false;

    std::cout << "Wirelist size " << Wirelist.size() << std::endl;

    for(size_t iWire = 0; iWire < Wirelist.size(); iWire++) {
      if(Wirelist[iWire]->Channel() == Simlist[i]->Channel() and Wirelist[iWire]->View() == 1) {
	wire_id = iWire;
	passed = true;
	break;
      }
    }

    if(!passed) { std::cout << "didn't find the wire. " << std::endl; continue; }

    std::vector<float> results = fPointIdAlg.predictIdVector(wire_id-240 , imax_tdc);

    std::cout << " results " << results[0] << " " << results[1] << " " << results[2] << std::endl;
   
    numHits += 1;
    probs[0] += results[0];
    probs[1] += results[1];
    probs[2] += results[2];

    if(bShower) {
      ProbTrackGivenShower->Fill(results[0]);
      ProbShowerGivenShower->Fill(results[1]);
    } else { 
      ProbTrackGivenTrack->Fill(results[0]); 
      ProbShowerGivenTrack->Fill(results[1]);
    }


    ProbTrack->Fill(results[0]);
    ProbShower->Fill(results[1]);
    ProbNothing->Fill(results[2]);

  } // Simlist for loop



  // Making sure everything is valid
  std::cout << "results for matched track:" << std::endl;
  for(size_t j = 0; j < probs.size(); j++) {
    std::cout << probs[j] / float(numHits) << " ";    
  }

  std::cout << " \n\n\n" << std::endl;

}

void NNMCTrackShowerEff::endJob() {

  ProbTrackGivenTrack->Scale(1./ProbTrackGivenTrack->Integral());
  ProbTrackGivenShower->Scale(1./ProbTrackGivenShower->Integral());

  roc->SetPoint(roc->GetN(), 1,1);

  // Thresh is track thesh
  // 1 - Thresh is shower thesh

  // if move_Thresh is above Thresh, it gets accepted as a track
  // if move_Thresh is above Thresh, it gets accepted as a shower

  for(int Thresh = 0; Thresh <= ProbTrackGivenTrack->GetNbinsX(); Thresh++) {
    
    float numMiss_shower = 0; // Miss-match
    float numMiss_track = 0; // Miss-match
    float numCorr_shower = 0; // Correct match
    float numCorr_track = 0; // Correct match

    float bins_lim = ProbTrackGivenTrack->GetNbinsX();

    for(int move_Thresh = 0; move_Thresh <= bins_lim; move_Thresh++) {

      if(move_Thresh < Thresh) {
	numMiss_track += ProbTrackGivenTrack->GetBinContent(move_Thresh); // Tracks rejected
      } else {
	numCorr_track += ProbTrackGivenTrack->GetBinContent(move_Thresh); // Tracks accepted
      }

      if(move_Thresh < Thresh) {
	numCorr_shower += ProbTrackGivenShower->GetBinContent(move_Thresh); // Showers accepted
      } else {
	numMiss_shower += ProbTrackGivenShower->GetBinContent(move_Thresh); // Showers rejected
      }

    }

    double false_pos = double(numMiss_shower); // / double(total_shower);
    double true_pos  = double(numCorr_track); // / double(total_track);
    
    std::cout << "false_pos " << false_pos << " true_pos " << true_pos << std::endl;
    std::cout << "numCorr " << numCorr_track << " numMiss " << numMiss_shower << std::endl;

    roc->SetPoint(roc->GetN(), false_pos, true_pos);

  }

  roc->SetPoint(roc->GetN(), 0,0);

}


DEFINE_ART_MODULE(NNMCTrackShowerEff)
