////////////////////////////////////////////////////////////////////////
// Class:       LArIATFragmentDump
// Module Type: analyzer
// File:        LArIATFragmentDump_module.cc
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "artdaq-core/Data/Fragment.hh"

#include "LariatFragment.h"
#include "WUTFragment.h"
#include "CAENFragment.h"
#include "TDCFragment.h"

#include "TTree.h"

#include <vector>
#include <string>

namespace rdu {
  class LArIATFragmentDump;
}

class rdu::LArIATFragmentDump : public art::EDAnalyzer {
public:
  explicit LArIATFragmentDump(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  LArIATFragmentDump(LArIATFragmentDump const &) = delete;
  LArIATFragmentDump(LArIATFragmentDump &&) = delete;
  LArIATFragmentDump & operator = (LArIATFragmentDump const &) = delete;
  LArIATFragmentDump & operator = (LArIATFragmentDump &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  TTree *               fCaenDataTree;        ///< Tree holding the data from the CAEN fragments 
  TTree *               fWutDataTree;         ///< Tree holding the data from the WUT fragments 
  TTree *               fTdcDataTree;         ///< Tree holding the data from the TDC fragments 
  std::string           fRawFragmentLabel;    ///< label for module producing artdaq fragments
  std::string  		    fRawFragmentInstance; ///< instance label for artdaq fragments        
  uint16_t              fSpill;               ///< Spill number

  // variables that will go into fWutDataTree
  uint16_t wut_spill;
  uint16_t wut_fragment_id;
  uint32_t wut_time_header;  // Each count in the time header is 16 us
  uint16_t wut_number_hits;
  std::vector<uint16_t> wut_hit_channel;
  std::vector<uint32_t> wut_hit_time_bin;
  std::vector<uint64_t> wut_hit_time;
  // variables that will go into fCaenDataTree
  uint16_t v1751_spill;
  uint16_t v1751_fragment_id;
  uint32_t v1751_trigger_time_tag;  // Each count in the trigger time tag is 8 ns
  std::vector<uint16_t> v1751_ustof1_logic;
  std::vector<uint16_t> v1751_ustof2_logic;
  std::vector<uint16_t> v1751_ustof3_logic;
  std::vector<uint16_t> v1751_ustof4_logic;
  std::vector<uint16_t> v1751_dstof1_logic;
  std::vector<uint16_t> v1751_dstof2_logic;
  // variables that will go into fTdcDataTree
  uint16_t tdc_spill;
  uint16_t tdc_fragment_id;
  uint16_t tdc_trigger_id;  // event_id
  uint16_t tdc_trigger_counter;
  uint16_t tdc_controller_time_stamp;
  uint32_t tdc_time_stamp;
  uint32_t tdc_total_hits;
  std::vector<uint16_t> tdc_number;
  std::vector<uint16_t> tdc_hit_channel;
  std::vector<uint16_t> tdc_hit_time_bin;
};


//------------------------------------------------------------------------------
rdu::LArIATFragmentDump::LArIATFragmentDump(fhicl::ParameterSet const & p)
  : EDAnalyzer(p)
{
  this->reconfigure(p);
}

//------------------------------------------------------------------------------
void rdu::LArIATFragmentDump::reconfigure(fhicl::ParameterSet const & p)
{
  fRawFragmentLabel    = p.get< std::string >("RawFragmentLabel", "daq");
  fRawFragmentInstance = p.get< std::string >("RawFragmentInstance", "SPILL");
}

//------------------------------------------------------------------------------
void rdu::LArIATFragmentDump::beginJob()
{

  size_t wut_max_hits_capacity = 4 * 128;

  wut_hit_channel.reserve(wut_max_hits_capacity);
  wut_hit_time_bin.reserve(wut_max_hits_capacity);

  v1751_ustof1_logic.reserve(1792);
  v1751_ustof2_logic.reserve(1792);
  v1751_ustof3_logic.reserve(1792);
  v1751_ustof4_logic.reserve(1792);
  v1751_dstof1_logic.reserve(1792);
  v1751_dstof2_logic.reserve(1792);

  size_t tdc_max_hits_capacity = TDCFragment::MAX_TDCS * TDCFragment::MAX_HITS;

  tdc_number.reserve(tdc_max_hits_capacity);
  tdc_hit_channel.reserve(tdc_max_hits_capacity);
  tdc_hit_time_bin.reserve(tdc_max_hits_capacity);

  art::ServiceHandle<art::TFileService> tfs;

  //fWutDataTree = tfs->make<TTree>("WutData", "WutData");
  fWutDataTree = tfs->make<TTree>("wut", "wut");
  //fWutDataTree->Branch("spill",                 &fWUT.wut_spill);
  fWutDataTree->Branch("fragment_id", &wut_fragment_id, "fragment_id/s");
  fWutDataTree->Branch("time_header", &wut_time_header, "time_header/i");
  fWutDataTree->Branch("total_hits", &wut_number_hits, "total_hits/s");
  fWutDataTree->Branch("hit_channel", wut_hit_channel.data(),
                       "hit_channel[total_hits]/s");
  fWutDataTree->Branch("hit_time_bin", wut_hit_time_bin.data(),
                       "hit_time_bin[total_hits]/i");

  //fCaenDataTree = tfs->make<TTree>("CaenData", "CaenData");
  fCaenDataTree = tfs->make<TTree>("v1751", "v1751");
  //fCaenDataTree->Branch("spill",                 &fCAEN.caen_spill);
  fCaenDataTree->Branch("fragment_id", &v1751_fragment_id, "fragment_id/s");
  fCaenDataTree->Branch("trigger_time_tag", &v1751_trigger_time_tag,
                        "trigger_time_tag/i");
  fCaenDataTree->Branch("ustof1_logic", v1751_ustof1_logic.data(),
                        "ustof1_logic[1792]/s");
  fCaenDataTree->Branch("ustof2_logic", v1751_ustof2_logic.data(),
                        "ustof2_logic[1792]/s");
  fCaenDataTree->Branch("ustof3_logic", v1751_ustof3_logic.data(),
                        "ustof3_logic[1792]/s");
  fCaenDataTree->Branch("ustof4_logic", v1751_ustof4_logic.data(),
                        "ustof4_logic[1792]/s");
  fCaenDataTree->Branch("dstof1_logic", v1751_dstof1_logic.data(),
                        "dstof1_logic[1792]/s");
  fCaenDataTree->Branch("dstof2_logic", v1751_dstof2_logic.data(),
                        "dstof2_logic[1792]/s");

  ////fTdcDataTree = tfs->make<TTree>("TdcData", "TdcData");
  ////fTdcDataTree = tfs->make<TTree>("tdc", "tdc");
  fTdcDataTree = tfs->make<TTree>("mwpc", "mwpc");

  //fTdcDataTree->Branch("spill", &tdc_spill, "spill/s");
  //fTdcDataTree->Branch("fragment_id", &tdc_fragment_id, "fragment_id/s");
  fTdcDataTree->Branch("trigger_id", &tdc_trigger_id, "trigger_id/s");
  fTdcDataTree->Branch("controller_time_stamp", &tdc_controller_time_stamp,
                       "controller_time_stamp/s");
  fTdcDataTree->Branch("tdc_time_stamp", &tdc_time_stamp, "tdc_time_stamp/i");
  fTdcDataTree->Branch("total_hits", &tdc_total_hits, "total_hits/i");
  fTdcDataTree->Branch("tdc_number", tdc_number.data(),
                       "tdc_number[total_hits]/s");
  fTdcDataTree->Branch("hit_channel", tdc_hit_channel.data(),
                       "hit_channel[total_hits]/s");
  fTdcDataTree->Branch("hit_time_bin", tdc_hit_time_bin.data(),
                       "hit_time_bin[total_hits]/s");

  return;
}

//------------------------------------------------------------------------------
void rdu::LArIATFragmentDump::analyze(art::Event const & evt)
{
  art::Handle< std::vector<artdaq::Fragment> > fragments;
  evt.getByLabel(fRawFragmentLabel, fRawFragmentInstance, fragments);

  if( !fragments.isValid() )
    throw cet::exception("LARIATFragementReader") << "artdaq::Fragment handle is not valid, bail";
  if( fragments->size() != 1 )
    throw cet::exception("LARIATFragementReader") << "artdaq::Fragment handle contains more than one fragment, bail";

  // this does not return the spill number...
  fSpill = (uint16_t) evt.id().event();
  //fSpill = (uint16_t) evt.event();

  art::EventNumber_t spillNumber = evt.event();

  // get the fragments we are interested in
  const auto& frag((*fragments)[0]);

  const char * bytePtr = reinterpret_cast<const char *> (&*frag.dataBegin());
  LariatFragment * data = new LariatFragment((char *) bytePtr,
      frag.dataSize() * sizeof(unsigned long long));
  std::cout << "Have data fragment "
            << frag.dataSize() * sizeof(unsigned long long)
            << std::endl;
  data->print();

  std::cout << "Run: " << evt.run() << "; subrun: " << evt.subRun()
            << "; spill: " << fSpill << std::endl;

  std::cout << "Spill number: " << spillNumber << std::endl;

  const size_t numberWutFrags = data->wutFrags.size();
  std::cout << "Found " << numberWutFrags << " WUT fragments" << std::endl;

  if (numberWutFrags > 0) {
    std::cout << "Looking at WUT fragments..." << std::endl;
  }

  for (size_t i = 0; i < numberWutFrags; ++i) {
    WUTFragment & wutFrag = data->wutFrags[i];
    wutFrag.print();
    uint32_t numberWutHits = wutFrag.header.nHits;
    //std::cout << "  WUT fragment ID: " << i << std::endl;
    std::cout << "  Number of WUT hits: " << numberWutHits << std::endl;
    std::vector<WUTFragment::WutHit> & hits = wutFrag.hits;

    wut_hit_channel.clear();
    wut_hit_time_bin.clear();
    wut_hit_time.clear();

    wut_fragment_id = i;
    wut_number_hits = (uint16_t) wutFrag.header.nHits;
    wut_time_header = wutFrag.header.timeHeader;

    std::cout << "WUT spill counter: "
              << wutFrag.header.spillCounter
              << std::endl;

    for (size_t j = 0; j < numberWutHits; ++j) {
      WUTFragment::WutHit & hit = hits[j];

      wut_hit_channel.push_back((uint16_t) hit.channel);
      wut_hit_time_bin.push_back(hit.timeBin);
    }
    fWutDataTree->Fill();
  }

  const size_t numberCaenFrags = data->caenFrags.size();
  std::cout << "Found " << numberCaenFrags << " CAEN fragments" << std::endl;

  if (numberCaenFrags > 0) {
    std::cout << "Looking at CAEN fragments..." << std::endl;
  }

  for (size_t i = 0; i < numberCaenFrags; ++i) {
    CAENFragment & caenFrag = data->caenFrags[i];
    if (caenFrag.header.boardId == 8) {
      caenFrag.print();

      std::cout << "CAEN event counter: "
                << caenFrag.header.eventCounter
                << std::endl;

      v1751_fragment_id = caenFrag.header.eventCounter;
      v1751_trigger_time_tag = caenFrag.header.triggerTimeTag;

      v1751_ustof1_logic.clear();
      v1751_ustof2_logic.clear();
      v1751_ustof3_logic.clear();
      v1751_ustof4_logic.clear();
      v1751_dstof1_logic.clear();
      v1751_dstof2_logic.clear();

      for (size_t sample = 0; sample < caenFrag.header.nSamples; ++sample) {
        v1751_ustof1_logic.push_back(caenFrag.waveForms[2].data[sample]);
        v1751_ustof2_logic.push_back(caenFrag.waveForms[3].data[sample]);
        v1751_ustof3_logic.push_back(caenFrag.waveForms[4].data[sample]);
        v1751_ustof4_logic.push_back(caenFrag.waveForms[5].data[sample]);
        v1751_dstof1_logic.push_back(caenFrag.waveForms[6].data[sample]);
        v1751_dstof2_logic.push_back(caenFrag.waveForms[7].data[sample]);
      }

      fCaenDataTree->Fill();
    }
  }

  const size_t numberTdcFrags = data->tdcFrags.size();
  std::cout << "Found " << numberTdcFrags << " TDC fragments" << std::endl;

  if (numberTdcFrags > 0) {
    std::cout << "Looking at TDC fragments..." << std::endl;
  }

  for (size_t i = 0; i < numberTdcFrags; ++i) {
    TDCFragment & tdcFrag = data->tdcFrags[i];

    std::vector< std::vector<TDCFragment::TdcEventData> > &
        tdcEvents = tdcFrag.tdcEvents;

    std::cout << "TDC spill counter: "
              << tdcFrag.controllerHeader.spillCounter
              << std::endl;

    std::cout << "tdcEvents.size(): " << tdcEvents.size() << std::endl;
    tdcFrag.print();

    for (size_t j = 0; j < tdcEvents.size(); ++j) {

      tdc_trigger_id = j;

      std::cout << "TDC event index: " << j << std::endl;
      tdc_number.clear();
      tdc_hit_channel.clear();
      tdc_hit_time_bin.clear();

      tdc_total_hits = 0;

      for (size_t tdc_index = 0; tdc_index < TDCFragment::MAX_TDCS;
           ++tdc_index) {

        TDCFragment::TdcEventData tdcEventData = tdcEvents[j].at(tdc_index);

        tdc_controller_time_stamp = tdcEventData.tdcEventHeader.controllerTimeStamp;
        tdc_time_stamp = tdcEventData.tdcEventHeader.tdcTimeStamp;
        tdc_trigger_counter = tdcEventData.tdcEventHeader.triggerCounter;

        tdc_total_hits += tdcEventData.tdcEventHeader.nHits;

        //std::cout << "TDC number: " << tdcEventData.tdcEventHeader.tdcNumber << std::endl;
        //std::cout << "TDC number of hits: " << tdcEventData.tdcEventHeader.nHits << std::endl;
        //std::cout << "TDC trigger counter: " << tdc_trigger_counter << std::endl;

        if (tdc_trigger_counter != (uint32_t) j+1) {
          std::cout << "TDC event index and TDC trigger counter mismatch!" << std::endl;
        }

        for (size_t hit_index = 0; hit_index < tdcEventData.tdcHits.size();
             ++hit_index) {
          TDCFragment::TdcHit & hit = tdcEventData.tdcHits[hit_index];
          tdc_hit_channel.push_back((uint16_t) hit.channel);
          tdc_hit_time_bin.push_back(hit.timeBin);
          tdc_number.push_back(tdc_index + 1);
        }

        if (tdcEventData.tdcEventHeader.nHits == 0) continue;
      }
      if (tdc_total_hits == 0) continue;
      fTdcDataTree->Fill();
    }
  }

  return;  
}

DEFINE_ART_MODULE(rdu::LArIATFragmentDump)
