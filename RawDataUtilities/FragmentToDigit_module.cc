////////////////////////////////////////////////////////////////////////
// Class:       FragmentToDigit
// Module Type: producer
// File:        FragmentToDigit_module.cc
//
// Generated at Mon Dec  1 11:28:13 2014 by Will Flanagan using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
// TODO
//////////////////////////////////////////////////////////////
// [x] Add CAEN V1751 board 0
// [x] Add CAEN V1751 board 1
// [x] Add channels 31 to 63 of CAEN V1740 board 7
// [x] Add CAEN V1740 channels for boards 0-6 and channels 0
//     to 31 of board 7 to TPC RawDigits
// [x] Add WUT
// [x] Add MWPCs
// [x] Put Pawel's OpDetPulse modifications back in (Pawel)
// [x] Add data block matching algorithm
// [x] Add trigger associations (Brian)
// [ ] Set the trigger bits correctly (Brian)
// [x] Determine the pedestals for the RawDigits 
// [ ] Add helpful comments throughout code. This may never be
//     checked off.
//////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "artdaq-core/Data/Fragment.hh"

#include "LArIATFragments/LariatFragment.h"
#include "LArIATFragments/WUTFragment.h"
#include "LArIATFragments/CAENFragment.h"
#include "LArIATFragments/TDCFragment.h"

#include "SimpleTypesAndConstants/RawTypes.h"
#include "RawData/RawDigit.h"
#include "RawData/AuxDetDigit.h"
#include "RawData/OpDetPulse.h"
#include "RawData/TriggerData.h"
#include "SummaryData/RunData.h"
#include "Geometry/Geometry.h"
#include "Utilities/AssociationUtil.h"

//#include "TTree.h"
#include "TGraph.h"
#include "TF1.h"

#include <memory>
#include <functional>
#include <vector>
#include <string>
#include <algorithm>
#include <initializer_list>
#include <bitset>

enum {
  V1740_N_CHANNELS = 64,
  V1751_N_CHANNELS = 8,
  WUT_N_TDC_CHANNELS = 16,
  WUT_MAX_HITS = 128,
};

// ugly nested map for matching data blocks
typedef std::map< std::string, std::map< std::string, std::map< unsigned int, std::vector<unsigned int> > > > match_map;

class FragmentToDigit;

class FragmentToDigit : public art::EDProducer {
public:
  explicit FragmentToDigit(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  FragmentToDigit(FragmentToDigit const &) = delete;
  FragmentToDigit(FragmentToDigit &&) = delete;
  FragmentToDigit & operator = (FragmentToDigit const &) = delete;
  FragmentToDigit & operator = (FragmentToDigit &&) = delete;

  // Required functions.
  void produce(art::Event & evt) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void beginRun(art::Run &run);
  void matchDataBlocks(LariatFragment * data);

  void coarseMatch(std::string const& deviceALabel,
		   std::string const& deviceBLabel,
		   double             range[2],
		   std::map< std::string, std::map<unsigned int, double> > timeStamps,
		   match_map        & matchMap);

  void fineMatch(std::string               const& deviceALabel,
		 std::string 		   const& deviceBLabel,
		 double      		          range[2],    
		 std::pair<double, double> const& fitParameters,
		 std::map< std::string, std::map<unsigned int, double> > timeStamps,
		 match_map                      & matchMap);

  void printMatchMap(std::string const& deviceALabel,
		     std::string const& deviceBLabel,
		     match_map        & matchMap);

  double line(std::pair<double, double> const& parameters, 
	      double                    const& x);

  std::pair<double, double> fitDrift(std::string const& deviceALabel,
				     std::string const& deviceBLabel,
				     std::map< std::string, std::map<unsigned int, double> > timeStamps,
				     match_map        & matchMap,
				     std::string const& graphNamePrefix);

  void matchFragments(uint32_t            & Ntriggers,
		      std::vector<size_t> & fv1751InTrigger,
		      std::vector<size_t> & fv1740InTrigger,
		      std::vector<size_t> & fTDCInTrigger,
		      LariatFragment*       data);

  uint32_t triggerBits               (std::vector<CAENFragment>     const& caenFrags);   				  
  void     makeTPCRawDigits          (std::vector<CAENFragment>     const& caenFrags,    	
			     	      std::vector<raw::RawDigit>         & tpcDigits);   	
  float    findPedestal              (const std::vector<short>           & adcVec);	     
  void     makeOpDetPulses           (std::vector<CAENFragment>     const& caenFrags,    	       
       	   			      std::vector<raw::OpDetPulse>       & opDetPulse);  	       
  void 	   makeMuonRangeDigits	     (std::vector<CAENFragment>     const& caenFrags,    	       
				      std::vector<raw::AuxDetDigit>      & mrAuxDigits); 	       
  void 	   makeTOFDigits             (std::vector<CAENFragment>     const& caenFrags,    	       
				      std::vector<raw::AuxDetDigit>      & tofAuxDigits);	       
  void 	   makeAeroGelDigits         (std::vector<CAENFragment>     const& caenFrags,    	       
				      std::vector<raw::AuxDetDigit>      & agAuxDigits); 	       
  void 	   caenFragmentToAuxDetDigits(std::vector<CAENFragment>     const& caenFrags,	       
				      std::vector<raw::AuxDetDigit>      & auxDetDigits,	       
				      uint32_t                      const& boardId,		       
				      std::set<uint32_t>            const& boardChans,	       
				      uint32_t                      const& chanOffset,	       
				      std::string                   const& detName);	       
  void 	   makeMWPCDigits            (std::vector<TDCFragment::TdcEventData> const& tdcFrags,      
				      std::vector<raw::AuxDetDigit>               & mwpcAuxDigits);

  void LinFitUnweighted(const std::vector<double>& x,
			const std::vector<double>& y,
			double& m, double& c);

  void makeCaenV1751AuxDetDigits(int i, 
				 LariatFragment*                                    data,
				 std::unique_ptr< std::vector<raw::AuxDetDigit> > & caenV1751Board0Vec,
				 std::unique_ptr< std::vector<raw::AuxDetDigit> > & caenV1751Board1Vec,
				 std::unique_ptr<std::vector< raw::OpDetPulse > > & OpDetVec2,
				 std::unique_ptr<std::vector< raw::OpDetPulse > > & OpDetVec1);
  void makeCaenV1740AuxDetDigits(int i,
				 LariatFragment * data,
				 std::unique_ptr< std::vector<raw::AuxDetDigit> > & caenV1740Board7Vec);
  void makeMWPCTDCAuxDetDigits(int i, LariatFragment * data,
			       std::vector< std::reference_wrapper< std::unique_ptr< std::vector<raw::AuxDetDigit> > > > & mwpcTdcVecs,
			       std::string mwpcTdcLabels[16]);
  void makeWUTDigits(LariatFragment*                                    data,
		     std::unique_ptr< std::vector<raw::AuxDetDigit> > & wutVec);

private:

  art::ServiceHandle<art::TFileService> tfs;

  std::string fRawFragmentLabel;     ///< label for module producing artdaq fragments
  std::string fRawFragmentInstance;  ///< instance label for artdaq fragments        

  std::string fCaenV1740Board0Label;
  std::string fCaenV1740Board1Label;
  std::string fCaenV1740Board2Label;
  std::string fCaenV1740Board3Label;
  std::string fCaenV1740Board4Label;
  std::string fCaenV1740Board5Label;
  std::string fCaenV1740Board6Label;
  std::string fCaenV1740Board7Label;
  std::string fCaenV1751Board0Label;
  std::string fCaenV1751Board1Label;
  std::string fCaenOpLabel1;
  std::string fCaenOpLabel2;
  std::string fWutLabel;
  std::string fMwpcTdc01Label;
  std::string fMwpcTdc02Label;
  std::string fMwpcTdc03Label;
  std::string fMwpcTdc04Label;
  std::string fMwpcTdc05Label;
  std::string fMwpcTdc06Label;
  std::string fMwpcTdc07Label;
  std::string fMwpcTdc08Label;
  std::string fMwpcTdc09Label;
  std::string fMwpcTdc10Label;
  std::string fMwpcTdc11Label;
  std::string fMwpcTdc12Label;
  std::string fMwpcTdc13Label;
  std::string fMwpcTdc14Label;
  std::string fMwpcTdc15Label;
  std::string fMwpcTdc16Label;
  bool fPMTTest;

  // variables from the SpillTrailer fragments
  uint32_t runNumber;
  uint32_t spillNumber;
  uint32_t timeStamp;

  uint32_t fNtriggers;
  std::vector<size_t> fv1751InTrigger;
  std::vector<size_t> fv1740InTrigger;
  std::vector<size_t> fTDCInTrigger;

  // maps for matching fragments
  std::map< std::string, std::map<unsigned int, double> > fFragTimeStamps;
  match_map fPreliminaryMatches;
  match_map fMatches;

  std::vector<std::vector<unsigned int>> fOpDetChID;
};

//------------------------------------------------------------------------------
FragmentToDigit::FragmentToDigit(fhicl::ParameterSet const & p)
  : fNtriggers(0)
{
  this->reconfigure(p);

  ///\todo At some point we want to store the POT for each run in the file

  produces< sumdata::RunData, art::InRun >();

  produces< std::vector<raw::RawDigit>    >();

  //-----COMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//
  produces< std::vector<raw::Trigger>     >();
  produces< std::vector<raw::AuxDetDigit> >();
  produces< std::vector<raw::OpDetPulse>  >();
  produces< art::Assns<raw::Trigger, raw::RawDigit>    >();
  produces< art::Assns<raw::Trigger, raw::AuxDetDigit> >();
  produces< art::Assns<raw::Trigger, raw::OpDetPulse>  >();
  //-----COMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//



  //-----UNCOMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//
  // produces< std::vector<raw::AuxDetDigit> >(fCaenV1740Board7Label);
  // produces< std::vector<raw::AuxDetDigit> >(fCaenV1751Board0Label);
  // produces< std::vector<raw::AuxDetDigit> >(fCaenV1751Board1Label);
  // produces< std::vector<raw::AuxDetDigit> >(fWutLabel);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc01Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc02Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc03Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc04Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc05Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc06Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc07Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc08Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc09Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc10Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc11Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc12Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc13Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc14Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc15Label);
  // produces< std::vector<raw::AuxDetDigit> >(fMwpcTdc16Label);
  // produces< std::vector<raw::OpDetPulse> >(fCaenOpLabel1);
  // produces< std::vector<raw::OpDetPulse> >(fCaenOpLabel2);
  //-----UNCOMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//
}

//------------------------------------------------------------------------------
void FragmentToDigit::reconfigure(fhicl::ParameterSet const & p)
{
  fRawFragmentLabel = p.get< std::string >("RawFragmentLabel", "daq");
  fRawFragmentInstance = p.get< std::string >("RawFragmentInstance", "SPILL");
  
  fOpDetChID      = p.get< std::vector<std::vector<unsigned int>> >("pmt_channel_ids");
  fPMTTest = p.get<bool> ("pmt_test");

  for(size_t i = 0; i < fOpDetChID.size(); ++i){
    for(size_t j = 0; j < fOpDetChID[i].size(); ++j)   
      LOG_VERBATIM("FragmentToDigit") << "channels and boards for opdetpulses : board - channel "
				      << i << " - " << j << " " << fOpDetChID[i][j];
  }

  fWutLabel             = p.get< std::string >("WutLabel",             "Wut"              );
  fCaenV1740Board0Label = p.get< std::string >("CaenV1740Board0Label", "CaenV1740Board0"  );
  fCaenV1740Board1Label = p.get< std::string >("CaenV1740Board1Label", "CaenV1740Board1"  );
  fCaenV1740Board2Label = p.get< std::string >("CaenV1740Board2Label", "CaenV1740Board2"  );
  fCaenV1740Board3Label = p.get< std::string >("CaenV1740Board3Label", "CaenV1740Board3"  );
  fCaenV1740Board4Label = p.get< std::string >("CaenV1740Board4Label", "CaenV1740Board4"  );
  fCaenV1740Board5Label = p.get< std::string >("CaenV1740Board5Label", "CaenV1740Board5"  );
  fCaenV1740Board6Label = p.get< std::string >("CaenV1740Board6Label", "CaenV1740Board6"  );
  fCaenV1740Board7Label = p.get< std::string >("CaenV1740Board7Label", "CaenV1740Board7"  );
  fCaenV1751Board0Label = p.get< std::string >("CaenV1751Board0Label", "CaenV1751Board0"  );
  fCaenV1751Board1Label = p.get< std::string >("CaenV1751Board1Label", "CaenV1751Board1"  );
  fMwpcTdc01Label       = p.get< std::string >("MwpcTdc01Label",       "MwpcTdc01"        );
  fMwpcTdc02Label	= p.get< std::string >("MwpcTdc02Label",       "MwpcTdc02"	  );
  fMwpcTdc03Label	= p.get< std::string >("MwpcTdc03Label",       "MwpcTdc03"	  );
  fMwpcTdc04Label	= p.get< std::string >("MwpcTdc04Label",       "MwpcTdc04"	  );
  fMwpcTdc05Label	= p.get< std::string >("MwpcTdc05Label",       "MwpcTdc05"	  );
  fMwpcTdc06Label	= p.get< std::string >("MwpcTdc06Label",       "MwpcTdc06"	  );
  fMwpcTdc07Label	= p.get< std::string >("MwpcTdc07Label",       "MwpcTdc07"	  );
  fMwpcTdc08Label	= p.get< std::string >("MwpcTdc08Label",       "MwpcTdc08"	  );
  fMwpcTdc09Label	= p.get< std::string >("MwpcTdc09Label",       "MwpcTdc09"	  );
  fMwpcTdc10Label	= p.get< std::string >("MwpcTdc10Label",       "MwpcTdc10"	  );
  fMwpcTdc11Label	= p.get< std::string >("MwpcTdc11Label",       "MwpcTdc11"	  );
  fMwpcTdc12Label	= p.get< std::string >("MwpcTdc12Label",       "MwpcTdc12"	  );
  fMwpcTdc13Label	= p.get< std::string >("MwpcTdc13Label",       "MwpcTdc13"	  );
  fMwpcTdc14Label	= p.get< std::string >("MwpcTdc14Label",       "MwpcTdc14"	  );
  fMwpcTdc15Label	= p.get< std::string >("MwpcTdc15Label",       "MwpcTdc15"	  );
  fMwpcTdc16Label	= p.get< std::string >("MwpcTdc16Label",       "MwpcTdc16"	  );
  fCaenOpLabel1         = p.get< std::string >("OpDetBoardLabel1",     "Caenv1751Optical1");
  fCaenOpLabel2         = p.get< std::string >("OpDetBoardLabel2",     "Caenv1751Optical2");

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::beginJob()
{
  //art::ServiceHandle<art::TFileService> tfs;

  //fV1751V1740DriftPreliminary = tfs->make<TGraph>();
  //fV1751MwpcDriftPreliminary  = tfs->make<TGraph>();
  //fV1740MwpcDriftPreliminary  = tfs->make<TGraph>();

  return;
}

//____________________________________________________________________________
void FragmentToDigit::beginRun(art::Run& run)
{
  
  // grab the geometry object to see what geometry we are using
  art::ServiceHandle<geo::Geometry> geo;
  
  std::unique_ptr<sumdata::RunData> runcol(new sumdata::RunData(geo->DetectorName()));
  
  run.put(std::move(runcol));
  
  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::produce(art::Event & evt)
{
  //-----COMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//
  std::unique_ptr< std::vector<raw::Trigger>     > triggerVec (new std::vector<raw::Trigger    >);
  std::unique_ptr< std::vector<raw::RawDigit>    > rawDigitVec(new std::vector<raw::RawDigit   >);
  std::unique_ptr< std::vector<raw::AuxDetDigit> > auxDetVec  (new std::vector<raw::AuxDetDigit>);
  std::unique_ptr< std::vector<raw::OpDetPulse>  > opDetVec   (new std::vector<raw::OpDetPulse >);

  std::unique_ptr< art::Assns<raw::Trigger, raw::RawDigit>    > tdRDAssns(new art::Assns<raw::Trigger, raw::RawDigit>   );
  std::unique_ptr< art::Assns<raw::Trigger, raw::AuxDetDigit> > tdADAssns(new art::Assns<raw::Trigger, raw::AuxDetDigit>);
  std::unique_ptr< art::Assns<raw::Trigger, raw::OpDetPulse>  > tdOPAssns(new art::Assns<raw::Trigger, raw::OpDetPulse> );
  //-----COMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//

  art::Handle< std::vector<artdaq::Fragment> > fragments;
  evt.getByLabel(fRawFragmentLabel, fRawFragmentInstance, fragments);

  if ( !fragments.isValid() )
      throw cet::exception("FragmentToDigit") << "artdaq::Fragment handle is not valid, bail";
  if ( fragments->size() != 1 )
      throw cet::exception("FragmentToDigit") << "artdaq::Fragment handle contains more than one fragment, bail";

  // get the fragments we are interested in
  const auto& frag((*fragments)[0]);

  const char * bytePtr = reinterpret_cast<const char *> (&*frag.dataBegin());
  LariatFragment * data = new LariatFragment((char *) bytePtr, frag.dataSize() * sizeof(unsigned long long));
  mf::LogInfo("FragmentToDigit") << "Have data fragment "
				 << frag.dataSize() * sizeof(unsigned long long);
  data->print();
  data->printSpillTrailer();

  LariatFragment::SpillTrailer & spillTrailer = data->spillTrailer;
  runNumber = spillTrailer.runNumber;
  spillNumber = spillTrailer.spillNumber;
  timeStamp   = spillTrailer.timeStamp;

  mf::LogInfo("FragmentToDigit") << "evt.run(): " << evt.run()
				 << "; evt.subRun(): " << evt.subRun()
				 << "; evt.event(): " << evt.event()
				 << "; evt.time().timeLow(): " << evt.time().timeLow()
				 << "; evt.time().timeHigh(): " << evt.time().timeHigh()
				 << "\nrunNumber: " << runNumber << "; spillNumber: " << spillNumber
				 << "; timeStamp: " << timeStamp;

  this->matchDataBlocks(data);
  this->matchFragments(fNtriggers, fv1751InTrigger, fv1740InTrigger, fTDCInTrigger, data);
  //this->printMatchMap(fCaenV1740Board0Label, fCaenV1740Board1Label, fMatches);

  LOG_INFO("FragmentToDigit") << "Ntriggers is: " << fNtriggers 
			      << "\nThe size of v1751InTrigger is: " << fv1751InTrigger.size()
			      << "\nThe size of v1740InTrigger is: " << fv1740InTrigger.size()
			      << "\nThe size of TDCInTrigger is:   " << fTDCInTrigger.size();

  //-----COMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//
  std::vector<CAENFragment>              caenFrags;	 
  std::vector<raw::AuxDetDigit>          auxDigits;	 
  std::vector<raw::RawDigit>    	 rawDigits;	 
  std::vector<raw::OpDetPulse>   	 opPulses;	 
  size_t                         	 startAssns = 0;
  size_t                         	 endAssns   = 0;
  double                                 eventTime  = 1.*evt.time().timeHigh() + 1.*evt.time().timeLow();

  // remove the next two lines of code when we verify that the trigger 
  // matching also includes the TPC data
  this->makeTPCRawDigits(data->caenFrags, rawDigits);
  for(auto rd : rawDigits) rawDigitVec->push_back(rd);

  for(size_t i = 0; i < fNtriggers; ++i) {

    caenFrags.clear();
    auxDigits.clear();
    rawDigits.clear();
    opPulses .clear();

    mf::LogInfo("FragmentToDigit") << "Trigger " << i 
				   << " has a V1751 Fragment with index "  << fv1751InTrigger[i] 
				   <<"\n and a V1740 Fragment with index " << fv1740InTrigger[i];

    if(fTDCInTrigger.size() > 0) 
      mf::LogInfo("FragmentToDigit") << ", and a TDC Fragment with index " << fTDCInTrigger[i];

    if(fv1751InTrigger[i]) caenFrags.push_back(data->caenFrags[fv1751InTrigger[i]]);
    if(fv1740InTrigger[i]) caenFrags.push_back(data->caenFrags[fv1740InTrigger[i]]);

    if(fTDCInTrigger.size() > 0 && fTDCInTrigger[i]){
      // if the size of the number of TDCs from the fragment does not match the 
      // number of the tdcEvents, then continue to the next one without doing anything
      if (data->tdcFrags[0].controllerHeader.nTDCs != data->tdcFrags[0].tdcEvents[fTDCInTrigger[i]].size()) {
	mf::LogError("FragmentToDigit") << "*** Fatal nTDCs mismatch: " 
					<< data->tdcFrags[0].tdcEvents[fTDCInTrigger[i]].size()
					<< " != " << data->tdcFrags[0].controllerHeader.nTDCs
					<< " cannot make MWPC digits";
      }
      else
	this->makeMWPCDigits(data->tdcFrags[0].tdcEvents[fTDCInTrigger[i]],  auxDigits);
    }

    // put a trigger object in the output vector
    triggerVec->push_back(raw::Trigger(i, caenFrags.front().header.triggerTimeTag, eventTime, this->triggerBits(caenFrags)));

    // make each association type as you go putting the digits into the vectors

    // uncomment the next line when we are sure that the fragments
    // are matched for the TPC data as well
    // this->makeTPCRawDigits(caenFrags, rawDigits);
    //startAssns = rawDigitVec->size();
    //for(auto rd : rawDigits) rawDigitVec->push_back(rd);
    //endAssns = rawDigitVec->size();
    //util::CreateAssn(*this, evt, *triggerVec, *rawDigitVec, *tdRDAssns, startAssns, endAssns);

    if(fPMTTest){
      this->makeOpDetPulses(caenFrags, opPulses);

      startAssns = opDetVec->size();
      for(auto op : opPulses) opDetVec->push_back(op);
      endAssns = opDetVec->size();
      util::CreateAssn(*this, evt, *triggerVec, *opDetVec, *tdOPAssns, startAssns, endAssns);
    }

    // putting all the AuxDetDigits from the different detectors into a single
    // vector in the event record.  They can be separated out by the detector
    // name data member of the AuxDetDigit later.  Doing it this way makes 
    // creating the associations easier.
    this->makeMuonRangeDigits(caenFrags, auxDigits);
    this->makeTOFDigits      (caenFrags, auxDigits);
    this->makeAeroGelDigits  (caenFrags, auxDigits);

    startAssns = auxDetVec->size();
    for(auto ad : auxDigits) auxDetVec->push_back(ad);
    endAssns = auxDetVec->size();
    util::CreateAssn(*this, evt, *triggerVec, *auxDetVec, *tdADAssns, startAssns, endAssns);
  }

  this->makeWUTDigits(data, auxDetVec);

  evt.put(std::move(triggerVec));
  evt.put(std::move(rawDigitVec));
  evt.put(std::move(auxDetVec));
  evt.put(std::move(opDetVec));
  evt.put(std::move(tdRDAssns));
  evt.put(std::move(tdADAssns));
  evt.put(std::move(tdOPAssns));
  //-----COMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//


  //-----UNCOMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > caenV1740Board7Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > caenV1751Board0Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > caenV1751Board1Vec(new std::vector<raw::AuxDetDigit>);

  // std::unique_ptr< std::vector<raw::AuxDetDigit> > wutVec(new std::vector<raw::AuxDetDigit>);

  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc01Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc02Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc03Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc04Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc05Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc06Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc07Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc08Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc09Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc10Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc11Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc12Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc13Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc14Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc15Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr< std::vector<raw::AuxDetDigit> > mwpcTdc16Vec(new std::vector<raw::AuxDetDigit>);
  // std::unique_ptr<std::vector< raw::OpDetPulse > > OpDetVec1(new std::vector<raw::OpDetPulse>);
  // std::unique_ptr<std::vector< raw::OpDetPulse > > OpDetVec2(new std::vector<raw::OpDetPulse>);

  // // the following line is way too long
  // std::vector< std::reference_wrapper< std::unique_ptr< std::vector<raw::AuxDetDigit> > > > mwpcTdcVecs = {
  //   mwpcTdc01Vec, mwpcTdc02Vec, mwpcTdc03Vec, mwpcTdc04Vec,
  //   mwpcTdc05Vec, mwpcTdc06Vec, mwpcTdc07Vec, mwpcTdc08Vec,
  //   mwpcTdc09Vec, mwpcTdc10Vec, mwpcTdc11Vec, mwpcTdc12Vec,
  //   mwpcTdc13Vec, mwpcTdc14Vec, mwpcTdc15Vec, mwpcTdc16Vec
  // };

  // std::string mwpcTdcLabels[16] = {
  //     fMwpcTdc01Label, fMwpcTdc02Label, fMwpcTdc03Label, fMwpcTdc04Label,
  //     fMwpcTdc05Label, fMwpcTdc06Label, fMwpcTdc07Label, fMwpcTdc08Label,
  //     fMwpcTdc09Label, fMwpcTdc10Label, fMwpcTdc11Label, fMwpcTdc12Label,
  //     fMwpcTdc13Label, fMwpcTdc14Label, fMwpcTdc15Label, fMwpcTdc16Label
  //     };

  //produce wvforms for all triggers in selected channels in v1751 if PMTTest is set to true - skip matching for them
  // if (fPMTTest){
  //   for(size_t i=0;i<data->caenFrags.size();++i){
  //     this->makeCaenV1751AuxDetDigits(i, data, caenV1751Board0Vec, caenV1751Board1Vec, OpDetVec1, OpDetVec2);
  //   }
  // }

  // for(size_t i = 0; i < fNtriggers; ++i) {
  //   mf::LogInfo("FragmentToDigit") << "Trigger " << i 
  // 				   << " has a V1751 Fragment with index "  << fv1751InTrigger[i] 
  // 				   <<"\n and a V1740 Fragment with index " << fv1740InTrigger[i];

  //   if(fTDCInTrigger.size() > 0) 
  //     mf::LogInfo("FragmentToDigit") << ", and a TDC Fragment with index " << fTDCInTrigger[i];

  //   if(fv1751InTrigger[i]){
  //     this->makeCaenV1751AuxDetDigits(fv1751InTrigger[i], data, 
  //     				      caenV1751Board0Vec, caenV1751Board1Vec, 
  //     				      OpDetVec1, OpDetVec2);
  //   }
  //   if(fv1740InTrigger[i]){
  //     this->makeCaenV1740AuxDetDigits(fv1740InTrigger[i], data, caenV1740Board7Vec);
  //   }

  //   if(fTDCInTrigger.size() > 0 && fTDCInTrigger[i]){
  //     this->makeMWPCTDCAuxDetDigits(fTDCInTrigger[i], data, mwpcTdcVecs, mwpcTdcLabels);
  //   }
  // }

  // this->makeWUTDigits(data, wutVec);

  // evt.put(std::move(caenV1740Board7Vec), fCaenV1740Board7Label);
  // evt.put(std::move(caenV1751Board0Vec), fCaenV1751Board0Label);
  // evt.put(std::move(caenV1751Board1Vec), fCaenV1751Board1Label);
  // evt.put(std::move(OpDetVec1), fCaenOpLabel1);
  // evt.put(std::move(OpDetVec2), fCaenOpLabel2);
  // evt.put(std::move(wutVec), fWutLabel);

  // for (size_t i = 0; i < TDCFragment::MAX_TDCS; ++i) {
  //   evt.put(std::move(mwpcTdcVecs[i].get()), mwpcTdcLabels[i]);
  // }
  //-----UNCOMMENT BETWEEN LINES TO RECOVER PREVIOUS FUNCTIONALITY----------------//

  fv1751InTrigger.clear();
  fv1740InTrigger.clear();
  fTDCInTrigger.clear();

  return;  
}

//......................................................................
void FragmentToDigit::LinFitUnweighted(const std::vector<double>& x,
				       const std::vector<double>& y,
				       double& m, double& c)
{
  // Before going ahead, make sure we have sensible arrays
  if(x.size() != y.size())
    throw cet::exception("FragmentToDigit") << "cannot do linear fit, vectors are different sizes "
					    << "x: " << x.size() << " y: " << y.size();
  if(x.size() < 2)
    throw cet::exception("FragmentToDigit") << "cannot do linear fit, not enough points "
					    << "x: " << x.size() << " y: " << y.size();
  
  // Accumulate the sums for the fit
  double Sx  = 0;
  double Sy  = 0;
  double Sxy = 0;
  double Sy2 = 0;
  double Sx2 = 0;
  const unsigned int I = x.size();
  for(unsigned int i = 0; i < I; ++i) {
    Sx  += x[i];
    Sy  += y[i];
    Sx2 += x[i]*x[i];
    Sxy += x[i]*y[i];
    Sy2 += y[i]*y[i];
  }
  const double d = I*Sx2 - Sx*Sx;
  m = (I*Sxy  - Sx*Sy)/d;
  c = (Sy*Sx2 - Sx*Sxy)/d;
  
  return;
}

//-----------------------------------------------------------------------------------
void FragmentToDigit::matchDataBlocks(LariatFragment * data) 
{

  //std::map< std::string, std::map<unsigned int, double> > fFragTimeStamps;

  //////////////////////////////////////////////////////////////////////
  // Some notes
  //////////////////////////////////////////////////////////////////////
  //
  // There are multiple CAEN fragments and only one TDC fragment for
  // each spill. Each TDC fragment holds multiple TDC events.
  //
  // Since there are multiple CAEN fragments and only one TDC fragment
  // per spill, I will use the term "data block" to refer to a single
  // CAEN fragment or a single TDC event.
  //
  // fFragTimeStamps will store the data block time stamps from all
  // devices (except the WUT) to help with the matching.
  //
  // Here is some pseudocode on how to access the time stamps:
  //
  // for deviceLabel in devices:
  //     for dataBlockIndex in dataBlocks:
  //         dataBlockTimeStamp = fFragTimeStamps[deviceLabel][dataBlockIndex];
  //
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: loop through the data blocks to get their time stamps
  //          into fFragTimeStamps
  //////////////////////////////////////////////////////////////////////

  size_t numberCaenDataBlocks[10] = {};
  size_t numberMwpcDataBlocks = 0;

  std::string caenLabels[10] = {
    fCaenV1740Board0Label,
    fCaenV1740Board1Label,
    fCaenV1740Board2Label,
    fCaenV1740Board3Label,
    fCaenV1740Board4Label,
    fCaenV1740Board5Label,
    fCaenV1740Board6Label,
    fCaenV1740Board7Label,
    fCaenV1751Board0Label,
    fCaenV1751Board1Label
  };

  std::string mwpcTdcLabels[TDCFragment::MAX_TDCS] = {
      fMwpcTdc01Label,
      fMwpcTdc02Label,
      fMwpcTdc03Label,
      fMwpcTdc04Label,
      fMwpcTdc05Label,
      fMwpcTdc06Label,
      fMwpcTdc07Label,
      fMwpcTdc08Label,
      fMwpcTdc09Label,
      fMwpcTdc10Label,
      fMwpcTdc11Label,
      fMwpcTdc12Label,
      fMwpcTdc13Label,
      fMwpcTdc14Label,
      fMwpcTdc15Label,
      fMwpcTdc16Label
  };

  const size_t numberCaenFrags = data->caenFrags.size();
  LOG_DEBUG("FragmentToDigit") << "Found " << numberCaenFrags << " CAEN fragments";

  if (numberCaenFrags > 0) 
    LOG_DEBUG("FragmentToDigit") << "Looking at CAEN fragments...";

  for (size_t i = 0; i < numberCaenFrags; ++i) {
    CAENFragment & caenFrag = data->caenFrags[i];
    unsigned int boardId = static_cast <unsigned int> (caenFrag.header.boardId);
    std::string label = caenLabels[boardId];
    unsigned int index = numberCaenDataBlocks[boardId];
    // each CAEN Trigger Time Tag count is 8 ns
    double timeStamp = caenFrag.header.triggerTimeTag * 0.008;  // convert to microseconds
    fFragTimeStamps[label][index] = timeStamp;
    numberCaenDataBlocks[boardId] += 1;
  }

  const int numberTdcFrags = data->tdcFrags.size();
  LOG_DEBUG("FragmentToDigit") << "Found " << numberTdcFrags << " TDC fragments";

  if (numberTdcFrags > 0) 
    LOG_DEBUG("FragmentToDigit") << "Looking at TDC fragments...";
  

  for (int i = 0; i < numberTdcFrags; ++i) {

    TDCFragment & tdcFrag = data->tdcFrags[i];

    std::vector< std::vector<TDCFragment::TdcEventData> > &tdcEvents = tdcFrag.tdcEvents;

    //LOG_DEBUG("FragmentToDigit")
    //    << "tdcEvents.size(): " << tdcEvents.size();
    //tdcFrag.print();

    numberMwpcDataBlocks = tdcEvents.size();

    for (size_t j = 0; j < tdcEvents.size(); ++j) {

      if (tdcFrag.controllerHeader.nTDCs != tdcEvents[j].size()) {
        mf::LogError("FragmentToDigit") << "*** Fatal nTDCs mismatch: " << tdcEvents[j].size()
				<< " != " << tdcFrag.controllerHeader.nTDCs<< " "<< j;
	continue;
      }

      LOG_DEBUG("FragmentToDigit") << "TDC event: " << j;

      for (size_t tdc_index = 0; tdc_index < TDCFragment::MAX_TDCS; ++tdc_index) {
        TDCFragment::TdcEventData tdcEventData = tdcEvents[j].at(tdc_index);

        uint16_t controllerTimeStamp = tdcEventData.tdcEventHeader.controllerTimeStamp;
        uint32_t tdcTimeStamp = tdcEventData.tdcEventHeader.tdcTimeStamp;
        // each TDC Time Stamp count is 1/106.208 microseconds
        double timeStamp = tdcEventData.tdcEventHeader.tdcTimeStamp / 106.208;  // convert to microseconds

        std::string label = mwpcTdcLabels[tdc_index];

        LOG_DEBUG("FragmentToDigit") << "  TDC index: " << tdc_index;
        LOG_DEBUG("FragmentToDigit") << "  Label: " << label;
        LOG_DEBUG("FragmentToDigit") << "  TDC time stamp: " << tdcTimeStamp;
        LOG_DEBUG("FragmentToDigit") << "  Controller time stamp: " << controllerTimeStamp;

        fFragTimeStamps[label][j] = timeStamp;

      }
    }
  }

  // let's forget the WUT for now
  //const int numberWutFrags = data->wutFrags.size();
  //LOG_DEBUG("FragmentToDigit")
  //    << "Found " << numberWutFrags << " WUT fragments";

  //////////////////////////////////////////////////////////////////////
  //@\ END: loop through the data blocks to get their time stamps
  //        into fFragTimeStamps
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: loop through fFragTimeStamps to check that they are there
  //////////////////////////////////////////////////////////////////////

  for (size_t i = 0; i < 10; ++i) {
    std::string label = caenLabels[i];
    unsigned int indices = numberCaenDataBlocks[i];
    LOG_DEBUG("FragmentToDigit") << "Board ID: " << i << ", number of data blocks: " << numberCaenDataBlocks[i];
    LOG_DEBUG("FragmentToDigit") << "Label: " << label;
    for (size_t j = 0; j < indices; ++j) {
      LOG_DEBUG("FragmentToDigit") << "  Index: " << j;
      LOG_DEBUG("FragmentToDigit") << "  Time stamp: " << fFragTimeStamps[label][j];
    }
  }

  for (size_t i = 0; i < TDCFragment::MAX_TDCS; ++i) {
    std::string label = mwpcTdcLabels[i];
    LOG_DEBUG("FragmentToDigit") << "TDC index: " << i << ", number of data blocks: " << numberMwpcDataBlocks;
    LOG_DEBUG("FragmentToDigit") << "Label: " << label;
    for (size_t j = 0; j < numberMwpcDataBlocks; ++j) {
      LOG_DEBUG("FragmentToDigit") << "  Index: " << j;
      LOG_DEBUG("FragmentToDigit") << "  Time stamp: " << fFragTimeStamps[label][j];
    }
  }

  //////////////////////////////////////////////////////////////////////
  //@\ END: loop through fFragTimeStamps to check that they are there
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: intra V1740/V1751 matching
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  // NOTE: The master clocks of the V1740s is boardId 0; the master
  //       clock of the V1751s is boardId 8.
  //////////////////////////////////////////////////////////////////////

  // the difference in time stamps should be in between this range for a match; microseconds
  double v1740IntraRange[2] = { -0.016, 0.016 };
  double v1751IntraRange[2] = { -0.016, 0.016 };

  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board1Label, v1740IntraRange, fFragTimeStamps, fMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board2Label, v1740IntraRange, fFragTimeStamps, fMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board3Label, v1740IntraRange, fFragTimeStamps, fMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board4Label, v1740IntraRange, fFragTimeStamps, fMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board5Label, v1740IntraRange, fFragTimeStamps, fMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board6Label, v1740IntraRange, fFragTimeStamps, fMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board7Label, v1740IntraRange, fFragTimeStamps, fMatches);
  coarseMatch(fCaenV1751Board0Label, fCaenV1751Board1Label, v1751IntraRange, fFragTimeStamps, fMatches);

  //printMatchMap(fCaenV1740Board0Label, fCaenV1740Board1Label, fMatches);
  //printMatchMap(fCaenV1740Board0Label, fCaenV1740Board2Label, fMatches);
  //printMatchMap(fCaenV1740Board0Label, fCaenV1740Board3Label, fMatches);
  //printMatchMap(fCaenV1740Board0Label, fCaenV1740Board4Label, fMatches);
  //printMatchMap(fCaenV1740Board0Label, fCaenV1740Board5Label, fMatches);
  //printMatchMap(fCaenV1740Board0Label, fCaenV1740Board6Label, fMatches);
  //printMatchMap(fCaenV1751Board0Label, fCaenV1751Board1Label, fMatches);

  //////////////////////////////////////////////////////////////////////
  //@\ END: intra V1740/V1751 matching
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: coarse matching
  //////////////////////////////////////////////////////////////////////

  // the difference in time stamps should be in between this range for a match; microseconds
  double v1751v1740InterRange[2] = { 2,   5 };
  double v1751MwpcInterRange[2]  = { 0, 160 };
  double v1740MwpcInterRange[2]  = { 0, 160 };

  std::map< std::string, std::map< std::string, std::pair<double, double> > > fitParameters;

  coarseMatch(fCaenV1751Board0Label, fCaenV1740Board0Label, v1751v1740InterRange, fFragTimeStamps, fPreliminaryMatches);
  coarseMatch(fCaenV1751Board0Label, fMwpcTdc01Label,       v1751MwpcInterRange,  fFragTimeStamps, fPreliminaryMatches);
  coarseMatch(fCaenV1740Board0Label, fMwpcTdc01Label, 	    v1740MwpcInterRange,  fFragTimeStamps, fPreliminaryMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board1Label, v1751v1740InterRange, fFragTimeStamps, fPreliminaryMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board2Label, v1751v1740InterRange, fFragTimeStamps, fPreliminaryMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board3Label, v1751v1740InterRange, fFragTimeStamps, fPreliminaryMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board4Label, v1751v1740InterRange, fFragTimeStamps, fPreliminaryMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board5Label, v1751v1740InterRange, fFragTimeStamps, fPreliminaryMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board6Label, v1751v1740InterRange, fFragTimeStamps, fPreliminaryMatches);
  coarseMatch(fCaenV1740Board0Label, fCaenV1740Board7Label, v1751v1740InterRange, fFragTimeStamps, fPreliminaryMatches);

  //printMatchMap(fCaenV1751Board0Label, fCaenV1740Board0Label, fPreliminaryMatches);
  //printMatchMap(fCaenV1751Board0Label, fMwpcTdc01Label, fPreliminaryMatches);
  //printMatchMap(fCaenV1740Board0Label, fMwpcTdc01Label, fPreliminaryMatches);

  fitParameters[fCaenV1751Board0Label][fCaenV1740Board0Label] = fitDrift(fCaenV1751Board0Label, fCaenV1740Board0Label, fFragTimeStamps, fPreliminaryMatches, "coarse_match");
  fitParameters[fCaenV1751Board0Label][fMwpcTdc01Label]       = fitDrift(fCaenV1751Board0Label, fMwpcTdc01Label,       fFragTimeStamps, fPreliminaryMatches, "coarse_match");
  fitParameters[fCaenV1740Board0Label][fMwpcTdc01Label]       = fitDrift(fCaenV1740Board0Label, fMwpcTdc01Label,       fFragTimeStamps, fPreliminaryMatches, "coarse_match");
  fitParameters[fCaenV1740Board0Label][fCaenV1740Board1Label] = fitDrift(fCaenV1740Board0Label, fCaenV1740Board1Label, fFragTimeStamps, fPreliminaryMatches, "coarse_match");
  fitParameters[fCaenV1740Board0Label][fCaenV1740Board2Label] = fitDrift(fCaenV1740Board0Label, fCaenV1740Board2Label, fFragTimeStamps, fPreliminaryMatches, "coarse_match");
  fitParameters[fCaenV1740Board0Label][fCaenV1740Board3Label] = fitDrift(fCaenV1740Board0Label, fCaenV1740Board3Label, fFragTimeStamps, fPreliminaryMatches, "coarse_match");
  fitParameters[fCaenV1740Board0Label][fCaenV1740Board4Label] = fitDrift(fCaenV1740Board0Label, fCaenV1740Board4Label, fFragTimeStamps, fPreliminaryMatches, "coarse_match");
  fitParameters[fCaenV1740Board0Label][fCaenV1740Board5Label] = fitDrift(fCaenV1740Board0Label, fCaenV1740Board5Label, fFragTimeStamps, fPreliminaryMatches, "coarse_match");
  fitParameters[fCaenV1740Board0Label][fCaenV1740Board6Label] = fitDrift(fCaenV1740Board0Label, fCaenV1740Board6Label, fFragTimeStamps, fPreliminaryMatches, "coarse_match");
  fitParameters[fCaenV1740Board0Label][fCaenV1740Board7Label] = fitDrift(fCaenV1740Board0Label, fCaenV1740Board7Label, fFragTimeStamps, fPreliminaryMatches, "coarse_match");

  //////////////////////////////////////////////////////////////////////
  //@\ END: coarse matching
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: fine matching
  //////////////////////////////////////////////////////////////////////

  double v1751v1740InterEps[2] = { 1, 1 };
  double v1751MwpcInterEps[2]  = { 1, 1 };
  double v1740MwpcInterEps[2]  = { 1, 1 };

  fineMatch(fCaenV1751Board0Label, fCaenV1740Board0Label, v1751v1740InterEps, fitParameters[fCaenV1751Board0Label][fCaenV1740Board0Label], fFragTimeStamps, fMatches);
  fineMatch(fCaenV1751Board0Label, fMwpcTdc01Label,       v1751MwpcInterEps,  fitParameters[fCaenV1751Board0Label][fMwpcTdc01Label],       fFragTimeStamps, fMatches);
  fineMatch(fCaenV1740Board0Label, fMwpcTdc01Label, 	  v1740MwpcInterEps,  fitParameters[fCaenV1740Board0Label][fMwpcTdc01Label], 	   fFragTimeStamps, fMatches);
  fineMatch(fCaenV1740Board0Label, fCaenV1740Board1Label, v1740MwpcInterEps,  fitParameters[fCaenV1740Board0Label][fCaenV1740Board1Label], fFragTimeStamps, fMatches);
  fineMatch(fCaenV1740Board0Label, fCaenV1740Board2Label, v1740MwpcInterEps,  fitParameters[fCaenV1740Board0Label][fCaenV1740Board2Label], fFragTimeStamps, fMatches);
  fineMatch(fCaenV1740Board0Label, fCaenV1740Board3Label, v1740MwpcInterEps,  fitParameters[fCaenV1740Board0Label][fCaenV1740Board3Label], fFragTimeStamps, fMatches);
  fineMatch(fCaenV1740Board0Label, fCaenV1740Board4Label, v1740MwpcInterEps,  fitParameters[fCaenV1740Board0Label][fCaenV1740Board4Label], fFragTimeStamps, fMatches);
  fineMatch(fCaenV1740Board0Label, fCaenV1740Board5Label, v1740MwpcInterEps,  fitParameters[fCaenV1740Board0Label][fCaenV1740Board5Label], fFragTimeStamps, fMatches);
  fineMatch(fCaenV1740Board0Label, fCaenV1740Board6Label, v1740MwpcInterEps,  fitParameters[fCaenV1740Board0Label][fCaenV1740Board6Label], fFragTimeStamps, fMatches);
  fineMatch(fCaenV1740Board0Label, fCaenV1740Board7Label, v1740MwpcInterEps,  fitParameters[fCaenV1740Board0Label][fCaenV1740Board7Label], fFragTimeStamps, fMatches);

  fitParameters[fCaenV1751Board0Label][fCaenV1740Board0Label] = fitDrift(fCaenV1751Board0Label, fCaenV1740Board0Label, fFragTimeStamps, fMatches, "fine_match");
  fitParameters[fCaenV1751Board0Label][fMwpcTdc01Label]       = fitDrift(fCaenV1751Board0Label, fMwpcTdc01Label,       fFragTimeStamps, fMatches, "fine_match");
  fitParameters[fCaenV1740Board0Label][fMwpcTdc01Label]       = fitDrift(fCaenV1740Board0Label, fMwpcTdc01Label,       fFragTimeStamps, fMatches, "fine_match");

  //////////////////////////////////////////////////////////////////////
  //@\ END: fine matching
  //////////////////////////////////////////////////////////////////////

  return;
}

//-----------------------------------------------------------------------------------
void FragmentToDigit::coarseMatch(std::string const& deviceALabel,
				  std::string const& deviceBLabel,
				  double             range[2],
				  std::map< std::string, std::map<unsigned int, double> > timeStamps,
				  match_map        & matchMap) 
{
  
  std::map< unsigned int, std::vector<unsigned int> > matchAB;

  size_t numberADataBlocks = timeStamps[deviceALabel].size();
  size_t numberBDataBlocks = timeStamps[deviceBLabel].size();

  for (size_t a = 0; a < numberADataBlocks; ++a) {
    double timeStampA = timeStamps[deviceALabel][a];
    for (size_t b = 0; b < numberBDataBlocks; ++b) {
      double timeStampB = timeStamps[deviceBLabel][b];
      double difference = timeStampA - timeStampB;
      if (range[0] <= difference and difference <= range[1]) {
        matchAB[a].push_back(b);
      }
    }
  }

  matchMap[deviceALabel][deviceBLabel] = matchAB;

  return;
}

//-----------------------------------------------------------------------------------
void FragmentToDigit::fineMatch(std::string               const& deviceALabel,
				std::string 		  const& deviceBLabel,
				double      		         eps[2],      
				std::pair<double, double> const& fitParameters,
				std::map< std::string, std::map<unsigned int, double> > timeStamps,
				match_map                      & matchMap) 
{

  std::map< unsigned int, std::vector<unsigned int> > matchAB;

  size_t numberADataBlocks = timeStamps[deviceALabel].size();
  size_t numberBDataBlocks = timeStamps[deviceBLabel].size();

  for (size_t a = 0; a < numberADataBlocks; ++a) {
    double timeStampA = timeStamps[deviceALabel][a];
    for (size_t b = 0; b < numberBDataBlocks; ++b) {
      double timeStampB = timeStamps[deviceBLabel][b];
      double difference = timeStampA - timeStampB;
      double y = line(fitParameters, timeStampA);
      double yLow = y - eps[0];
      double yHigh = y + eps[1];
      if (yLow <= difference and difference <= yHigh) {
        matchAB[a].push_back(b);
      }
    }
  }

  matchMap[deviceALabel][deviceBLabel] = matchAB;

  return;
}

//-----------------------------------------------------------------------------------
double FragmentToDigit::line(std::pair<double, double> const& parameters, 
			     double                    const& x) 
{
  double intercept = parameters.first;
  double slope = parameters.second;
  return intercept + slope * x;
}

//-----------------------------------------------------------------------------------
std::pair<double, double> FragmentToDigit::fitDrift(std::string const& deviceALabel,
						    std::string const& deviceBLabel,
						    std::map< std::string, std::map<unsigned int, double> > timeStamps,
						    match_map        & matchMap,
						    std::string const& graphNamePrefix) 
{

  std::vector<double> x;
  std::vector<double> y;

  std::vector<double> x_;
  std::vector<double> y_;

  std::map< unsigned int, std::vector<unsigned int> > matchAB = matchMap[deviceALabel][deviceBLabel];

  LOG_DEBUG("FragmentToDigit") << "Matches between " << deviceALabel << " and " << deviceBLabel;
  LOG_DEBUG("FragmentToDigit") << "  Matching index pair format: " << "(" << deviceALabel << ", " << deviceBLabel << ")";

  for (auto const & itA : matchAB) {
    LOG_DEBUG("FragmentToDigit") << "  Index: " << itA.first << "; number of matches: " << itA.second.size();
    for (auto const & itB : itA.second) {
      double timeStampA = timeStamps[deviceALabel][itA.first];
      double timeStampB = timeStamps[deviceBLabel][itB];
      double difference = timeStampA - timeStampB;
      double reference = timeStampA;
      LOG_DEBUG("FragmentToDigit") << "    (" << itA.first << ", " << itB << ")"
				   << "; difference: " << difference << " usec"
				   << "; reference: " << reference << " usec";
      if (itA.second.size() == 1) {
        x.push_back(reference);
        y.push_back(difference);
      }
      else {
        x_.push_back(reference);
        y_.push_back(difference);
      }
    }
  }

  // std::string graphName = graphNamePrefix + "_drift_" + deviceALabel + "_" + deviceBLabel;
  // std::string graphTitles = ("; Time since beginning of spill (using " + deviceALabel 
  // 			     + " clock) [#mus]; #Delta t between "     + deviceALabel 
  // 			     + " and " + deviceBLabel + " [#mus]");

  // TGraph * graph = tfs->make<TGraph>(x.size(), &x[0], &y[0]);
  // TF1 * f = tfs->make<TF1>("f", "pol1", 0, 30e6);
  // graph->Fit("f", "Q");
  // graph->SetMarkerStyle(20);
  // graph->SetTitle(graphTitles.c_str());
  // graph->Write(graphName.c_str());
  // LOG_DEBUG("FragmentToDigit") << "Fit parameters: intercept, "
  // 			       << f->GetParameter(0) << " usec; slope, "
  // 			       << f->GetParameter(1) << " usec/usec";

  // return std::make_pair<double, double>(f->GetParameter(0), f->GetParameter(1));
  
  std::pair<double, double> intSlp(0.,0.);

  try{
    this->LinFitUnweighted(x, y, intSlp.second, intSlp.first);
  }
  catch(cet::exception &e){
    LOG_WARNING("FragmentToDigit") << "caught exception:\n" << e
				   << "\n returning intercept = 0 and slope = 0";
  }

  return intSlp;
}

//------------------------------------------------------------------------------
void FragmentToDigit::printMatchMap(std::string const& deviceALabel,
				    std::string const& deviceBLabel,
				    match_map        & matchMap) 
{

  std::map< unsigned int, std::vector<unsigned int> > matchAB = matchMap[deviceALabel][deviceBLabel];

  LOG_DEBUG("FragmentToDigit") << "Matches between " << deviceALabel << " and " << deviceBLabel
			       << "\n Matching index pair format: " << "(" 
			       << deviceALabel << ", " << deviceBLabel << ")";

  for (auto const & itA : matchAB) {
    for (auto const & itB : itA.second) {
      LOG_DEBUG("FragmentToDigit") << "  (" << itA.first << ", " << itB << ")";
    }
  }

  return;
}

//----------------------------------------------------------------------------------------------
// Matching v1751, v1740, and TDC fragments
// CAEN triggerTimeTag must be multiplied by 0.008 to get microseconds since the start of spill
// TDC tdcTimeStamp must be divided by 106.208 to get microseconds since the start of spill
// I am currently calling triggers within 200 microseconds a match
void FragmentToDigit::matchFragments(uint32_t & fNtriggers,
                                     std::vector<size_t> & fv1751InTrigger,
                                     std::vector<size_t> & fv1740InTrigger,
                                     std::vector<size_t> & fTDCInTrigger,
                                     LariatFragment * data)
{

  size_t v1751FragNumber = 1;
  size_t numberOf1740Matches = 0;
  size_t numberOfTDCMatches = 0;

  LOG_DEBUG("FragmentToDigit") << "Lets do some fragment timestamp matching so that we can group triggers...";

  const size_t numberCaenFrags = data->caenFrags.size();
  LOG_DEBUG("FragmentToDigit") << "Found " << numberCaenFrags << " CAEN fragments";

  const int numberTdcFrags = data->tdcFrags.size();
  LOG_DEBUG("FragmentToDigit") << "Found " << numberTdcFrags << " TDC fragments";

  if (numberCaenFrags > 0)
    LOG_DEBUG("FragmentToDigit") << "Begin trigger matching against V1751 CAEN fragments...";

  for (size_t i = 0; i < numberCaenFrags; ++i) {

    numberOf1740Matches = 0;
    numberOfTDCMatches = 0;
    CAENFragment & caenFrag = data->caenFrags[i];

    if (caenFrag.header.boardId == 9) {

      fv1751InTrigger.push_back(i);
      LOG_DEBUG("FragmentToDigit") << "v1751 fragment number "<< v1751FragNumber 
				     << " at t=" << caenFrag.header.triggerTimeTag*0.008 << "us";

      for (size_t k = 0; k < numberCaenFrags; ++k) {

        CAENFragment & secondCaenFrag = data->caenFrags[k];

        if (secondCaenFrag.header.boardId == 7 && std::abs(secondCaenFrag.header.triggerTimeTag*0.008 - caenFrag.header.triggerTimeTag*0.008)<200) {

          ++numberOf1740Matches;
          if(numberOf1740Matches == 1) fv1740InTrigger.push_back(k);

        }

      }

      if(numberOf1740Matches == 0) fv1740InTrigger.push_back(0);
      LOG_DEBUG("FragmentToDigit") << " has " << numberOf1740Matches << " matching v1740 fragments ";


      // There is always one TDC fragment, so I am no longer looping over TDC fragments.
      // Different TDC triggers can be found by looping over TDC events

      //if( data->tdcFrags.size() < 1) continue;
      if( data->tdcFrags.size() >0){
	TDCFragment & tdcFrag = data->tdcFrags[0];
	
	for (size_t l = 0; l < tdcFrag.tdcEvents.size(); ++l) {
	  
	  if (std::abs(tdcFrag.tdcEvents[l].at(0).tdcEventHeader.tdcTimeStamp/106.208 - caenFrag.header.triggerTimeTag*0.008)<200) {
	    
	    ++numberOfTDCMatches;
	    if(numberOfTDCMatches == 1) fTDCInTrigger.push_back(l);	    
	  }
	}//end loop over tdcEvents

	if(numberOfTDCMatches == 0) fTDCInTrigger.push_back(0);
	LOG_DEBUG("FragmentToDigit") << " and " << numberOfTDCMatches << " matching TDC fragments ";
      }
      ++v1751FragNumber;
      LOG_DEBUG("FragmentToDigit") << "At i=" << i << "  v1751FragNumber:" << v1751FragNumber;
    }

  }

  fNtriggers=v1751FragNumber-1;

}

//------------------------------------------------------------------------------
uint32_t FragmentToDigit::triggerBits(std::vector<CAENFragment> const& caenFrags)
{

  // the trigger bits are piped into the V1740 board in slot 7, inputs 48 to 63
  // these are example connections as of May 04, 2015
  // 0   WC1      | OR of 2 X view TDCs ANDed with OR of 2 Y
  // 1   WC2      | "                                      " 
  // 2   WC3      | "                                      " 
  // 3   WC4      | "                                      " 
  // 4   BEAMON   | Spill gate : STARTs on $21, STOPs on $36 (cable says $26 but Bill says $36)
  // 5   USTOF    | OR of 4 PMTs
  // 6   DSTOF    | OR of 2 PMTs
  // 7   PUNCH    | OR of 2 X view paddles ANDed with OR of 2 Y
  // 8   HALO     | OR of 2 PMTs
  // 9   PULSER   |
  // 10  COSMICON | Cosmic gate : STARTs on $36, STOPs on $00 (not optimal, would like to stop before $00)
  // 11  COSMIC   | the trigger signal from the cosmic rack
  // 12  SC1 CFD  |
  // 13  MICHEL   | Coincidence of two light flashes in TPC (LARSCINT) occurring within a 5us time window
  // 14  LARSCINT | Coincidence of Hamamatsu and ETL PMTs (discriminated)
  // 15  MuRS     | Any coincidence of two planes.  Each plane is the OR of the discriminated pulses of 4 paddles.  

  // Each waveform corresponds to a single trigger channel.  If the (pedestal subtracted?) value of any ADC
  // in a waveform is less than 0, then the trigger for that channel fired

  std::bitset<16> triggerBits;

  size_t minChan  = 48;
  size_t maxChan  = 64;
  float  pedestal = 0.;
  for(auto const& frag : caenFrags){

    if(frag.header.boardId != 7) continue;

      for(size_t chan = minChan; chan < maxChan; ++chan){ 
	if(chan > frag.waveForms.size() )
	  throw cet::exception("FragmentToDigit") << "attempting to access channel "
						  << chan << " from 1740 fragment with only "
						  << frag.waveForms.size() << " channels";

	std::vector<short> const trig(frag.waveForms[chan].data.begin(), frag.waveForms[chan].data.end());
	pedestal = this->findPedestal(trig);
	for(auto const& data : trig){
	  if(data < pedestal) triggerBits.set(chan - minChan);
	}
      } // end loop over channels on the board
  }

  return triggerBits.to_ulong();
}  

//------------------------------------------------------------------------------
void FragmentToDigit::makeTPCRawDigits(std::vector<CAENFragment> const& caenFrags,
				       std::vector<raw::RawDigit>     & tpcDigits)
{
  raw::ChannelID_t tpcChan = 0;
  size_t maxChan = 64;
  size_t boardId = 0;

  // make a list of the starting wire number for each board channel 0
  size_t startWireInd[8] = {239, 175, 111, 47,   0,   0,   0, 0 };
  size_t startWireCol[8] = {0,   0,   0,   239, 223, 159, 95, 31};
 
  for(auto const& frag : caenFrags){
    
    // the TPC mapping has the readout going to boards 0-7 of
    // the CAEN 1751, channels 0-63 of the boards 0-6, channels 0-31 of board 7
    // To make things hard, we decided to count the wires down instead of up
    // Board 0 channel 0  --> wire 239 of the induction plane
    // Board 3 channel 48 --> wire 0   of the induction plane
    // Board 3 channel 49 --> wire 239 of the collection plane
    // Board 7 channel 32 --> wire 0   of the collection plane
    boardId = frag.header.boardId;
    if(boardId > 7) continue;
    else{
      if(boardId < 7) maxChan = 64;
      else maxChan = 32;
      for(size_t chan = 0; chan < maxChan; ++chan){ 
	if(chan > frag.waveForms.size() )
	  throw cet::exception("FragmentToDigit") << "attempting to access channel "
						  << chan << " from 1740 fragment with only "
						  << frag.waveForms.size() << " channels";

	// get TPC channel for the induction plane
	if( boardId < 3 || (boardId == 3 && chan < 48) )
	  tpcChan = startWireInd[boardId] - chan;
	// get TPC Channel for the collection plane
	else if( boardId > 3)
	  tpcChan = 240 + startWireCol[boardId] - chan;
	else if(boardId == 3 && chan > 47)
	  tpcChan = 240 + startWireCol[boardId] - chan + 48;

	std::vector<short> const adc(frag.waveForms[chan].data.begin(), frag.waveForms[chan].data.end());
	raw::RawDigit rd(tpcChan, adc.size(), adc);
	rd.SetPedestal(this->findPedestal(adc));
	tpcDigits.push_back(rd);
      } // end loop to fill channels from this board
    }// end if it is a TPC board      
  }// end loop over caen fragments

  return;
  
}

//------------------------------------------------------------------------------
float FragmentToDigit::findPedestal(const std::vector<short> & adcVec)
{
  // do nothing if there are no values in the vector
  if(adcVec.size() < 1) return 0.;

  // for now try taking the simple mean of the values in the 
  // vector and return that as the pedestal
  float mean = 0.;
  for(auto const& adc : adcVec) mean += adc;
  mean /= 1.*adcVec.size();

  return mean;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeOpDetPulses(std::vector<CAENFragment>    const& caenFrags,
				      std::vector<raw::OpDetPulse>      & opDetPulse)
{
  // loop over the caenFrags
  uint32_t boardId        = 0;
  uint32_t triggerTimeTag = 0;
  for(auto const& caenFrag : caenFrags){

    boardId        = caenFrag.header.boardId;
    triggerTimeTag = caenFrag.header.triggerTimeTag;
    
    if(fOpDetChID[boardId].size() > 0){

      // loop over the channels on this board connected to optical detectors
      for(auto ch : fOpDetChID[boardId]){

	// check that the current channel, ch, is a valid one for grabbing a waveform
	if(ch > caenFrag.waveForms.size() )
	  throw cet::exception("FragmentToDigit") << "requested channel, " << ch 
						  << " from board "        << boardId
						  << " is beyond the scope of the waveform vector";

	std::vector<short> waveForm(caenFrag.waveForms[ch].data.begin(), caenFrag.waveForms[ch].data.end());
   
	mf::LogInfo("FragmentToDigit") << "Writing opdetpulses " 
				       << " boardID : " << boardId 
				       << " channel " << ch 
				       << " size of wvform data " << waveForm.size()
				       << " fOpDetChID[boardId] size() " << fOpDetChID[boardId].size();

	opDetPulse.push_back(raw::OpDetPulse(static_cast <unsigned short> (ch),
					     waveForm,
					     0,
					     static_cast <unsigned int> (triggerTimeTag)
					     )
			     );

      } // end loop over channels on this board
    } // end if this board has optical channels on it
  } // end loop over fragments

  return;
}

//------------------------------------------------------------------------------
// boardId is the ID of the board we want to grab the digits from
// boardChans holds the channels on that board that we care about for this
// set of digits we want to make
// chanOffset is the value we subtract from the board channel so that the 
// digits have the right channel range for the desired auxiliary detector (ie 
// channel 0 of the muon range stack is not necessarily on channel 0 of the 
// caen board)
// detName is the name of the detector
void FragmentToDigit::caenFragmentToAuxDetDigits(std::vector<CAENFragment>     const& caenFrags,
						 std::vector<raw::AuxDetDigit>      & auxDetDigits,
						 uint32_t                      const& boardId,
						 std::set<uint32_t>            const& boardChans,
						 uint32_t                      const& chanOffset,
						 std::string                   const& detName)
{
  // loop over the fragments and grab the one corresponding to this board ID
  for(auto const& frag : caenFrags){

    if(frag.header.boardId != boardId) continue;

    // loop over the channels in the set
    for( auto const& ch : boardChans){
      
      // check that ch is larger than chanOffset
      if(ch < chanOffset)
	throw cet::exception("FragmentToDigit") << "requested channel, " << ch
						<< " is smaller than the requested offest "
						<< chanOffset;

      // check that there is a waveform for the chosen channel
      if(ch > frag.waveForms.size() )
	throw cet::exception("FragmentToDigit") << "requested channel, " << ch 
						<< " from board "        << boardId
						<< " is beyond the scope of the waveform vector";
      
      std::vector<short> waveForm(frag.waveForms[ch].data.begin(), frag.waveForms[ch].data.end());
	
      // place the AuxDetDigit in the vector
      auxDetDigits.push_back(raw::AuxDetDigit(static_cast<unsigned short> (ch - chanOffset),
					      waveForm,
					      detName,
					      static_cast<unsigned long long>(frag.header.triggerTimeTag))
			     );

    } // end loop over channels on the board
  } // end loop over fragments
  
  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeMuonRangeDigits(std::vector<CAENFragment>     const& caenFrags,
					  std::vector<raw::AuxDetDigit>      & mrAuxDigits)
{
  // The Muon Range Stack channels are all on the V1740 board in slot 7
  // The channels are 32 <= ch < 48
  uint32_t boardId = 7;
  uint32_t chanOff = 32;
  std::set<uint32_t> boardChans;
  for(uint32_t bc = chanOff; bc < 48; ++bc) boardChans.insert(bc);

  this->caenFragmentToAuxDetDigits(caenFrags, mrAuxDigits, boardId, boardChans, chanOff, "MuonRangeStack");

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeTOFDigits(std::vector<CAENFragment>     const& caenFrags,
				    std::vector<raw::AuxDetDigit>      & tofAuxDigits)
{
  // TOF inputs are all sent to board 8
  uint32_t boardId = 8;
  uint32_t chanOff = 0;
  std::set<uint32_t> boardChans;
  for(uint32_t bc = chanOff; bc < 4; ++bc) boardChans.insert(bc);

  this->caenFragmentToAuxDetDigits(caenFrags, tofAuxDigits, boardId, boardChans, chanOff, "TOF");

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeAeroGelDigits(std::vector<CAENFragment>     const& caenFrags,
					std::vector<raw::AuxDetDigit>      & agAuxDigits)
{
  // Aerogel inputs are all sent to board 8
  uint32_t boardId = 8;
  uint32_t chanOff = 4;
  std::set<uint32_t> boardChans;
  for(uint32_t bc = chanOff; bc < 8; ++bc) boardChans.insert(bc);

  this->caenFragmentToAuxDetDigits(caenFrags, agAuxDigits, boardId, boardChans, chanOff, "AeroGel");

  return;
}

//------------------------------------------------------------------------------
// set the name of the detector in the AuxDetDigit to be of the form
// MWPCXX where XX is the controller Number
// The map below indicates how each TDC maps to each Wire Chamber
// channel            wires
//   0   |-----------| 1
// TDC 3 |           |
//   63  |           |
//       |           | Wire Chamber 1
//   0   |           |
// TDC 4 |           |
//   63  |-----------| 128
//       TDC1     TDC2
//       0  63   0  63 channel
// wires 1         128

// channel            wires
//   0   |-----------| 1
// TDC 7 |           |
//   63  |           |
//       |           | Wire Chamber 2
//   0   |           |
// TDC 8 |           |
//   63  |-----------| 128
//       TDC5     TDC6
//       0  63   0  63 channel
// wires 1         128

// channel            wires
//   0   |-----------| 1
// TDC 11|           |
//   63  |           |
//       |           | Wire Chamber 3
//   0   |           |
// TDC 12|           |
//   63  |-----------| 128
//       TDC9     TDC10
//       0  63   0  63 channel
// wires 1         128

// channel            wires
//   0   |-----------| 1
// TDC 15|           |
//   63  |           |
//       |           | Wire Chamber 4
//   0   |           |
// TDC 16|           |
//   63  |-----------| 128
//       TDC13    TDC14
//       0  63   0  63 channel
// wires 1         128
//
// take the convention that vertical wire numbers start at channel 128
void FragmentToDigit::makeMWPCDigits(std::vector<TDCFragment::TdcEventData> const& tdcEventData,
				     std::vector<raw::AuxDetDigit>               & mwpcAuxDigits)
{

  // make the map of TDC number to detector name and tdc to starting channel
  std::map<uint8_t, size_t> tdcToStartWire;
  std::map<uint8_t, size_t> tdcToChamber;
  for(uint8_t tdc = 1; tdc < 17; ++tdc){
    if(tdc < 5)       tdcToChamber[tdc] = 0;
    else if(tdc < 9)  tdcToChamber[tdc] = 1;
    else if(tdc < 13) tdcToChamber[tdc] = 2;
    else              tdcToChamber[tdc] = 3;

    if     (tdc == 1 || tdc == 5 || tdc == 9  || tdc == 13) tdcToStartWire[tdc] = 0;
    else if(tdc == 2 || tdc == 6 || tdc == 10 || tdc == 14) tdcToStartWire[tdc] = 64;
    else if(tdc == 3 || tdc == 7 || tdc == 11 || tdc == 15) tdcToStartWire[tdc] = 128;
    else if(tdc == 4 || tdc == 8 || tdc == 12 || tdc == 16) tdcToStartWire[tdc] = 192;
  }

  std::vector<std::string> detNames(4);
  detNames[0] = "MWPC1";
  detNames[1] = "MWPC2";
  detNames[2] = "MWPC3";
  detNames[3] = "MWPC4";

  // vector to hold the channels for a single MWPC
  std::vector< std::vector< std::vector<short> > > hitsInChannel;
  hitsInChannel.resize(TDCFragment::MAX_CHAMBERS);
  for(size_t cham = 0; cham < hitsInChannel.size(); ++cham){
    hitsInChannel[cham].resize(TDCFragment::N_CHANNELS * TDCFragment::TDCS_PER_CHAMBER);
    for(size_t chan = 0; chan < hitsInChannel[cham].size(); ++chan)
      hitsInChannel[cham][chan].resize(TDCFragment::MAX_HITS, 0);
  }

  // vector to hold the timeStamps for each channel in the MWPC
  std::vector< std::vector<unsigned long long> > timeStamps;
  timeStamps.resize(TDCFragment::MAX_CHAMBERS);
  for(size_t cham = 0; cham < timeStamps.size(); ++cham) 
    timeStamps[cham].resize(TDCFragment::N_CHANNELS * TDCFragment::TDCS_PER_CHAMBER, 0);
      
  for(auto const& tdced : tdcEventData){ 

    // determine the chamber and start wire
    auto switr = tdcToStartWire.find(tdced.tdcEventHeader.tdcNumber);
    auto chitr = tdcToChamber.find(tdced.tdcEventHeader.tdcNumber);

    if( chitr == tdcToChamber.end() || switr == tdcToStartWire.end() )
      throw cet::exception("FragmentToDigit") << "TDC number " << tdced.tdcEventHeader.tdcNumber
					      << " is not present in map to chamber number or start wire";

    for(auto const& hit : tdced.tdcHits){
      hitsInChannel[chitr->second][switr->second + size_t (hit.channel)].push_back(short (hit.timeBin));
      timeStamps   [chitr->second][switr->second + size_t (hit.channel)] = tdced.tdcEventHeader.tdcTimeStamp;
    }
      
  } // end loop over tdcEventData

  // now make the AuxDetDigits for this fragment
  for(size_t cham = 0; cham < TDCFragment::MAX_CHAMBERS; ++cham){
    for(size_t chan = 0; chan < TDCFragment::N_CHANNELS * TDCFragment::TDCS_PER_CHAMBER; ++chan){
      
      mwpcAuxDigits.push_back(raw::AuxDetDigit(static_cast <unsigned short> (chan),
					       hitsInChannel[cham][chan],
					       detNames[cham],
					       static_cast <unsigned long long> (timeStamps[cham][chan]))
			      );
      
    }
  } // end loops to create AuxDetDigits

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeMWPCTDCAuxDetDigits(int i, LariatFragment * data,
					      std::vector< std::reference_wrapper< std::unique_ptr< std::vector<raw::AuxDetDigit> > > > & mwpcTdcVecs,
					      std::string mwpcTdcLabels[16])
{
  TDCFragment & tdcFrag = data->tdcFrags[0];
  
  std::vector< std::vector<TDCFragment::TdcEventData> > &tdcEvents = tdcFrag.tdcEvents;

  // if the size of the number of TDCs from the fragment does not match the 
  // number of the tdcEvents, then return without doing anything
  if (tdcFrag.controllerHeader.nTDCs != tdcEvents[i].size()) {
    mf::LogError("FragmentToDigit") << "*** Fatal nTDCs mismatch: " 
				    << tdcEvents[i].size()
				    << " != " << tdcFrag.controllerHeader.nTDCs
				    <<" return to calling function";
    return;
  }

  for (size_t tdc_index = 0; tdc_index < TDCFragment::MAX_TDCS; ++tdc_index) {
    TDCFragment::TdcEventData tdcEventData = tdcEvents[i].at(tdc_index);
    
    std::vector< std::vector<short> > hitsInChannel;
    
    hitsInChannel.resize(TDCFragment::N_CHANNELS);
    for (size_t channel = 0; channel < TDCFragment::N_CHANNELS; ++channel) {
      hitsInChannel[channel].reserve(TDCFragment::MAX_HITS);
    }
    
    uint32_t tdcTimeStamp = tdcEventData.tdcEventHeader.tdcTimeStamp;
    
    for (size_t hit_index = 0; hit_index < tdcEventData.tdcHits.size(); ++hit_index) {
      TDCFragment::TdcHit & hit = tdcEventData.tdcHits[hit_index];
      hitsInChannel[size_t (hit.channel)].push_back(short (hit.timeBin));
    }
    
    for (size_t channel = 0; channel < TDCFragment::N_CHANNELS; ++channel) {
      
      mwpcTdcVecs[tdc_index].get()->push_back(raw::AuxDetDigit(static_cast <unsigned short> (channel),
							       hitsInChannel[channel],
							       mwpcTdcLabels[tdc_index],
							       static_cast <unsigned long long> (tdcTimeStamp)
							       )
					      );

    }

  }

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeWUTDigits(LariatFragment * data,
                                    std::unique_ptr< std::vector<raw::AuxDetDigit> > & wutVec)
{

  const int numberWutFrags = data->wutFrags.size();
  mf::LogInfo("FragmentToDigit") << "Found " << numberWutFrags << " WUT fragments";

  if (numberWutFrags > 0)
    mf::LogInfo("FragmentToDigit") << "Looking at WUT fragments...";

  for (int i = 0; i < numberWutFrags; ++i) {
    WUTFragment & wutFrag = data->wutFrags[i];
    uint32_t numberHits = wutFrag.header.nHits;
    std::vector<WUTFragment::WutHit> & hits = wutFrag.hits;

    std::vector< std::vector<short> > hitsInChannel;

    hitsInChannel.resize(WUT_N_TDC_CHANNELS);
    for (size_t channel = 0; channel < WUT_N_TDC_CHANNELS; ++channel)
      hitsInChannel[channel].reserve(WUT_MAX_HITS);
    
    uint32_t timeHeader = wutFrag.header.timeHeader;

    for (size_t j = 0; j < numberHits; ++j) {
      WUTFragment::WutHit & hit = hits[j];
      hitsInChannel[size_t (hit.channel)].push_back(short (hit.timeBin));
    }

    for (size_t channel = 0; channel < WUT_N_TDC_CHANNELS; ++channel) {

      wutVec->push_back(raw::AuxDetDigit(static_cast <unsigned short> (channel),
					 hitsInChannel[channel],
					 fWutLabel,
					 static_cast <unsigned long long> (timeHeader)
					 )
			);
      
    }
  }// end loop over WUT fragments

  return;
}


//------------------------------------------------------------------------------
void FragmentToDigit::makeCaenV1751AuxDetDigits(int i, LariatFragment * data,
                                                std::unique_ptr< std::vector<raw::AuxDetDigit> > & caenV1751Board0Vec,
                                                std::unique_ptr< std::vector<raw::AuxDetDigit> > & caenV1751Board1Vec,
						std::unique_ptr<std::vector< raw::OpDetPulse > > & OpDetVec1,
						std::unique_ptr<std::vector< raw::OpDetPulse > > & OpDetVec2)
{

  CAENFragment & caenFrag = data->caenFrags[i];

  uint32_t boardId = caenFrag.header.boardId;
  uint32_t triggerTimeTag = caenFrag.header.triggerTimeTag;
  for (size_t j = 0; j < V1751_N_CHANNELS; ++j) {
    std::vector<short> caenFragWaveForm(caenFrag.waveForms[j].data.begin(), caenFrag.waveForms[j].data.end());
   
    if(boardId == 8)
      caenV1751Board0Vec->push_back(raw::AuxDetDigit(static_cast <unsigned short> (j),
						     caenFragWaveForm,
						     fCaenV1751Board0Label,
						     static_cast <unsigned long long> (triggerTimeTag)
						     )
				    );
    else if(boardId == 9)
      caenV1751Board1Vec->push_back(raw::AuxDetDigit(static_cast <unsigned short> (j),
						     caenFragWaveForm,
						     fCaenV1751Board1Label,
						     static_cast <unsigned long long> (triggerTimeTag)
						     )
				    );
    

    if(fOpDetChID[boardId].size() != 0){
      // the following if statement makes no sense.  Why would we expect the size of the 
      // vector for a given set of channels on a board to be greater than j????
      if(fOpDetChID[boardId].size() > j){
	mf::LogInfo("FragmentToDigit") << "Writing opdetpulses index i=" << i 
				       << " in makeCaenV1751Frags boardID : " << boardId 
				       << " channel " << j 
				       << " size of wvform data " << caenFrag.waveForms[j].data.size()
				       << " fOpDetChID[boardId] size() " << fOpDetChID[boardId].size() 
				       << " boardId " << boardId;
	// this if statement is also suspect - what happens when there are fewer than j 
	// entries in the vector of channels referenced by fOpDetChId[boardId]????
	if(fOpDetChID[boardId][j] == j){
	  if(boardId == 8)
	    OpDetVec1->push_back(raw::OpDetPulse(static_cast <unsigned short> (j),
						 caenFragWaveForm,
						 0,
						 static_cast <unsigned int> (triggerTimeTag)
						 )
				 );
	  else if (boardId == 9) 
	    OpDetVec2->push_back(raw::OpDetPulse(static_cast <unsigned short> (j),
						 caenFragWaveForm,
						 0,
						 static_cast <unsigned int> (triggerTimeTag)
						 )
				 );
	}//end if the board is the right one
      }//end if the board is the right one        
    }// end if this op channel is valid
  }// end loop over 1751 channels

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeCaenV1740AuxDetDigits(int i, LariatFragment * data,
						std::unique_ptr< std::vector<raw::AuxDetDigit> > & caenV1740Board7Vec)
{

  CAENFragment & caenFrag = data->caenFrags[i];

  uint32_t boardId = caenFrag.header.boardId;
  uint32_t triggerTimeTag = caenFrag.header.triggerTimeTag;

  if (boardId == 7) {
    for (size_t j = 31; j < V1740_N_CHANNELS; ++j) {
      std::vector<short> caenFragWaveForm(caenFrag.waveForms[j].data.begin(),
					  caenFrag.waveForms[j].data.end());
      caenV1740Board7Vec->push_back(raw::AuxDetDigit(static_cast <unsigned short> (j),
						     caenFragWaveForm,
						     fCaenV1740Board7Label,
						     static_cast <unsigned long long> (triggerTimeTag)
						     )
				    );
    }

  }

}

DEFINE_ART_MODULE(FragmentToDigit)
