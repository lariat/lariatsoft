////////////////////////////////////////////////////////////////////////
// Class:       FragmentToDigit
// Module Type: producer
// File:        FragmentToDigit_module.cc
//
// Generated at Mon Dec  1 11:28:13 2014 by Will Flanagan using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////
// TODO
//////////////////////////////////////////////////////////////
// [x] Add CAEN V1751 board 0
// [x] Add CAEN V1751 board 1
// [x] Add channels 31 to 63 of CAEN V1740 board 7
// [x] Add CAEN V1740 channels for boards 0-6 and channels 0
//     to 31 of board 7 to TPC RawDigits
// [x] Add WUT
// [x] Add MWPCs
// [x] Put Pawel's OpDetPulse modifications back in (Pawel)
// [x] Add data block matching algorithm
// [x] Add trigger associations (Brian)
// [ ] Set the trigger bits correctly (Brian)
// [x] Determine the pedestals for the RawDigits 
// [ ] Add helpful comments throughout code. This may never be
//     checked off.
//////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "artdaq-core/Data/Fragment.hh"

#include "LArIATFragments/LariatFragment.h"
#include "LArIATFragments/WUTFragment.h"
#include "LArIATFragments/CAENFragment.h"
#include "LArIATFragments/TDCFragment.h"
#include "LArIATFragments/V1495Fragment.h"

#include "SimpleTypesAndConstants/RawTypes.h"
#include "RawData/RawDigit.h"
#include "RawData/AuxDetDigit.h"
#include "RawData/OpDetPulse.h"
#include "RawData/TriggerData.h"
#include "SummaryData/RunData.h"
#include "Geometry/Geometry.h"
#include "Utilities/AssociationUtil.h"

#include "RawDataUtilities/FragmentUtility.h"

//#include "TTree.h"
#include "TGraph.h"
#include "TF1.h"
#include "TH2.h"
#include "TH1.h"

#include <memory>
#include <functional>
#include <vector>
#include <string>
#include <algorithm>
#include <initializer_list>
#include <bitset>

enum {
  V1740_N_CHANNELS = 64,
  V1751_N_CHANNELS = 8,
  WUT_N_TDC_CHANNELS = 16,
  WUT_MAX_HITS = 128,
};

// ugly nested maps for matching data blocks
//typedef std::map< std::string, std::map< std::string, std::vector< std::map< unsigned int, std::vector<unsigned int> > > > > match_maps;
//typedef std::map< std::string, std::map< std::string, std::vector< std::pair<double, double> > > > fit_params_maps;
typedef std::map< int, std::map< int, std::vector< std::map< unsigned int, std::vector<unsigned int> > > > > match_maps;
typedef std::map< int, std::map< int, std::vector< std::pair<double, double> > > > fit_params_maps;
typedef std::vector<TDCFragment::TdcEventData> TDCDataBlock; 

class FragmentToDigit;

class FragmentToDigit : public art::EDProducer {
public:
  explicit FragmentToDigit(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  FragmentToDigit(FragmentToDigit const &) = delete;
  FragmentToDigit(FragmentToDigit &&) = delete;
  FragmentToDigit & operator = (FragmentToDigit const &) = delete;
  FragmentToDigit & operator = (FragmentToDigit &&) = delete;

  // Required functions.
  void produce(art::Event & evt) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void beginRun(art::Run &run);
  void matchDataBlocks(const LariatFragment * data);

  void coarseMatch(int   const& deviceAID,
                   int   const& deviceBID,
                   double       range[2],
                   std::map< int, std::map<unsigned int, double> > timeStamps,
                   match_maps & matchMaps);

  void fineMatch(int      const& deviceAID,
                 int      const& deviceBID,
                 double          range[2],    
                 fit_params_maps fitParametersMaps,
                 std::map< int, std::map<unsigned int, double> > timeStamps,
                 match_maps    & matchMaps);

  void printMatchMap(int   const& deviceAID,
                     int   const& deviceBID,
                     match_maps & matchMaps);

  double line(std::pair<double, double> const& parameters, 
              double                    const& x);

  double clockDriftCorr(std::pair<double, double> const& parameters,
                        double                    const& x);

  void fitClockDrift(int         const& deviceAID,
                     int         const& deviceBID,
                     std::map< int, std::map<unsigned int, double> > timeStamps,
                     match_maps       & matchMaps,
                     fit_params_maps  & fitParametersMaps,
                     std::string const& graphNamePrefix);

  void matchFitIter(int        const& deviceAID,
                    int        const& deviceBID,
                    std::map< int, std::map<unsigned int, double> > timeStamps,
                    match_maps      & matchMaps,
                    fit_params_maps & fitParametersMaps,
                    double            coarseRange[2],
                    double            fineEps[2]);

  uint32_t triggerBits               (std::vector<CAENFragment>     const& caenFrags);   				  
  void     makeTPCRawDigits          (std::vector<CAENFragment>     const& caenFrags,    	
			     	      std::vector<raw::RawDigit>         & tpcDigits);   	
  float    findPedestal              (const std::vector<short>           & adcVec);	     
  void     makeOpDetPulses           (std::vector<CAENFragment>     const& caenFrags,    	       
       	   			      std::vector<raw::OpDetPulse>       & opDetPulse);  	       
  void 	   makeMuonRangeDigits	     (std::vector<CAENFragment>     const& caenFrags,    	       
				      std::vector<raw::AuxDetDigit>      & mrAuxDigits); 	       
  void 	   makeTOFDigits             (std::vector<CAENFragment>     const& caenFrags,    	       
				      std::vector<raw::AuxDetDigit>      & tofAuxDigits);	       
  void 	   makeAeroGelDigits         (std::vector<CAENFragment>     const& caenFrags,    	       
				      std::vector<raw::AuxDetDigit>      & agAuxDigits); 	       
  void 	   makeHaloDigits            (std::vector<CAENFragment>     const& caenFrags,    	       
				      std::vector<raw::AuxDetDigit>      & hAuxDigits); 	       
  void 	   makeTriggerDigits         (std::vector<CAENFragment>     const& caenFrags,    	       
				      std::vector<raw::AuxDetDigit>      & trAuxDigits); 	       
  void 	   caenFragmentToAuxDetDigits(std::vector<CAENFragment>     const& caenFrags,	       
				      std::vector<raw::AuxDetDigit>      & auxDetDigits,	       
				      uint32_t                      const& boardId,		       
				      std::set<uint32_t>            const& boardChans,	       
				      uint32_t                      const& chanOffset,	       
				      std::string                   const& detName);	       
  void 	   makeMWPCDigits            (std::vector<TDCFragment::TdcEventData> const& tdcFrags,      
				      std::vector<raw::AuxDetDigit>               & mwpcAuxDigits);

  void     LinFitUnweighted(const std::vector<double>& x,
			    const std::vector<double>& y,
			    double& m, double& c);

  void     InitializeMWPCContainers();
  void     CleanUpMWPCContainers();
  

private:

  art::ServiceHandle<art::TFileService>      tfs;                      ///< handle to the TFileService
  std::string                                fRawFragmentLabel;        ///< label for module producing artdaq fragments
  std::string 				     fRawFragmentInstance;     ///< instance label for artdaq fragments        
  size_t                                     fMaxNumberFitIterations;  ///< number of fit iterations before stopping
  std::map<uint32_t, std::set<uint32_t> >    fOpticalDetChannels;      ///< key is the board ID, set are channels on that board
  std::map< int, std::vector<CAENFragment> > fTriggerToCAENDataBlocks; ///< map trigger ID to vector of CAEN blocks
  std::map< int, std::vector<TDCDataBlock> > fTriggerToTDCDataBlocks;  ///< map trigger ID to vector of TDC blocks
  std::map<size_t, size_t>                   fTDCToStartWire;          ///< map TDCs to first wire attached to TDC
  std::map<size_t, size_t>                   fTDCToChamber;            ///< map TDCs to the chamber they are attached
  std::vector<std::string>                   fMWPCNames;               ///< vector to hold detector names of the MWPCs
  int                                        fRunNumber;               ///< current run number
  TH2F *                                     FragCountsSameTrigger_1751vsTDC_NoTPC;	  
  TH2F * 				     FragCountsSameTrigger_1751vsTDC_WithTPC; 
  TH2F * 				     FragCountsSameTrigger_1751vsTDC_ExtraTPC;
  TH1F*   				     fRawDigitPedestals;       ///< computed pedestal values               
  TH1F*  				     fRawDigitADC;             ///< pedestal subtracted values               

};

//------------------------------------------------------------------------------
FragmentToDigit::FragmentToDigit(fhicl::ParameterSet const & p)
  : fRunNumber(0)
{
  this->reconfigure(p);

  ///\todo At some point we want to store the POT for each run in the file

  produces< sumdata::RunData, art::InRun >();

  produces< std::vector<raw::RawDigit>    >();
  produces< std::vector<raw::Trigger>     >();
  produces< std::vector<raw::AuxDetDigit> >();
  produces< std::vector<raw::OpDetPulse>  >();
  produces< art::Assns<raw::Trigger, raw::RawDigit>    >();
  produces< art::Assns<raw::Trigger, raw::AuxDetDigit> >();
  produces< art::Assns<raw::Trigger, raw::OpDetPulse>  >();
  //produces< std::vector<V1495Fragment> >();


}

//------------------------------------------------------------------------------
void FragmentToDigit::reconfigure(fhicl::ParameterSet const & p)
{
  fRawFragmentLabel       = p.get< std::string >("RawFragmentLabel",       "daq"  );
  fRawFragmentInstance    = p.get< std::string >("RawFragmentInstance",    "SPILL");
  fMaxNumberFitIterations = p.get< int         >("MaxNumberFitIterations", 5      );
  std::vector<std::vector<unsigned int> > opChans = p.get< std::vector<std::vector<unsigned int>> >("pmt_channel_ids");

  for(size_t i = 0; i < opChans.size(); ++i){
    if(opChans[i].size() < 1) continue;
    for(size_t j = 1; j < opChans[i].size(); ++j){
      fOpticalDetChannels[opChans[i][0]].insert(opChans[i][j]);
      LOG_VERBATIM("FragmentToDigit") << "board " << opChans[i][0] 
				      << " has optical detector on channel " 
				      << opChans[i][j];
    }
  }


  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::beginJob()
{
  FragCountsSameTrigger_1751vsTDC_NoTPC   = tfs->make<TH2F>("FragCountsSameTrigger_1751vsTDC_NoTPC"   
							    ,"FragCountsSameTrigger_1751vsTDC_NoTPC; Number TDC Data Blocks; Number v1751 Data Blocks"   
							    ,6,-0.5,5.5,6,-0.5,5.5);
  FragCountsSameTrigger_1751vsTDC_WithTPC = tfs->make<TH2F>("FragCountsSameTrigger_1751vsTDC_WithTPC" 
							    ,"FragCountsSameTrigger_1751vsTDC_WithTPC; Number TDC Data Blocks; Number v1751 Data Blocks" 
							    ,6,-0.5,5.5,6,-0.5,5.5);
  FragCountsSameTrigger_1751vsTDC_ExtraTPC= tfs->make<TH2F>("FragCountsSameTrigger_1751vsTDC_ExtraTPC"
							    ,"FragCountsSameTrigger_1751vsTDC_ExtraTPC; Number TDC Data Blocks; Number v1751 Data Blocks"
							    ,6,-0.5,5.5,6,-0.5,5.5);

  fRawDigitPedestals = tfs->make<TH1F>("rawDigitPedestals", ";Pedestal (ADC);Digits", 1000, 0., 10000.);
  fRawDigitADC       = tfs->make<TH1F>("rawDigitADC",       ";Signal (ADC);Digits"  , 1000, 0., 10000.);   

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::endJob()
{
  this->CleanUpMWPCContainers();

  return;
}

//____________________________________________________________________________
void FragmentToDigit::beginRun(art::Run& run)
{
  fRunNumber = run.run();

  this->InitializeMWPCContainers();

  // grab the geometry object to see what geometry we are using
  art::ServiceHandle<geo::Geometry> geo;

  std::unique_ptr<sumdata::RunData> runcol(new sumdata::RunData(geo->DetectorName()));

  run.put(std::move(runcol));

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::produce(art::Event & evt)
{
  std::unique_ptr< std::vector<raw::RawDigit>    > rawDigitVec(new std::vector<raw::RawDigit   >);
  std::unique_ptr< std::vector<raw::Trigger>     > triggerVec (new std::vector<raw::Trigger    >);
  std::unique_ptr< std::vector<raw::AuxDetDigit> > auxDetVec  (new std::vector<raw::AuxDetDigit>);
  std::unique_ptr< std::vector<raw::OpDetPulse>  > opDetVec   (new std::vector<raw::OpDetPulse >);

  std::unique_ptr< art::Assns<raw::Trigger, raw::RawDigit>    > tdRDAssns(new art::Assns<raw::Trigger, raw::RawDigit>   );
  std::unique_ptr< art::Assns<raw::Trigger, raw::AuxDetDigit> > tdADAssns(new art::Assns<raw::Trigger, raw::AuxDetDigit>);
  std::unique_ptr< art::Assns<raw::Trigger, raw::OpDetPulse>  > tdOPAssns(new art::Assns<raw::Trigger, raw::OpDetPulse> );

  // make the utility to access the fragments from the event record
  rdu::FragmentUtility fragUtil(evt, fRawFragmentLabel, fRawFragmentInstance);

  // fill the maps for matching the different data blocks into triggers
  // clear out the maps from the previous event first
  fTriggerToCAENDataBlocks.clear();
  fTriggerToTDCDataBlocks .clear();
  this->matchDataBlocks(&fragUtil.DAQFragment());

  // make a set of the different trigger numbers, ie the keys in the fTriggerToCAENDataBlocks
  // and fTriggerToTDCDataBlocks maps
  std::set<int> trigNums;
  for(auto itr : fTriggerToCAENDataBlocks) trigNums.insert(itr.first);
  for(auto itr : fTriggerToTDCDataBlocks)  trigNums.insert(itr.first);

  std::vector<CAENFragment>              caenFrags;	 
  std::vector<raw::AuxDetDigit>          auxDigits;	 
  std::vector<raw::RawDigit>    	 rawDigits;	 
  std::vector<raw::OpDetPulse>   	 opPulses;	 
  size_t                         	 startAssns = 0;
  size_t                         	 endAssns   = 0;
  double                                 eventTime  = 1.*evt.time().timeHigh() + 1.*evt.time().timeLow();
  bool                                   caenDataPresent = true;
  bool                                   tdcDataPresent  = true;

  for(auto trigNum : trigNums){

    caenDataPresent = false;
    tdcDataPresent  = false;
    caenFrags.clear();
    auxDigits.clear();
    rawDigits.clear();
    opPulses .clear();

    if(fTriggerToCAENDataBlocks.count(trigNum) > 0 ){
      auto trigToCAEN = fTriggerToCAENDataBlocks.find(trigNum);

      for(auto c : trigToCAEN->second) caenFrags.push_back(c);
      
      triggerVec->push_back(raw::Trigger(trigNum, caenFrags.front().header.triggerTimeTag, eventTime, this->triggerBits(caenFrags)));
      caenDataPresent = true;
    }
    else
      LOG_WARNING("FragmentToDigit") << "There are no CAEN Fragments for trigger " << trigNum
				     << " that may be OK, so continue";

    // get the TDC fragments for this trigger
    if(fTriggerToTDCDataBlocks.count(trigNum) > 0 ){
      auto trigToTDC = fTriggerToTDCDataBlocks.find(trigNum);

      for(auto tdc : trigToTDC->second) this->makeMWPCDigits(tdc,  auxDigits);

      tdcDataPresent = true;
      if(!caenDataPresent){
	auto tdc = trigToTDC->second.front();
	triggerVec->push_back(raw::Trigger(trigNum, tdc.front().tdcEventHeader.tdcTimeStamp, 
					   eventTime, this->triggerBits(caenFrags)));
      }
    }
    else
      LOG_WARNING("FragmentToDigit") << "There are no TDC Fragments for trigger " << trigNum
				     << " that may be OK, so continue";

    // put a trigger object in the output vector
    if(!caenDataPresent && !tdcDataPresent){
      LOG_WARNING("FragmentToDigit") << "There are no CAEN or TDC Fragments for trigger " << trigNum
				     << " so there is nothing to put into the event record; "
				     << " continue to the next trigger";
      continue;
    }
      

    // make each association type as you go putting the digits into the vectors
    this->makeTPCRawDigits(caenFrags, rawDigits);
    startAssns = rawDigitVec->size();
    for(auto rd : rawDigits) rawDigitVec->push_back(rd);
    endAssns = rawDigitVec->size();
    util::CreateAssn(*this, evt, *triggerVec, *rawDigitVec, *tdRDAssns, startAssns, endAssns);

    this->makeOpDetPulses(caenFrags, opPulses);
    startAssns = opDetVec->size();
    for(auto op : opPulses) opDetVec->push_back(op);
    endAssns = opDetVec->size();
    util::CreateAssn(*this, evt, *triggerVec, *opDetVec, *tdOPAssns, startAssns, endAssns);

    // putting all the AuxDetDigits from the different detectors into a single
    // vector in the event record.  They can be separated out by the detector
    // name data member of the AuxDetDigit later.  Doing it this way makes 
    // creating the associations easier.
    this->makeMuonRangeDigits(caenFrags, auxDigits);
    this->makeTOFDigits      (caenFrags, auxDigits);
    this->makeAeroGelDigits  (caenFrags, auxDigits);
    this->makeHaloDigits     (caenFrags, auxDigits);
    this->makeTriggerDigits  (caenFrags, auxDigits);

    startAssns = auxDetVec->size();
    for(auto ad : auxDigits) auxDetVec->push_back(ad);
    endAssns = auxDetVec->size();
    util::CreateAssn(*this, evt, *triggerVec, *auxDetVec, *tdADAssns, startAssns, endAssns);
  }

  evt.put(std::move(triggerVec));
  evt.put(std::move(rawDigitVec));
  evt.put(std::move(auxDetVec));
  evt.put(std::move(opDetVec));
  evt.put(std::move(tdRDAssns));
  evt.put(std::move(tdADAssns));
  evt.put(std::move(tdOPAssns));

  fTriggerToCAENDataBlocks.clear();
  fTriggerToTDCDataBlocks .clear();

  return;  
}

//......................................................................
void FragmentToDigit::LinFitUnweighted(const std::vector<double>& x,
				       const std::vector<double>& y,
				       double& m, double& c)
{
  // Before going ahead, make sure we have sensible arrays
  if(x.size() != y.size())
    throw cet::exception("FragmentToDigit") << "cannot do linear fit, vectors are different sizes "
					    << "x: " << x.size() << " y: " << y.size();
  if(x.size() < 2)
    throw cet::exception("FragmentToDigit") << "cannot do linear fit, not enough points "
					    << "x: " << x.size() << " y: " << y.size();

  // Accumulate the sums for the fit
  double Sx  = 0;
  double Sy  = 0;
  double Sxy = 0;
  double Sy2 = 0;
  double Sx2 = 0;
  const unsigned int I = x.size();
  for(unsigned int i = 0; i < I; ++i) {
    Sx  += x[i];
    Sy  += y[i];
    Sx2 += x[i]*x[i];
    Sxy += x[i]*y[i];
    Sy2 += y[i]*y[i];
  }
  const double d = I*Sx2 - Sx*Sx;
  m = (I*Sxy  - Sx*Sy)/d;
  c = (Sy*Sx2 - Sx*Sxy)/d;

  return;
}

//-----------------------------------------------------------------------------------
void FragmentToDigit::matchDataBlocks(const LariatFragment * data) 
{

  // maps for matching fragments
  std::map< int, std::map<unsigned int, double> > dataBlockTimeStamps;
  match_maps matchMaps;

  //////////////////////////////////////////////////////////////////////
  // Some notes
  //////////////////////////////////////////////////////////////////////
  //
  // There are multiple CAEN fragments and only one TDC fragment for
  // each spill. Each TDC fragment holds multiple TDC events.
  //
  // Since there are multiple CAEN fragments and only one TDC fragment
  // per spill, I will use the term "data block" to refer to a single
  // CAEN fragment or a single TDC event.
  //
  // dataBlockTimeStamps will store the data block time stamps from all
  // devices (except the WUT) to help with the matching.
  //
  // Here is some pseudocode on how to access the time stamps:
  //
  // for deviceID in devices:
  //     for dataBlockIndex in dataBlocks:
  //         dataBlockTimeStamp = dataBlockTimeStamps[deviceID][dataBlockIndex];
  //
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  // Device ID key
  //////////////////////////////////////////////////////////////////////
  //  Device ID  Device
  //  ---------  ------
  //  0          CAEN boardId 0, V1740 board 0
  //  1          CAEN boardId 1, V1740 board 1
  //  2          CAEN boardId 2, V1740 board 2
  //  3          CAEN boardId 3, V1740 board 3
  //  4          CAEN boardId 4, V1740 board 4
  //  5          CAEN boardId 5, V1740 board 5
  //  6          CAEN boardId 6, V1740 board 6
  //  7          CAEN boardId 7, V1740 board 7
  //  8          CAEN boardId 8, V1751 board 0
  //  9          CAEN boardId 9, V1751 board 1
  //  10         Multi-wire proportional chambers, 16 TDCs
  //  24         CAEN boardId 24, V1740 board 24
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: loop through the data blocks to get their time stamps
  //          into dataBlockTimeStamps
  //////////////////////////////////////////////////////////////////////

  size_t numberCaenDataBlocks[32] = {};
  size_t numberMwpcDataBlocks = 0;

  const size_t numberCaenFrags = data->caenFrags.size();
  LOG_VERBATIM("FragmentToDigit") << "Found " << numberCaenFrags << " CAEN fragments";

  if (numberCaenFrags > 0) 
    LOG_VERBATIM("FragmentToDigit") << "Looking at CAEN fragments...";

  for (size_t i = 0; i < numberCaenFrags; ++i) {
    CAENFragment const& caenFrag = data->caenFrags[i];
    unsigned int boardId = static_cast <unsigned int> (caenFrag.header.boardId);
    unsigned int index = numberCaenDataBlocks[boardId];
    int deviceID = boardId;
    // each CAEN Trigger Time Tag count is 8 ns
    double timeStamp = caenFrag.header.triggerTimeTag * 0.008;  // convert to microseconds
    dataBlockTimeStamps[deviceID][index] = timeStamp;
    numberCaenDataBlocks[boardId] += 1;
  }

  const size_t numberTdcFrags = data->tdcFrags.size();
  LOG_VERBATIM("FragmentToDigit") << "Found " << numberTdcFrags << " TDC fragments";

  if (numberTdcFrags > 0) 
    LOG_VERBATIM("FragmentToDigit") << "Looking at TDC fragments...";

  for (size_t i = 0; i < numberTdcFrags; ++i) {

    TDCFragment const& tdcFrag = data->tdcFrags[i];

    std::vector< std::vector<TDCFragment::TdcEventData> > const& tdcEvents = tdcFrag.tdcEvents;

    //LOG_DEBUG("FragmentToDigit")
    //    << "tdcEvents.size(): " << tdcEvents.size();
    //tdcFrag.print();

    numberMwpcDataBlocks = tdcEvents.size();

    for (size_t j = 0; j < tdcEvents.size(); ++j) {

      if (tdcFrag.controllerHeader.nTDCs != tdcEvents[j].size()) {
        mf::LogError("FragmentToDigit") << "*** Fatal nTDCs mismatch: " << tdcEvents[j].size()
            << " != " << tdcFrag.controllerHeader.nTDCs<< " "<< j;
        continue;
      }

      LOG_DEBUG("FragmentToDigit") << "TDC event: " << j;

      for (size_t tdc_index = 0; tdc_index < TDCFragment::MAX_TDCS; ++tdc_index) {
        TDCFragment::TdcEventData tdcEventData = tdcEvents[j].at(tdc_index);

        uint16_t controllerTimeStamp = tdcEventData.tdcEventHeader.controllerTimeStamp;
        uint32_t tdcTimeStamp = tdcEventData.tdcEventHeader.tdcTimeStamp;
        // each TDC Time Stamp count is 1/106.208 microseconds
        double timeStamp = tdcEventData.tdcEventHeader.tdcTimeStamp / 106.208;  // convert to microseconds

        int deviceID = 32;

        LOG_DEBUG("FragmentToDigit") << "  TDC index: " << tdc_index;
        LOG_DEBUG("FragmentToDigit") << "  TDC time stamp: " << tdcTimeStamp;
        LOG_DEBUG("FragmentToDigit") << "  Controller time stamp: " << controllerTimeStamp;

        dataBlockTimeStamps[deviceID][j] = timeStamp;

      }
    }
  }

  // let's forget the WUT for now
  //const int numberWutFrags = data->wutFrags.size();
  //LOG_DEBUG("FragmentToDigit")
  //    << "Found " << numberWutFrags << " WUT fragments";

  //////////////////////////////////////////////////////////////////////
  //@\ END: loop through the data blocks to get their time stamps
  //        into dataBlockTimeStamps
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: loop through dataBlockTimeStamps to check that they are there
  //////////////////////////////////////////////////////////////////////

  for (size_t i = 0; i < 10; ++i) {
    int deviceID = i;
    unsigned int indices = numberCaenDataBlocks[i];
    LOG_DEBUG("FragmentToDigit") << "Board ID: " << i << ", number of data blocks: " << numberCaenDataBlocks[i];
    LOG_DEBUG("FragmentToDigit") << "Device ID: " << deviceID;
    for (size_t j = 0; j < indices; ++j) {
      LOG_DEBUG("FragmentToDigit") << "  Index: " << j;
      LOG_DEBUG("FragmentToDigit") << "  Time stamp: " << dataBlockTimeStamps[deviceID][j];
    }
  }

  for (size_t i = 0; i < TDCFragment::MAX_TDCS; ++i) {
    int deviceID = 32;
    LOG_DEBUG("FragmentToDigit") << "TDC index: " << i << ", number of data blocks: " << numberMwpcDataBlocks;
    LOG_DEBUG("FragmentToDigit") << "Device ID: " << deviceID;
    for (size_t j = 0; j < numberMwpcDataBlocks; ++j) {
      LOG_DEBUG("FragmentToDigit") << "  Index: " << j;
      LOG_DEBUG("FragmentToDigit") << "  Time stamp: " << dataBlockTimeStamps[deviceID][j];
    }
  }

  //////////////////////////////////////////////////////////////////////
  //@\ END: loop through dataBlockTimeStamps to check that they are there
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: intra V1740/V1751 matching
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  // NOTE: The master clocks of the V1740s is boardId 0; the master
  //       clock of the V1751s is boardId 8.
  //////////////////////////////////////////////////////////////////////

  // the difference in time stamps should be in between this range for a match; microseconds
  double v1740IntraRange[2] = { -0.032, 0.032 };
  double v1751IntraRange[2] = { -0.032, 0.032 };

  this->coarseMatch(0, 1, v1740IntraRange, dataBlockTimeStamps, matchMaps);
  this->coarseMatch(0, 2, v1740IntraRange, dataBlockTimeStamps, matchMaps);
  this->coarseMatch(0, 3, v1740IntraRange, dataBlockTimeStamps, matchMaps);
  this->coarseMatch(0, 4, v1740IntraRange, dataBlockTimeStamps, matchMaps);
  this->coarseMatch(0, 5, v1740IntraRange, dataBlockTimeStamps, matchMaps);
  this->coarseMatch(0, 6, v1740IntraRange, dataBlockTimeStamps, matchMaps);
  this->coarseMatch(0, 7, v1740IntraRange, dataBlockTimeStamps, matchMaps);
  this->coarseMatch(8, 9, v1751IntraRange, dataBlockTimeStamps, matchMaps);

  //printMatchMap(0, 1, matchMaps);
  //printMatchMap(0, 2, matchMaps);
  //printMatchMap(0, 3, matchMaps);
  //printMatchMap(0, 4, matchMaps);
  //printMatchMap(0, 5, matchMaps);
  //printMatchMap(0, 6, matchMaps);
  //printMatchMap(0, 7, matchMaps);
  //printMatchMap(8, 9, matchMaps);

  //////////////////////////////////////////////////////////////////////
  //@\ END: intra V1740/V1751 matching
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: matching
  //////////////////////////////////////////////////////////////////////

  // the difference in time stamps should be in between this range for a match; microseconds
  // these variables should probably be placed in the .fcl file
  double v1751v1740InterRange[2] = { -500, 500 };
  double v1751MwpcInterRange[2]  = {    0, 160 };
  double v1740MwpcInterRange[2]  = {    0, 160 };

  // acceptance range from fitted line to allow a match; microseconds
  // these variables should probably be placed in the .fcl file
  // y - eps[0] <= y_test <= y + eps[1]
  double v1751v1740InterEps[2] = { 1, 1 };
  double v1751MwpcInterEps[2]  = { 1, 1 };
  double v1740MwpcInterEps[2]  = { 1, 1 };

  fit_params_maps fitParamsMaps;

  this->matchFitIter(8,  0, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751v1740InterRange, v1751v1740InterEps);
  this->matchFitIter(8,  1, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751v1740InterRange, v1751v1740InterEps);
  this->matchFitIter(8,  2, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751v1740InterRange, v1751v1740InterEps);
  this->matchFitIter(8,  3, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751v1740InterRange, v1751v1740InterEps);
  this->matchFitIter(8,  4, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751v1740InterRange, v1751v1740InterEps);
  this->matchFitIter(8,  5, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751v1740InterRange, v1751v1740InterEps);
  this->matchFitIter(8,  6, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751v1740InterRange, v1751v1740InterEps);
  this->matchFitIter(8,  7, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751v1740InterRange, v1751v1740InterEps);
  this->matchFitIter(8, 24, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751v1740InterRange, v1751v1740InterEps);
  this->matchFitIter(8, 32, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1751MwpcInterRange,  v1751MwpcInterEps);
  this->matchFitIter(0, 32, dataBlockTimeStamps, matchMaps, fitParamsMaps, v1740MwpcInterRange,  v1740MwpcInterEps);

  //////////////////////////////////////////////////////////////////////
  //@\ END: matching
  //////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////
  //@\ BEGIN: add to trigger ID to data block map
  //////////////////////////////////////////////////////////////////////

  int triggerID = 0;

  size_t numberMatchedCaenDataBlocks[32] = {};
  size_t numberMatchedMwpcDataBlocks = 0;

  fitParamsMaps[8][8].push_back(std::make_pair<double, double>(0, 0));
  fitParamsMaps[8][9].push_back(std::make_pair<double, double>(0, 0));

  // this shouldn't be hard-coded, but there is no way to get
  // the decimation factor of the sample rate from the CAENFragment
  double v1740SampleTime = 0.128;  // microseconds
  double v1751SampleTime = 0.001;  // microseconds
  size_t numberV1740Samples = 0;
  size_t numberV1751Samples = 0;

  for (size_t i = 0; i < numberCaenFrags; ++i) {
    CAENFragment const& caenFrag = data->caenFrags[i];
    unsigned int boardId = static_cast <unsigned int> (caenFrag.header.boardId);
    if (boardId == 0) {
      numberV1740Samples = static_cast <size_t> (caenFrag.header.nSamples);
    }
    if (boardId == 8) {
      numberV1751Samples = static_cast <size_t> (caenFrag.header.nSamples);
    }
    if (numberV1740Samples > 0 and numberV1751Samples > 0) break;
  }

  // vector of corrected timestamps to data block indices:
  //[
  //  timestamp0, [ caenBoardID, caenFragmentIndex0 ],
  //  timestamp1, [ caenBoardID, caenFragmentIndex1 ],
  //  timestamp3, [      mwpcID,     tdcEventIndex0 ],
  //  timestamp4, [ caenBoardID, caenFragmentIndex2 ],
  //  timestamp5, [      mwpcID,     tdcEventIndex1 ],
  //  ...
  //]
  std::vector< std::pair<double, std::pair<int, int> > > timeStampToDataBlockIndices;

  // correct CAENFragment timestamp and add corrected timestamp and index to vector
  for (size_t i = 0; i < numberCaenFrags; ++i) {
    CAENFragment const& caenFrag = data->caenFrags[i];
    unsigned int boardId = static_cast <unsigned int> (caenFrag.header.boardId);
    int deviceID = boardId;

    // each CAEN Trigger Time Tag count is 8 ns
    double timeStamp = caenFrag.header.triggerTimeTag * 0.008;  // convert to microseconds

    std::pair<double, double> fitParams(0, 0);

    fitParams = fitParamsMaps[8][deviceID].back();
    double corrTimeStamp = this->clockDriftCorr(fitParams, timeStamp);

    LOG_VERBATIM("FragmentToDigit") << "\n  deviceID:      " << deviceID
                                    << "\n  timeStamp:     " << timeStamp
                                    << "\n  corrTimeStamp: " << corrTimeStamp;

    std::pair<int, int> dataBlockIndex(boardId, i);

    timeStampToDataBlockIndices.push_back(std::make_pair(corrTimeStamp, dataBlockIndex));

  }

  // correct TDCEvent timestamp and add corrected timestamp and index to vector
  for (size_t i = 0; i < numberTdcFrags; ++i) {

    TDCFragment const& tdcFrag = data->tdcFrags[i];

    std::vector< std::vector<TDCFragment::TdcEventData> > const& tdcEvents = tdcFrag.tdcEvents;

    //LOG_DEBUG("FragmentToDigit")
    //    << "tdcEvents.size(): " << tdcEvents.size();
    //tdcFrag.print();

    int deviceID = 32;
    std::pair<double, double> fitParams(0, 0);
    fitParams = fitParamsMaps[8][deviceID].back();

    for (size_t j = 0; j < tdcEvents.size(); ++j) {

      if (tdcFrag.controllerHeader.nTDCs != tdcEvents[j].size()) {
        mf::LogError("FragmentToDigit") << "*** Fatal nTDCs mismatch: " << tdcEvents[j].size()
            << " != " << tdcFrag.controllerHeader.nTDCs<< " "<< j;
        continue;
      }

      //LOG_DEBUG("FragmentToDigit") << "TDC event: " << j;

      // Loop over TDCs to count the number of TDC timestamps that fall within range.
      // If that number is greater than 0, we consider this TDC event a match. We are
      // doing this to work around the mismatches of the TDC time bits.

      std::map<double, unsigned int> timeStampCounts;

      for (size_t tdc_index = 0; tdc_index < TDCFragment::MAX_TDCS; ++tdc_index) {
        TDCFragment::TdcEventData tdcEventData = tdcEvents[j].at(tdc_index);

        // each TDC Time Stamp count is 1/106.208 microseconds
        double timeStamp = tdcEventData.tdcEventHeader.tdcTimeStamp / 106.208;  // microseconds
        double corrTimeStamp = this->clockDriftCorr(fitParams, timeStamp);

        timeStampCounts[corrTimeStamp] += 1;

      } // end loop over TDCs

      unsigned int counts = 0;
      double corrTimeStamp = 0;

      for (auto const& k : timeStampCounts) {
        LOG_DEBUG("FragmentToDigit") << "timestamp: " << k.first
                                        << "\ncounts: " << k.second;
        if (k.second > counts) {
          corrTimeStamp = k.first;
          counts = k.second;
        }
      }

      std::pair<int, int> dataBlockIndex(32, j);

      timeStampToDataBlockIndices.push_back(std::make_pair(corrTimeStamp, dataBlockIndex));

    } // end loop over TDCEvents
  } // end loop over TDCFragments

  //LOG_VERBATIM("FragmentToDigit") << "Unsorted timestamps:";
  //for (auto const& i : timeStampToDataBlockIndices) {
  //  LOG_VERBATIM("FragmentToDigit") << "  timestamp: " << i.first;
  //}

  //std::sort(timeStampToDataBlockIndices.begin(), timeStampToDataBlockIndices.end());

  //LOG_VERBATIM("FragmentToDigit") << "Sorted timestamps:";

  //for (auto const& i : timeStampToDataBlockIndices) {
  //  LOG_VERBATIM("FragmentToDigit") << "  timestamp: " << i.first;
  //  //LOG_VERBATIM("FragmentToDigit") << "    index: (" << i.second.first << ", " << i.second.second << ")";
  //}

  std::vector<int> tstdbi_;  // master bookkeeper of already matched data blocks

  LOG_VERBATIM("FragmentToDigit") << "Sorted timestamps:";
  for (size_t i = 0; i < timeStampToDataBlockIndices.size(); ++i) {

    if (std::find(tstdbi_.begin(), tstdbi_.end(), i) != tstdbi_.end()) continue;

    double baseTimeStamp = timeStampToDataBlockIndices[i].first;
    std::pair<int, int> baseIndexPair = timeStampToDataBlockIndices[i].second;

    LOG_VERBATIM("FragmentToDigit") << "  baseTimeStamp:    " << baseTimeStamp;
    LOG_VERBATIM("FragmentToDigit") << "    baseIndexPair: (" << baseIndexPair.first << ", " << baseIndexPair.second << ")";

    double timeThresholdLow = baseTimeStamp - 0.032;
    double timeThresholdHigh = baseTimeStamp + 0.032;

    std::vector<int> selectedIndices;  // local bookkeeper  of selected data blocks

    for (size_t j = 0; j < timeStampToDataBlockIndices.size(); ++j) {

      if (std::find(tstdbi_.begin(), tstdbi_.end(), j) != tstdbi_.end()) continue;

      double timeStamp = timeStampToDataBlockIndices[j].first;
      std::pair<int, int> indexPair = timeStampToDataBlockIndices[j].second;

      if (timeThresholdLow <= timeStamp and timeStamp <= timeThresholdHigh) {
        LOG_VERBATIM("FragmentToDigit") << "    timeStamp:   " << timeStamp;
        LOG_VERBATIM("FragmentToDigit") << "      indexPair: (" << indexPair.first << ", " << indexPair.second << ")";

        selectedIndices.push_back(j);  // add to local bookkeeper of selected data blocks
        tstdbi_.push_back(j);          // add to master bookkeeper of already matched data blocks
      } // if timestamp falls within range

    } // for each data block

    // now loop over the selected data blocks for this trigger ID
    // and see if we can add more data blocks that occur during
    // the readout windows of the CAEN V1740s and V1751s
    for (size_t j = 0; j < selectedIndices.size(); ++j) {
      int index = selectedIndices[j];
      std::pair<int, int> indexPair = timeStampToDataBlockIndices[index].second;
      int deviceID = indexPair.first;

      LOG_VERBATIM("FragmentToDigit") << "  index: " << index;

      if (deviceID == 0) { // look for CAEN V1740 data blocks

        double timeStamp_ = timeStampToDataBlockIndices[index].first;
        double recordLength = numberV1740Samples * v1740SampleTime;  // microseconds

        double timeThresholdLow = timeStamp_ - 0.032;                // microseconds
        double timeThresholdHigh = timeStamp_ + recordLength;        // microseconds

        for (size_t k = 0; k < timeStampToDataBlockIndices.size(); ++k) {

          if (std::find(tstdbi_.begin(), tstdbi_.end(), k) != tstdbi_.end()) continue;

          double timeStamp = timeStampToDataBlockIndices[k].first;

          if (timeThresholdLow <= timeStamp and timeStamp <= timeThresholdHigh) {
            selectedIndices.push_back(k);  // add to local bookkeeper of selected data blocks
            tstdbi_.push_back(k);          // add to master bookkeeper of already matched data blocks
          } // if timestamp falls within range

        } // for each data block

      } // if CAEN board id is 0

      if (deviceID == 8) { // look for CAEN V1751 data blocks

        double timeStamp_ = timeStampToDataBlockIndices[index].first;
        double recordLength = numberV1751Samples * v1751SampleTime;  // microseconds

        double timeThresholdLow = timeStamp_ - 0.032;                // microseconds
        double timeThresholdHigh = timeStamp_ + recordLength;        // microseconds

        for (size_t k = 0; k < timeStampToDataBlockIndices.size(); ++k) {

          if (std::find(tstdbi_.begin(), tstdbi_.end(), k) != tstdbi_.end()) continue;

          double timeStamp = timeStampToDataBlockIndices[k].first;

          if (timeThresholdLow <= timeStamp and timeStamp <= timeThresholdHigh) {
            selectedIndices.push_back(k);  // add to local bookkeeper of selected data blocks
            tstdbi_.push_back(k);          // add to master bookkeeper of already matched data blocks
          } // if timestamp falls within range

        } // for each data block

      } // if CAEN board id is 8

    } // end loop over selected data blocks

    int v1740DataBlockCount = 0;
    int v1751DataBlockCount = 0;
    int WChamDataBlockCount = 0;

    // now that we have our final list of selected data blocks for this
    // trigger ID, let's add them to the trigger ID to data block maps
    for (size_t j = 0; j < selectedIndices.size(); ++j) {
      int index = selectedIndices[j];
      std::pair<int, int> indexPair = timeStampToDataBlockIndices[index].second;
      int deviceID = indexPair.first;
      int idx = indexPair.second;

      if (deviceID < 10 || deviceID == 24) {
        CAENFragment const& caenFrag = data->caenFrags[idx];
        unsigned int boardId = static_cast <unsigned int> (caenFrag.header.boardId);
        fTriggerToCAENDataBlocks[triggerID].push_back(caenFrag);
        numberMatchedCaenDataBlocks[boardId] += 1;
        if (deviceID == 0) ++v1740DataBlockCount; //Also need to check for the other v1740s somehow
        if (deviceID == 8) ++v1751DataBlockCount; //Also need to check for the other v17451 somehow
      }

      else if (deviceID == 32) {
        if (numberTdcFrags > 0) {
          TDCFragment const& tdcFrag = data->tdcFrags[0]; //The first and only spill's worth of TDC data.
          std::vector< std::vector<TDCFragment::TdcEventData> > const& tdcEvents = tdcFrag.tdcEvents;
          fTriggerToTDCDataBlocks[triggerID].push_back(tdcEvents[idx]);
          numberMatchedMwpcDataBlocks += 1;
          ++WChamDataBlockCount;
        }//if numberTdcFrags > 0
      }//if deviceID == 32
    } // end loop over selected data blocks

    triggerID += 1;

    LOG_VERBATIM("FragmentToDigit") << "  Trig: " << triggerID << " T/P/W:  " << v1740DataBlockCount <<"/"<<v1751DataBlockCount<<"/"<<WChamDataBlockCount;

    if (v1740DataBlockCount == 0)
      FragCountsSameTrigger_1751vsTDC_NoTPC    ->Fill(WChamDataBlockCount, v1751DataBlockCount);
    else if (v1740DataBlockCount == 1)
      FragCountsSameTrigger_1751vsTDC_WithTPC  ->Fill(WChamDataBlockCount, v1751DataBlockCount);
    else if (v1740DataBlockCount > 1)
      FragCountsSameTrigger_1751vsTDC_ExtraTPC ->Fill(WChamDataBlockCount, v1751DataBlockCount);
    
  } // for each data block

  LOG_VERBATIM("FragmentToDigit") << "  timeStampToDataBlockIndices.size(): " << timeStampToDataBlockIndices.size();
  LOG_VERBATIM("FragmentToDigit") << "  tstdbi_.size(): " << tstdbi_.size();

  //////////////////////////////////////////////////////////////////////
  //@\ END: add to trigger ID to data block map
  //////////////////////////////////////////////////////////////////////

  // print matching summary

  LOG_VERBATIM("FragmentToDigit") << "\n";
  for (size_t i = 0; i < 32; ++i) {
    LOG_VERBATIM("FragmentToDigit") << "    boardId " << i << " matches: "
                                    << numberMatchedCaenDataBlocks[i] << " / "
                                    << numberCaenDataBlocks[i];
  }
  LOG_VERBATIM("FragmentToDigit") << "\n    MWPC matches: "
                                  << numberMatchedMwpcDataBlocks << " / "
                                  << numberMwpcDataBlocks;
  LOG_VERBATIM("FragmentToDigit") << "\n";
  

  return;
}

//-----------------------------------------------------------------------------------
void FragmentToDigit::coarseMatch(int   const& deviceAID,
                                  int   const& deviceBID,
                                  double       range[2],      
                                  std::map< int, std::map<unsigned int, double> > timeStamps,
                                  match_maps & matchMaps) 
{

  std::map< unsigned int, std::vector<unsigned int> > matchAB;

  size_t numberADataBlocks = timeStamps[deviceAID].size();
  size_t numberBDataBlocks = timeStamps[deviceBID].size();

  for (size_t a = 0; a < numberADataBlocks; ++a) {
    double timeStampA = timeStamps[deviceAID][a];
    for (size_t b = 0; b < numberBDataBlocks; ++b) {
      double timeStampB = timeStamps[deviceBID][b];
      double difference = timeStampA - timeStampB;
      if (range[0] <= difference and difference <= range[1]) {
        matchAB[a].push_back(b);
      }
    }
  }

  matchMaps[deviceAID][deviceBID].push_back(matchAB);

  return;
}

//-----------------------------------------------------------------------------------
void FragmentToDigit::fineMatch(int      const& deviceAID,
                                int      const& deviceBID,
                                double             eps[2],      
                                fit_params_maps fitParametersMaps,
                                std::map< int, std::map<unsigned int, double> > timeStamps,
                                match_maps    & matchMaps) 
{

  std::pair<double, double> fitParameters = fitParametersMaps[deviceAID][deviceBID].back();

  std::map< unsigned int, std::vector<unsigned int> > matchAB;

  size_t numberADataBlocks = timeStamps[deviceAID].size();
  size_t numberBDataBlocks = timeStamps[deviceBID].size();

  for (size_t a = 0; a < numberADataBlocks; ++a) {
    double timeStampA = timeStamps[deviceAID][a];
    for (size_t b = 0; b < numberBDataBlocks; ++b) {
      double timeStampB = timeStamps[deviceBID][b];
      double difference = timeStampA - timeStampB;
      double y = this->line(fitParameters, timeStampA);
      double yLow = y - eps[0];
      double yHigh = y + eps[1];
      if (yLow <= difference and difference <= yHigh) {
        matchAB[a].push_back(b);
      }
    }
  }

  matchMaps[deviceAID][deviceBID].push_back(matchAB);

  return;
}

//-----------------------------------------------------------------------------------
double FragmentToDigit::line(std::pair<double, double> const& parameters, 
                             double                    const& x) 
{
  double intercept = parameters.first;
  double slope = parameters.second;
  return intercept + slope * x;
}

//-----------------------------------------------------------------------------------
double FragmentToDigit::clockDriftCorr(std::pair<double, double> const& parameters, 
                                       double                    const& x) 
{
  double intercept = parameters.first;
  double slope = parameters.second;
  return (intercept + x) / (1 - slope);
}

//-----------------------------------------------------------------------------------
void FragmentToDigit::fitClockDrift(int         const& deviceAID,
                                    int         const& deviceBID,
                                    std::map< int, std::map<unsigned int, double> > timeStamps,
                                    match_maps       & matchMaps,
                                    fit_params_maps  & fitParametersMaps,
                                    std::string const& graphNamePrefix) 
{

  std::vector<double> x;
  std::vector<double> y;

  std::vector<double> x_;
  std::vector<double> y_;

  std::map< unsigned int, std::vector<unsigned int> > matchAB = matchMaps[deviceAID][deviceBID].back();

  LOG_DEBUG("FragmentToDigit") << "Matches between " << deviceAID << " and " << deviceBID;
  LOG_DEBUG("FragmentToDigit") << "  Matching index pair format: " << "(" << deviceAID << ", " << deviceBID << ")";

  for (auto const & itA : matchAB) {
    LOG_DEBUG("FragmentToDigit") << "  Index: " << itA.first << "; number of matches: " << itA.second.size();
    for (auto const & itB : itA.second) {
      double timeStampA = timeStamps[deviceAID][itA.first];
      double timeStampB = timeStamps[deviceBID][itB];
      double difference = timeStampA - timeStampB;
      double reference = timeStampA;
      LOG_DEBUG("FragmentToDigit") << "    (" << itA.first << ", " << itB << ")"
                                   << "; difference: " << difference << " usec"
                                   << "; reference: " << reference << " usec";
      if (itA.second.size() == 1) {
        x.push_back(reference);
        y.push_back(difference);
      }
      else {
        x_.push_back(reference);
        y_.push_back(difference);
      }
    }
  }

  std::pair<double, double> intSlp(0., 0.);

  // try {
  //   this->LinFitUnweighted(x, y, intSlp.second, intSlp.first);
  // }
  // catch (cet::exception &e) {
  //   LOG_WARNING("FragmentToDigit") << "caught exception:\n" << e
  //                                  << "\n returning intercept = 0 and slope = 0";
  // }

  // return intSlp;

  std::string graphName = graphNamePrefix + "_drift_" + std::to_string(deviceAID) + "_" + std::to_string(deviceBID);
  std::string graphTitles = ("; Time since beginning of spill (using deviceID " +
                             std::to_string(deviceAID) +
  			                 " clock) [#mus]; #Delta t between device ID " +
                             std::to_string(deviceAID) +
  			                 " and device ID " +
                             std::to_string(deviceBID) +
                             " [#mus]");

  TGraph * graph = tfs->make<TGraph>(x.size(), &x[0], &y[0]);

  try {
    TF1 * f = tfs->make<TF1>("f", "pol1", 0, 30e6);
    graph->Fit("f", "Q");
    LOG_DEBUG("FragmentToDigit") << "Fit parameters: intercept, "
                                 << f->GetParameter(0) << " usec; slope, "
                                 << f->GetParameter(1) << " usec/usec";
    intSlp.first = f->GetParameter(0);
    intSlp.second = f->GetParameter(1);
  }
  catch (cet::exception &e) {
    LOG_WARNING("FragmentToDigit") << "caught exception:\n" << e
                                   << "\nTLinearFitter failed"
                                   << "\n returning intercept = 0 and slope = 0";
  }

  graph->SetMarkerStyle(20);
  graph->SetTitle(graphTitles.c_str());
  graph->Write(graphName.c_str());
  // return std::make_pair<double, double>(f->GetParameter(0), f->GetParameter(1));

  fitParametersMaps[deviceAID][deviceBID].push_back(intSlp);

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::matchFitIter(int        const& deviceAID,
                                   int        const& deviceBID,
                                   std::map< int, std::map<unsigned int, double> > timeStamps,
                                   match_maps      & matchMaps,
                                   fit_params_maps & fitParametersMaps,
                                   double            coarseRange[2],
                                   double            fineEps[2])
{

  LOG_DEBUG("FragmentToDigit") << "matchFitIter -- "
                               << "deviceA: " << deviceAID << "; deviceB: " << deviceBID;

  this->coarseMatch(deviceAID, deviceBID, coarseRange, timeStamps, matchMaps);
  this->fitClockDrift(deviceAID, deviceBID, timeStamps, matchMaps, fitParametersMaps, "coarse_match");

  std::pair<double, double> fitParameters = fitParametersMaps[deviceAID][deviceBID].back();
  LOG_DEBUG("FragmentToDigit") << "  intercept: " << fitParameters.first << "; slope: " << fitParameters.second;

  for (size_t i = 0; i < fMaxNumberFitIterations; ++i) {

    this->fineMatch(deviceAID, deviceBID, fineEps, fitParametersMaps, timeStamps, matchMaps);
    this->fitClockDrift(deviceAID, deviceBID, timeStamps, matchMaps, fitParametersMaps, "fine_match_" + std::to_string(i));

    fitParameters = fitParametersMaps[deviceAID][deviceBID].back();
    LOG_DEBUG("FragmentToDigit") << "  intercept: " << fitParameters.first << "; slope: " << fitParameters.second;

    std::pair<double, double> prevFitParameters = fitParametersMaps[deviceAID][deviceBID].end()[-2];

    if (fitParameters == prevFitParameters) {
      LOG_DEBUG("FragmentToDigit") << "  Fit parameters did not change!";
      break;
    }

  }

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::printMatchMap(int   const& deviceAID,
                                    int   const& deviceBID,
                                    match_maps & matchMaps) 
{

  std::map< unsigned int, std::vector<unsigned int> > matchAB = matchMaps[deviceAID][deviceBID].back();

  LOG_DEBUG("FragmentToDigit") << "Matches between " << deviceAID << " and " << deviceBID
                               << "\n Matching index pair format: "
                               << "(deviceA " << deviceAID
                               << ", deviceB " << deviceBID << ")";

  for (auto const & itA : matchAB) {
    for (auto const & itB : itA.second) {
      LOG_DEBUG("FragmentToDigit") << "  (" << itA.first << ", " << itB << ")";
    }
  }

  return;
}

//------------------------------------------------------------------------------
uint32_t FragmentToDigit::triggerBits(std::vector<CAENFragment> const& caenFrags)
{

  // the trigger bits are piped into the V1740 board in slot 7, inputs 48 to 63
  // these are example connections as of May 08, 2015
  // 0   WC1      | OR of 2 X view TDCs ANDed with OR of 2 Y
  // 1   WC2      | "                                      " 
  // 2   WC3      | "                                      " 
  // 3   WC4      | "                                      " 
  // 4   BEAMON   | Spill gate : STARTs on $21, STOPs on $36 (cable says $26 but Bill says $36)
  // 5   USTOF    | OR of 4 PMTs
  // 6   DSTOF    | OR of 2 PMTs
  // 7   PUNCH    | OR of 2 X view paddles ANDed with OR of 2 Y
  // 8   HALO     | OR of 2 PMTs
  // 9   PULSER   |
  // 10  COSMICON | Cosmic gate : STARTs on $36, STOPs on $00 (not optimal, would like to stop before $00)
  // 11  COSMIC   | the trigger signal from the cosmic rack
  // 12  PILEUP   | Coincidence of any later LARSCINT with a delayed gate initiated by itself. Higher discrimination thresh. 
  // 13  MICHEL   | Coincidence of two light flashes in TPC (LARSCINT) occurring within a 5us time window
  // 14  LARSCINT | Coincidence of Hamamatsu and ETL PMTs (discriminated)
  // 15  MuRS     | Any coincidence of two planes.  Each plane is the OR of the discriminated pulses of 4 paddles. 

  // Each waveform corresponds to a single trigger channel.  If the (pedestal subtracted?) value of any ADC
  // in a waveform is less than 0, then the trigger for that channel fired

  //Need database eventually to set this correctly for different data-taking periods.

  std::bitset<16> triggerBits;

  size_t minChan  = 48;
  size_t maxChan  = 64;
  float  pedestal = 0.;
  for(auto const& frag : caenFrags){

    if     (frag.header.boardId != 7  && fRunNumber < 6155) continue;
    else if(frag.header.boardId != 24 && fRunNumber > 6154) continue;

    for(size_t chan = minChan; chan < maxChan; ++chan){ 
      if(chan > frag.waveForms.size() )
	throw cet::exception("FragmentToDigit") << "attempting to access channel "
						<< chan << " from 1740 fragment with only "
						<< frag.waveForms.size() << " channels";
      
      std::vector<short> const trig(frag.waveForms[chan].data.begin(), frag.waveForms[chan].data.end());
      pedestal = this->findPedestal(trig);
      for(auto const& data : trig){
	if(data < pedestal) triggerBits.set(chan - minChan);
      }
    } // end loop over channels on the board
  } // end loop over caen fragments

  return triggerBits.to_ulong();
}  

//------------------------------------------------------------------------------
void FragmentToDigit::makeTPCRawDigits(std::vector<CAENFragment> const& caenFrags,
				       std::vector<raw::RawDigit>     & tpcDigits)
{
  raw::ChannelID_t tpcChan = 0;
  size_t maxChan = 64;
  size_t boardId = 0;
  float  ped     = 0.;

  // make a list of the starting wire number for each board channel 0
  size_t startWireInd[8] = {239, 175, 111, 47,   0,   0,   0, 0 };
  size_t startWireCol[8] = {0,   0,   0,   239, 223, 159, 95, 31};
 
  for(auto const& frag : caenFrags){
    
    // the TPC mapping has the readout going to boards 0-7 of
    // the CAEN 1751, channels 0-63 of the boards 0-6, channels 0-31 of board 7
    // To make things hard, we decided to count the wires down instead of up
    // Board 0 channel 0  --> wire 239 of the induction plane
    // Board 3 channel 48 --> wire 0   of the induction plane
    // Board 3 channel 49 --> wire 239 of the collection plane
    // Board 7 channel 32 --> wire 0   of the collection plane
    boardId = frag.header.boardId;
    if(boardId > 7) continue;
    else{
      if(boardId < 7) maxChan = 64;
      else maxChan = 32;
      for(size_t chan = 0; chan < maxChan; ++chan){ 
	if(chan > frag.waveForms.size() )
	  throw cet::exception("FragmentToDigit") << "attempting to access channel "
						  << chan << " from 1740 fragment with only "
						  << frag.waveForms.size() << " channels";

	// get TPC channel for the induction plane
	if( boardId < 3 || (boardId == 3 && chan < 48) )
	  tpcChan = startWireInd[boardId] - chan;
	// get TPC Channel for the collection plane
	else if( boardId > 3)
	  tpcChan = 240 + startWireCol[boardId] - chan;
	else if(boardId == 3 && chan > 47)
	  tpcChan = 240 + startWireCol[boardId] - chan + 48;

	// as of v04_13_00 of LArSoft, the event display no longer takes the
	// pedestal value from the RawDigit and uses an interface to a database instead
	// that doesn't really work for LArIAT, so pre-pedestal subtract the data
	// and keep the pedestal value for reference in the RawDigit
	std::vector<short> const padc(frag.waveForms[chan].data.begin(), frag.waveForms[chan].data.end());
	ped = this->findPedestal(padc);
	fRawDigitPedestals->Fill(ped);
	std::vector<short> adc(padc.size());
        for(size_t a = 0; a < adc.size(); ++a){
	  adc[a] = padc[a] - (short)ped;
	  fRawDigitADC->Fill(adc[a]);
	}

	raw::RawDigit rd(tpcChan, adc.size(), adc);
	rd.SetPedestal(ped);
	tpcDigits.push_back(rd);
      } // end loop to fill channels from this board
    }// end if it is a TPC board      
  }// end loop over caen fragments

  return;
  
}

//------------------------------------------------------------------------------
float FragmentToDigit::findPedestal(const std::vector<short> & adcVec)
{
  // do nothing if there are no values in the vector
  if(adcVec.size() < 1) return 0.;

  // for now try taking the simple mean of the values in the 
  // vector and return that as the pedestal
  float mean = 0.;
  for(auto const& adc : adcVec) mean += adc;
  mean /= 1.*adcVec.size();

  return mean;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeOpDetPulses(std::vector<CAENFragment>    const& caenFrags,
				      std::vector<raw::OpDetPulse>      & opDetPulse)
{
  // loop over the caenFrags
  uint32_t boardId        = 0;
  uint32_t triggerTimeTag = 0;

  for(auto const& caenFrag : caenFrags){

    boardId        = caenFrag.header.boardId;
    triggerTimeTag = caenFrag.header.triggerTimeTag;

    if(fOpticalDetChannels.count(boardId) > 0){

      // loop over the channels on this board connected to optical detectors
      for(auto ch : fOpticalDetChannels.find(boardId)->second){

	// check that the current channel, ch, is a valid one for grabbing a waveform
	if(ch > caenFrag.waveForms.size() )
	  throw cet::exception("FragmentToDigit") << "requested channel, " << ch 
						  << " from board "        << boardId
						  << " is beyond the scope of the waveform vector";

	std::vector<short> waveForm(caenFrag.waveForms[ch].data.begin(), caenFrag.waveForms[ch].data.end());
   
	// LOG_VERBATIM("FragmentToDigit") << "Writing opdetpulses " 
	// 			       << " boardID : " << boardId 
	// 			       << " channel " << ch 
	// 			       << " size of wvform data " << waveForm.size()
	// 			       << " fOpDetChID[boardId] size() " << fOpDetChID[boardId].size();

	opDetPulse.push_back(raw::OpDetPulse(static_cast <unsigned short> (ch),
					     waveForm,
					     0,
					     static_cast <unsigned int> (triggerTimeTag)
					     )
			     );

      } // end loop over channels on this board
    } // end if this board has optical channels on it
  } // end loop over fragments

  return;
}

//------------------------------------------------------------------------------
// boardId is the ID of the board we want to grab the digits from
// boardChans holds the channels on that board that we care about for this
// set of digits we want to make
// chanOffset is the value we subtract from the board channel so that the 
// digits have the right channel range for the desired auxiliary detector (ie 
// channel 0 of the muon range stack is not necessarily on channel 0 of the 
// caen board)
// detName is the name of the detector
void FragmentToDigit::caenFragmentToAuxDetDigits(std::vector<CAENFragment>     const& caenFrags,
						 std::vector<raw::AuxDetDigit>      & auxDetDigits,
						 uint32_t                      const& boardId,
						 std::set<uint32_t>            const& boardChans,
						 uint32_t                      const& chanOffset,
						 std::string                   const& detName)
{
  // loop over the fragments and grab the one corresponding to this board ID
  for(auto const& frag : caenFrags){

    if(frag.header.boardId != boardId) continue;

    // loop over the channels in the set
    for( auto const& ch : boardChans){
      
      // check that ch is larger than chanOffset
      if(ch < chanOffset)
	throw cet::exception("FragmentToDigit") << "requested channel, " << ch
						<< " is smaller than the requested offest "
						<< chanOffset;

      // check that there is a waveform for the chosen channel
      if(ch > frag.waveForms.size() )
	throw cet::exception("FragmentToDigit") << "requested channel, " << ch 
						<< " from board "        << boardId
						<< " is beyond the scope of the waveform vector";
      
      std::vector<short> waveForm(frag.waveForms[ch].data.begin(), frag.waveForms[ch].data.end());
	
      // place the AuxDetDigit in the vector
      auxDetDigits.push_back(raw::AuxDetDigit(static_cast<unsigned short> (ch - chanOffset),
					      waveForm,
					      detName,
					      static_cast<unsigned long long>(frag.header.triggerTimeTag))
			     );

    } // end loop over channels on the board
  } // end loop over fragments
  
  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeMuonRangeDigits(std::vector<CAENFragment>     const& caenFrags,
					  std::vector<raw::AuxDetDigit>      & mrAuxDigits)
{
  // The Muon Range Stack channels are all on the V1740 board in slot 7
  // The channels are 32 <= ch < 48
  uint32_t boardId = 7;
  uint32_t chanOff = 32;
  uint32_t maxChan = 48;
  std::set<uint32_t> boardChans;

  // Starting in run 6155 the MuRS channels were read out by boardID 24
  if(fRunNumber > 6154){
    boardId = 24;
    chanOff = 32;
    maxChan = 48;
  }

  for(uint32_t bc = chanOff; bc < maxChan; ++bc) boardChans.insert(bc);

  this->caenFragmentToAuxDetDigits(caenFrags, mrAuxDigits, boardId, boardChans, chanOff, "MuonRangeStack");

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeTOFDigits(std::vector<CAENFragment>     const& caenFrags,
				    std::vector<raw::AuxDetDigit>      & tofAuxDigits)
{
  // TOF inputs are all sent to board 8
  uint32_t boardId = 8;
  uint32_t chanOff = 0;
  std::set<uint32_t> boardChans;

  for(uint32_t bc = chanOff; bc < 2; ++bc) boardChans.insert(bc);
  this->caenFragmentToAuxDetDigits(caenFrags, tofAuxDigits, boardId, boardChans, chanOff, "TOFUS");
  
  boardChans.clear();
  chanOff = 2;
  for(uint32_t bc = chanOff; bc < 4; ++bc) boardChans.insert(bc);
  this->caenFragmentToAuxDetDigits(caenFrags, tofAuxDigits, boardId, boardChans, chanOff, "TOFDS");

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeAeroGelDigits(std::vector<CAENFragment>     const& caenFrags,
					std::vector<raw::AuxDetDigit>      & agAuxDigits)
{
  // Aerogel inputs are all sent to board 8
  uint32_t boardId = 8;
  uint32_t chanOff = 4;
  std::set<uint32_t> boardChans;

  // Call this for each AeroGel counter
  for(uint32_t bc = chanOff; bc < 6; ++bc) boardChans.insert(bc);
  this->caenFragmentToAuxDetDigits(caenFrags, agAuxDigits, boardId, boardChans, chanOff, "AeroGelUS");

  boardChans.clear();
  chanOff = 6;
  for(uint32_t bc = chanOff; bc < 8; ++bc) boardChans.insert(bc);
  this->caenFragmentToAuxDetDigits(caenFrags, agAuxDigits, boardId, boardChans, chanOff, "AeroGelDS");

  return;
}

//------------------------------------------------------------------------------
// Halo paddles are currently (Jun 4, 2015) attached to board 9, channels 5 and 6
void FragmentToDigit::makeHaloDigits(std::vector<CAENFragment>     const& caenFrags,
				     std::vector<raw::AuxDetDigit>      & hAuxDigits)
{
  // Halo inputs are all sent to board 8
  uint32_t boardId = 9;
  uint32_t chanOff = 5;
  uint32_t maxChan = 7;
  std::set<uint32_t> boardChans;

  for(uint32_t bc = chanOff; bc < maxChan; ++bc) boardChans.insert(bc);
  this->caenFragmentToAuxDetDigits(caenFrags, hAuxDigits, boardId, boardChans, chanOff, "Halo");

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::makeTriggerDigits(std::vector<CAENFragment>     const& caenFrags,
					std::vector<raw::AuxDetDigit>      & trAuxDigits)
{
  // The trigger waveforms all come on board 7, channels 48-63
  uint32_t boardId = 7;
  uint32_t chanOff = 48;
  uint32_t maxChan = 64;
  std::set<uint32_t> boardChans;
  std::vector<std::string> trigNames;
  trigNames.push_back("WC1");
  trigNames.push_back("WC2");    
  trigNames.push_back("WC3");      
  trigNames.push_back("WC4");    
  trigNames.push_back("BEAMON"); 
  trigNames.push_back("USTOF");  
  trigNames.push_back("DSTOF");    
  trigNames.push_back("PUNCH");  
  trigNames.push_back("HALO");   
  trigNames.push_back("PULSER"); 
  trigNames.push_back("COSMICON"); 
  trigNames.push_back("COSMIC"); 
  trigNames.push_back("PILEUP"); 
  trigNames.push_back("MICHEL"); 
  trigNames.push_back("LARSCINT"); 
  trigNames.push_back("MuRS");

  // Starting in run 6155 the trigger channels were read out by boardID 24
  if(fRunNumber > 6154){
    boardId = 24;
    chanOff = 48;
    maxChan = 64;
  }

  // Call this for each AeroGel counter
  for(uint32_t tc = 0; tc < maxChan - chanOff; ++tc){
    boardChans.clear();
    boardChans.insert(chanOff + tc);
    this->caenFragmentToAuxDetDigits(caenFrags, trAuxDigits, boardId, boardChans, chanOff, trigNames[tc]);
  }

  return;
}

//------------------------------------------------------------------------------
// The map below indicates how each TDC maps to each Wire Chamber
// channel            wires
//   0   |-----------| 1
// TDC 3 |           |
//   63  |           |
//       |           | Wire Chamber 1
//   0   |           |
// TDC 4 |           |
//   63  |-----------| 128
//       TDC1     TDC2
//       0  63   0  63 channel
// wires 1         128

// channel            wires
//   0   |-----------| 1
// TDC 7 |           |
//   63  |           |
//       |           | Wire Chamber 2
//   0   |           |
// TDC 8 |           |
//   63  |-----------| 128
//       TDC5     TDC6
//       0  63   0  63 channel
// wires 1         128

// channel            wires
//   0   |-----------| 1
// TDC 11|           |
//   63  |           |
//       |           | Wire Chamber 3
//   0   |           |
// TDC 12|           |
//   63  |-----------| 128
//       TDC9     TDC10
//       0  63   0  63 channel
// wires 1         128

// channel            wires
//   0   |-----------| 1
// TDC 15|           |
//   63  |           |
//       |           | Wire Chamber 4
//   0   |           |
// TDC 16|           |
//   63  |-----------| 128
//       TDC13    TDC14
//       0  63   0  63 channel
// wires 1         128
//
// take the convention that vertical wire numbers start at channel 128
void FragmentToDigit::InitializeMWPCContainers()
{
  this->CleanUpMWPCContainers();

  // make the map of TDC number to detector name and tdc to starting channel
  for(size_t tdc = 1; tdc < 17; ++tdc){
    if(tdc < 5)       fTDCToChamber[tdc] = 0;
    else if(tdc < 9)  fTDCToChamber[tdc] = 1;
    else if(tdc < 13) fTDCToChamber[tdc] = 2;
    else              fTDCToChamber[tdc] = 3;

    if     (tdc == 1 || tdc == 5 || tdc == 9  || tdc == 13) fTDCToStartWire[tdc] = 0;
    else if(tdc == 2 || tdc == 6 || tdc == 10 || tdc == 14) fTDCToStartWire[tdc] = 64;
    else if(tdc == 3 || tdc == 7 || tdc == 11 || tdc == 15) fTDCToStartWire[tdc] = 128;
    else if(tdc == 4 || tdc == 8 || tdc == 12 || tdc == 16) fTDCToStartWire[tdc] = 192;
  }

  // had swapped cables in runs 5546 - 5598 for TDC 7 and 8.
  if(fRunNumber > 5545 && fRunNumber < 5599){
    fTDCToStartWire[7] = 192;
    fTDCToStartWire[8] = 128;
  }

  fMWPCNames.resize(4);
  fMWPCNames[0] = "MWPC1";
  fMWPCNames[1] = "MWPC2";
  fMWPCNames[2] = "MWPC3";
  fMWPCNames[3] = "MWPC4";

  return;
}

//------------------------------------------------------------------------------
void FragmentToDigit::CleanUpMWPCContainers()
{
  fMWPCNames           .clear();
  fTDCToStartWire      .clear();   
  fTDCToChamber        .clear();

  return;
}

//------------------------------------------------------------------------------
// set the name of the detector in the AuxDetDigit to be of the form
// MWPCXX where XX is the controller Number
void FragmentToDigit::makeMWPCDigits(std::vector<TDCFragment::TdcEventData> const& tdcEventData,
				     std::vector<raw::AuxDetDigit>               & mwpcAuxDigits)
{

  size_t channelsPerChamber = TDCFragment::N_CHANNELS * TDCFragment::TDCS_PER_CHAMBER;

  // vector to hold the channels for a single MWPC
  std::vector<std::vector<short> > chamberHits(TDCFragment::MAX_CHAMBERS * channelsPerChamber);

  // vector to hold the timeStamps for each channel in the MWPC
  std::vector<unsigned long long> chamberTimeStamps(TDCFragment::MAX_CHAMBERS * channelsPerChamber, 0);

  // LOG_VERBATIM("FragmentToDigit") << "there are " << tdcEventData.size() << " tdcEventData objects in the vector";

  for(auto const& tdced : tdcEventData){ 

    // determine the chamber and start wire
    auto switr = fTDCToStartWire.find(tdced.tdcEventHeader.tdcNumber);
    auto chitr = fTDCToChamber.find(tdced.tdcEventHeader.tdcNumber);

    if( chitr == fTDCToChamber.end() || switr == fTDCToStartWire.end() )
      throw cet::exception("FragmentToDigit") << "TDC number " << tdced.tdcEventHeader.tdcNumber
					      << " is not present in map to chamber number or start wire";

    // LOG_VERBATIM("FragmentToDigit") << "there are " << tdced.tdcHits.size() << " tdc hit objects in the vector for chamber "
    // 				    << chitr->second << " on tdc " << chitr->first << " start wire " << switr->second;
    
    for(auto const& hit : tdced.tdcHits){
      if(chitr->second >= TDCFragment::MAX_CHAMBERS || 
	 switr->second + (size_t)hit.channel >= channelsPerChamber
	 )
	throw cet::exception("FragmentToDigit") << "Chamber is " << chitr->second << "/" << TDCFragment::MAX_CHAMBERS
						<< " hit channel is " << (size_t)hit.channel
						<< " first wire in tdc is " << switr->second << "/" 
						<< channelsPerChamber;

      chamberHits      [chitr->second * channelsPerChamber + switr->second + size_t (hit.channel)].push_back(hit.timeBin);
      chamberTimeStamps[chitr->second * channelsPerChamber + switr->second + size_t (hit.channel)] = tdced.tdcEventHeader.tdcTimeStamp;

      // LOG_VERBATIM("FragmentToDigit") << chamberHits[chitr->second * channelsPerChamber + switr->second + size_t (hit.channel)].size() << " " 
      // 				      << (size_t)hit.channel << " " << switr->second << " " << (size_t)hit.timeBin << "\t" 
      // 				      << chamberTimeStamps[chitr->second * channelsPerChamber + switr->second + size_t (hit.channel)] << " " 
      // 				      << tdced.tdcEventHeader.tdcTimeStamp;
	
    }
      
  } // end loop over tdcEventData

  // now make the AuxDetDigits for this fragment
  for(size_t cham = 0; cham < TDCFragment::MAX_CHAMBERS; ++cham){
    for(size_t chan = 0; chan < channelsPerChamber; ++chan){

      if(chamberHits[cham*channelsPerChamber + chan].size() < 1) continue;
      
      mwpcAuxDigits.push_back(raw::AuxDetDigit(static_cast <unsigned short> (chan),
					       chamberHits[cham*channelsPerChamber + chan],
					       fMWPCNames[cham],
					       static_cast <unsigned long long> (chamberTimeStamps[cham*channelsPerChamber + chan]))
			      );

    }
    
  } // end loops to create AuxDetDigits

  return;
}

DEFINE_ART_MODULE(FragmentToDigit)
