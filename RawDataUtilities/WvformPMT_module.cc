////////////////////////////////////////////////////////////////////////
// Class:       WvformPMT
// Module Type: analyzer
// File:        WvformPMT_module.cc
//
// written by Pawel Kryczynski based on the DigitReader_module Generated at Tue Feb 10 15:40:09 2015 by Will Flanagan using artmod
// from cetpkgsupport v1_08_02 and OpDigiAna_module (by Christie Chiu and Ben Jones, MIT, 2012)
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Persistency/Common/Ptr.h"
#include "art/Persistency/Common/PtrVector.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "messagefacility/MessageLogger/MessageLogger.h"


#include "RawData/OpDetPulse.h"
#include "RecoBase/OpHit.h"



// ROOT includes
#include "TH1.h"
#include "THStack.h"
#include "TF1.h"
#include "TLorentzVector.h"
#include "TVector3.h"
#include "TArrayD.h"
// C++ Includes
#include <map>
#include <vector>
#include <iostream>
#include <cstring>
#include <sstream>
#include "math.h"
#include <climits>
#include <memory>
class WvformPMT;

class WvformPMT : public art::EDAnalyzer {
public:
  explicit WvformPMT(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  WvformPMT(WvformPMT const &) = delete;
  WvformPMT(WvformPMT &&) = delete;
  WvformPMT & operator = (WvformPMT const &) = delete;
  WvformPMT & operator = (WvformPMT &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
 // void reconfigure(fhicl::ParameterSet const & p) override;
  void endJob() override;
static Double_t twoexp(Double_t *x,Double_t *par);

private:


  // Declare member data here.
    std::string fInputModule;              // Input tag for OpDet collection
    std::string fInstanceName;             // Input tag for OpDet collection
    float fSampleFreq;                     // in MHz
    float fTimeBegin;                      // in us
    float fTimeEnd;                        // in us
    short fPEheight;                       // in ADC counts

   double fFitConst;
   double fExpM1;
   double fExpM2;
   double fExpS1;
   double fExpS2;
   double fFitStart;
   double fFitEnd;

    TF1 *fitexp2;

    double fSPEAmp;
    int  fNumberOfPMTs;
    int  fBaselineCounts;

    char fHistName[50];
  TH1D * avhist [5];
  TH1D * avhist_raw [5];
std::vector<std::vector <double>> bins;
std::vector<std::vector <double>> bins2;
std::vector <double> baseline;
int fEvents;
art::ServiceHandle<art::TFileService> tfs;

};

//------------------------------------------------------------------------------

Double_t WvformPMT::twoexp(Double_t *x,Double_t *par)
{
Double_t arg = 0;
arg = x[0];
Double_t fitval =par[0]+ par[1]*TMath::Exp(-arg/par[2]) +par[3]*TMath::Exp(-arg/par[4]);
return fitval;
}
//-----------------------------------------------------------------------------
WvformPMT::WvformPMT(fhicl::ParameterSet const & p)
  : EDAnalyzer(p)
{


    fTimeBegin  =  p.get<double>("time_begin",0.0);
    fTimeEnd    =  p.get<double>("time_end",7168.0);
    fSampleFreq =  p.get<double>("sample_freq",1.0);


    // Indicate that the Input Module comes from .fcl
    fInputModule = p.get<std::string>("InputModule");
    fInstanceName = p.get<std::string>("InstanceName");
 


   fNumberOfPMTs = p.get<int>("NumberOfPMTs",2);
   fBaselineCounts = p.get<int>("baseline_counts",90);
   fFitConst = p.get<double>("fit_const",0.0);
   fExpM1 = p.get<double>("fit_expmult1",1.0);
   fExpM2 = p.get<double>("fit_expmult2",1.0);
   fExpS1 = p.get<double>("fit_exp_slope1",27.0);
   fExpS2 = p.get<double>("fit_exp_slope2",1000.0);
   fFitStart = p.get<double>("fit_start",2050.0);
   fFitEnd = p.get<double>("fit_end",2050.0);
}



//------------------------------------------------------------------------------
void WvformPMT::beginJob()
{

	fEvents=0;
	bins.resize(fNumberOfPMTs);
        for(int c=0;c<fNumberOfPMTs;c++) {
            sprintf(fHistName, "OpDet_%i_Pulse_sum", c);

	    avhist[c]= tfs->make<TH1D>(fHistName, ";t (ns);", 
					     int((fTimeEnd - fTimeBegin) * fSampleFreq), 
					     fTimeBegin, 
					     fTimeEnd);

            sprintf(fHistName, "OpDet_%i_Pulse_sum_raw", c);

	    avhist_raw[c]= tfs->make<TH1D>(fHistName, ";t (ns);", 
					     int((fTimeEnd - fTimeBegin) * fSampleFreq), 
					     fTimeBegin, 
					     fTimeEnd);

        bins[c].clear();
        bins[c].resize(int((fTimeEnd - fTimeBegin) * fSampleFreq),0.0);
	  
        }

        

}

//------------------------------------------------------------------------------
void WvformPMT::analyze(art::Event const & evt)
{
	fEvents++;

    art::Handle< std::vector< raw::OpDetPulse > > WaveformHandle;

	evt.getByLabel(fInputModule, fInstanceName, WaveformHandle);
    
	std::cout<<" wvform size "<<WaveformHandle->size()<<std::endl;
    std::vector<std::string> histnames;
    // For every OpDet waveform in the vector given by WaveformHandle
    for(unsigned int i = 0; i < WaveformHandle->size(); ++i){
			art::Ptr< raw::OpDetPulse > ThePulsePtr(WaveformHandle, i);
			raw::OpDetPulse ThePulse = *ThePulsePtr;
			for(int j =0;j<int(ThePulse.Waveform().size());j++){
				if(int(j)<int(bins[int(ThePulse.OpChannel())].size())) bins[int(ThePulse.OpChannel())].at(j)=bins[int(ThePulse.OpChannel())].at(j)+(double) ThePulse.Waveform()[j];
  		 }



    }

}

//------------------------------------------------------------------------------
void WvformPMT::endJob()
{
baseline.resize(int(fNumberOfPMTs));

for(int c=0;c<fNumberOfPMTs;c++) {
	fitexp2 = new TF1("exp2",twoexp,0,15000,5);
	for(int j =0;j<fBaselineCounts;j++) baseline.at(c)=baseline.at(c)+double(bins[c].at(j));
	baseline.at(c)=baseline.at(c)/fBaselineCounts;
//	avhist[c]->SetBins(7168,0,7168);
	for(int j =0;j<int(avhist[c]->GetNbinsX());j++) {
			if (int(j)<int(bins[c].size())) avhist[c]->SetBinContent(j,(-double(bins[c].at(j))+baseline.at(c))/fEvents);
			if (int(j)<int(bins[c].size())) avhist_raw[c]->SetBinContent(j,(double(bins[c].at(j))/fEvents));
		}

		fitexp2->SetRange(Double_t(fFitStart),Double_t(fFitEnd));
		fitexp2->SetParameter(0,Double_t(fFitConst));
		fitexp2->SetParameter(1,Double_t(fExpM1));
		fitexp2->SetParameter(2,Double_t(fExpS1));
		fitexp2->SetParameter(3,Double_t(fExpM2));
		fitexp2->SetParameter(4,Double_t(fExpS2));
	  avhist[c]->Fit("exp2", "REM+");
  }

   
}

DEFINE_ART_MODULE(WvformPMT)
