////////////////////////////////////////////////////////////////////////
// Class:       KeepBeamFilter
// Module Type: filter
// File:        KeepBeamFilter_module.cc
//
// Created by Daniel Smith, dansmith@bu.edu
// 
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <TTree.h>
#include <TH1F.h>
#include <TH2F.h>
#include <TH3F.h>
#include <TVector3.h>

#include "art_root_io/TFileService.h"
#include "LArIATDataProducts/TOF.h"
#include "LArIATDataProducts/WCTrack.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/SpacePoint.h"

#include "canvas/Persistency/Common/FindOneP.h" 
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 


#include "larcore/Geometry/Geometry.h"
#include "lardata/Utilities/AssociationUtil.h"



class KeepBeamFilter;

class KeepBeamFilter : public art::EDFilter {
public:
  explicit KeepBeamFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  KeepBeamFilter(KeepBeamFilter const &) = delete;
  KeepBeamFilter(KeepBeamFilter &&) = delete;
  KeepBeamFilter & operator = (KeepBeamFilter const &) = delete;
  KeepBeamFilter & operator = (KeepBeamFilter &&) = delete;

  void reconfigure(fhicl::ParameterSet const & p);

  //bool insideImagPipe(std::vector<double> pos);
  //bool CheckUpstreamMagnetAperture(std::vector<double> hit1, std::vector<double> hit2);
  //bool CheckDownstreamMagnetAperture(std::vector<double> hit1, std::vector<double> hit2);
  //bool CheckDownstreamCollimatorAperture(std::vector<double> hit1, std::vector<double> hit2);


  //  std::vector<double> projToZ(std::vector<double> hit0, std::vector<double> hit1, double zpos);
  void projToZ(double hit0[3], double hit1[3], double (&result)[3], double zpos);
  void resetVar();
  void beginJob() override;
  void endJob() override;
  std::vector<bool> CheckUSMagApertures(double hit0[3], double hit1[3]);
  std::vector<bool> CheckDSMagApertures(double hit0[3], double hit1[3]);
  std::vector<bool> CheckDSColApertures(double hit0[3], double hit1[3]);
  // Required functions.
  bool filter(art::Event & e) override;
  
private:

  // Declare member data here.
  //---------- Filter Parameters ----------
  std::string fTOFModuleLabel;
  std::string fWCTrackLabel;
  bool verbose = false;

  // GEOMETRY!!!!!!!!!!!!!
  art::ServiceHandle<geo::Geometry> fGeo;  

  //---------- Histos ----------


  TH1F* hRadDist;
  TH1F* hRadDistMidPlane;
  

  // ====================== TTree info begin =========================
  // === Storing information into TTree ====
  TTree* fTree;
  //=== Storing Run Information ===
  int run;			//<---Run Number
  int subrun;			//<---SubRun Number
  int event;			//<---Event Number
  // === Storing WC information ===
  double  WC1xPos;
  double  WC1yPos;
  double  WC1zPos;
  double  WC2xPos;
  double  WC2yPos;
  double  WC2zPos;     //<---The WC positions are relative to the lower front corner of the TPC
  double  WC3xPos;
  double  WC3yPos;
  double  WC3zPos;
  double  WC4xPos;
  double  WC4yPos;
  double  WC4zPos;

  double  wcP ;
  double  wcPx;
  double  wcPy;
  double  wcPz;
  double  midPlaneVar;
  double  midPlaneVarX;
  double  midPlaneVarY;
  double  midPlaneVarZ;
  double  wc4ProjVar;
  double  wc4ProjVarX;
  double  wc4ProjVarY;
  double  wc4ProjVarZ;
  
  bool Mag1USPassX, Mag1USPassY, Mag1DSPassY, Mag1Pass, Mag2USPassY, Mag2DSPassX, Mag2DSPassY, Mag2Pass, DSColPassX, DSColPassY, DSColPass, AperturePass;  //All the aperture check booleans.
  // === Storing Time of Flight information ===
  double tofObject;      	//<---The TOF calculated (in ns?) for this TOF object
  double centerTOFsGeoDist;	//<---Geometrical Distance between the centers of the USTOF and DSTOF
  double mass;     		//<--- Storing the mass
  double massApproxL;           //<--- Storing the mass
  double approxPathL;		//<--- Storing approximated path length (cm) 
  
  
  // ====================== TTree info end =========================

  
  // I HATE TO DO THIS: I'M HARDCODING THE POSITIONS OF THE MAGNET CENTERS 
  // CAUSE I DON'T KNOW HOW TO FETCH non-AuxDet pieces in the gdml
  double NDB1_Center[3] = { 55.801, 5.048, -472.218};
  double NDB2_Center[3] = { 47.114, 4.726, -403.146};
  double Magnets_Mid[3] = { (NDB1_Center[0]+NDB2_Center[0])/2., (NDB1_Center[1]+NDB2_Center[1])/2., (NDB1_Center[2]+NDB2_Center[2])/2.};
  
  
  //I hate to do this too, but I have to hard code the corners of the magnetic aperatures and the center of the aperature faces.
  double NDB1_FFace_center[3]={61.186,    5.048,    -501.273};  //XYZ of mag1 upstream face
  double NDB1_BFace_center[3]={50.416,    5.048,    -443.163};  //XYZ of mag1 downstream face
  
  double NDB1_FFace_XZ_slope=5.3955; //using the center and the expected rotation around the Y axis (-10.5deg, nominally), find the equation of the line of the face, in the XZ plane
  double NDB1_FFace_XZ_intercept=2765.814;

  double NDB1_BFace_XZ_slope=5.3955;
  double NDB1_BFace_XZ_intercept=2441.509;  
  
 
    //magnet 2
  double NDB2_FFace_center[3]={49.946,    4.726,    -432.56};  //XYZ of mag2 upstream face
  double NDB2_BFace_center[3]={44.282,    4.726,    -373.732};  //XYZ of mag2 downstream face
  
  double NDB2_FFace_XZ_slope=10.3854;  //Same logic as Magnet 1, but with a -5.5deg rotation.
  double NDB2_FFace_XZ_intercept=4542.253;
  
  double NDB2_BFace_XZ_slope=10.3854;
  double NDB2_BFace_XZ_intercept=3925.637;
  
  
    //DS Collimator
  // Because we expect WC3/4 to be at the same rotation as the DSCol, the planes defining the WCs and the faces of the col are all parallel. 
  //we only need to check at one face, so I use the front face. Yay simplified geometry!
  double DSCol_FFace_center[3]={38.404,    3.323,    -293.256};
  
  double DSCol_FFace_XZ_slope=19.0811;  //Same logic, but with a 3deg rotation.
  double DSCol_FFace_XZ_intercept=5634.062;  
  
   //The position of each corner of the aperture. F or B for Front or Back face. top or bottom (relative to gravity), left or right relative to beam (left = TPC cathode side)
  double NDB1_F_top_left[3]=     {71.879,    12.158,    -449.291};
  double NDB1_F_top_right[3]=    {50.493,    12.158,    -503.255};
  double NDB1_F_bottom_left[3]=  {71.879,    -2.062,    -499.291};
  double NDB1_F_bottom_right[3]= {50.493,    -2.062,    -503.255};
  
  double NDB1_B_top_left[3]=     {61.109,    12.158,    -441.181};    
  double NDB1_B_top_right[3]=    {39.723,    12.158,    -445.145};
  double NDB1_B_bottom_left[3]=  {61.109,    -2.062,    -441.181};
  double NDB1_B_bottom_right[3]= {39.723,    -2.062,    -445.145};
  

  double NDB2_F_top_left[3]=     {60.771,    11.836,    -431.518};
  double NDB2_F_top_right[3]=    {39.121,    11.836,    -433.602};
  double NDB2_F_bottom_left[3]=  {60.771,    -2.384,    -431.518};
  double NDB2_F_bottom_right[3]= {39.121,    -2.384,    -433.602};
  
  double NDB2_B_top_left[3]=     {55.107,    11.836,    -372.690};   
  double NDB2_B_top_right[3]=    {33.457,    11.833,    -374.774};
  double NDB2_B_bottom_left[3]=  {55.107,    -2.384,    -372.690};
  double NDB2_B_bottom_right[3]= {33.457,    -2.384,    -374.774};
  //DS Collimator
  // Because we expect WC3/4 to be at the same rotation as the DSCol, the planes defining the WCs and the faces of the col are all parallel. 
  //we only need to check at one face, so I only need the front face. Yay simplified geometry!

  
  double DSCol_F_top_left[3]=     {45.096,    11.273,    -292.905};
  double DSCol_F_top_right[3]=    {31.712,    11.273,    -293.607};
  double DSCol_F_bottom_left[3]=  {45.096,    -4.627,    -292.905};
  double DSCol_F_bottom_right[3]= {31.712,    -4.627,    -293.607}; 
  /*
  bool MPToWC4;  //Using WC1, WC2, project to midplane. Use that point with WC3 to project to WC4. The boolean that said that passed. Used with fWC4ProjCut
  bool ExtrapolateToMP;  //Using WC1, WC2 project to midplane. Use WC3, WC4, project to Midplane. Are those points close? Used with fMidplaneCut.

  //Bools that track hit apertures.
  bool Magnet1ApertureCheck;
  bool Magnet2ApertureCheck;
  bool DSColApertureCheck;
  
  bool KeepTheEvent; //Depending on which Checks you want to use, the final boolean that combines these checks to decide if the event is good.
  
  //For each "collimator", the bounds of the face of both aperatures [xlow_frontface, xhigh_frontface, xlow_backface, xhigh_backface], similarly for y. In cm, in TPC coordinates. 
  //Taken from survey.
  
  double xboundMagnet1[4]={45.74, 75.52, 35.09, 64.87};
  double yboundMagnet1[4]={-13.12, 13.59, -13.16, 13.55};
  
  double xboundMagnet2[4]={34.88, 65.12, 27.90, 58.15};
  double yboundMagnet2[4]={-13.10, 13.61, -13.08, 13.63};
 
  double xboundDSCol[4]={30.33, 45.42, 26.65, 41.73};
  double yboundDSCol[4]={-15.70, 14.91, -15.53, 15.08};
  // Z Position of the center of the aperatures of each collimator, found by taking the average of the z bounds of the aperature. [zcent_US, zcent_DS]
  double zcentMagnet1[2] = { (-501.95-494.98)/2, (-449.49-456.46)/2};
  double zcentMagnet2[2] = { (-432.04-427.50)/2, (-381.27-385.81)/2};
  double zcentDSCol[2]   = { (-296.67-297.36)/2, (-205.94-206.63)/2};
  double Keepcount=0;
  */

};

// Initialize ttree variables
void KeepBeamFilter::resetVar()
{
  run                = -9999;		
  subrun             = -9999;		
  event              = -9999;		
  WC1xPos            = -9999.;
  WC1yPos            = -9999.;
  WC1zPos            = -9999.;
  WC2xPos            = -9999.;
  WC2yPos            = -9999.;
  WC2zPos            = -9999.;
  WC3xPos            = -9999.;
  WC3yPos            = -9999.;
  WC3zPos            = -9999.;
  WC4xPos            = -9999.;
  WC4yPos            = -9999.;
  WC4zPos            = -9999.;
  wcP                = -9999.;
  wcPx               = -9999.;
  wcPy               = -9999.;
  wcPz               = -9999.;
  midPlaneVar        = -9999.;
  midPlaneVarX       = -9999.;
  midPlaneVarY       = -9999.;
  midPlaneVarZ       = -9999.;
  wc4ProjVar         = -9999.;
  wc4ProjVarX        = -9999.;
  wc4ProjVarY        = -9999.;
  wc4ProjVarZ        = -9999.;
  tofObject          = -9999.;
  centerTOFsGeoDist  = -9999.;
  mass               = -9999.;	
  massApproxL        = -9999.;	
  approxPathL        = -9999.;
  Mag1USPassX        = false;
  Mag1USPassY        = false;
  Mag1DSPassY        = false;
  Mag1Pass           = false;
  Mag2USPassY        = false;
  Mag2DSPassX        = false;
  Mag2DSPassY        = false;
  Mag2Pass           = false;
  DSColPassX         = false;
  DSColPassY         = false;
  DSColPass          = false;
  AperturePass       = false;	
}


// ---------------------- Begin Job ---------------------------
void KeepBeamFilter::endJob()
{

}



// ---------------------- Begin Job ---------------------------
void KeepBeamFilter::beginJob()
{

  // Implementation of optional member function here.
  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("beamtree","analysis tree");
  fTree->Branch("run"                ,&run              ,"run/I"              );	
  fTree->Branch("subrun"             ,&subrun           ,"subrun/I"           );	
  fTree->Branch("event"              ,&event            ,"event/I"            );	
  fTree->Branch("WC1xPos"            ,&WC1xPos          ,"WC1xPos/D"          );
  fTree->Branch("WC1yPos"            ,&WC1yPos          ,"WC1yPos/D"          );
  fTree->Branch("WC1zPos"            ,&WC1zPos          ,"WC1zPos/D"          );
  fTree->Branch("WC2xPos"            ,&WC2xPos          ,"WC2xPos/D"          );
  fTree->Branch("WC2yPos"            ,&WC2yPos          ,"WC2yPos/D"          );
  fTree->Branch("WC2zPos"            ,&WC2zPos          ,"WC2zPos/D"          );
  fTree->Branch("WC3xPos"            ,&WC3xPos          ,"WC3xPos/D"          );
  fTree->Branch("WC3yPos"            ,&WC3yPos          ,"WC3yPos/D"          );
  fTree->Branch("WC3zPos"            ,&WC3zPos          ,"WC3zPos/D"          );
  fTree->Branch("WC4xPos"            ,&WC4xPos          ,"WC4xPos/D"          );
  fTree->Branch("WC4yPos"            ,&WC4yPos          ,"WC4yPos/D"          );
  fTree->Branch("WC4zPos"            ,&WC4zPos          ,"WC4zPos/D"          );
  fTree->Branch("wcP"                ,&wcP              ,"wcP/D"              );
  fTree->Branch("wcPx"               ,&wcPx             ,"wcPx/D"             );
  fTree->Branch("wcPy"               ,&wcPy             ,"wcPy/D"             );
  fTree->Branch("wcPz"               ,&wcPz             ,"wcPz/D"             );
  fTree->Branch("midPlaneVar"        ,&midPlaneVar      ,"midPlaneVar/D"      );
  fTree->Branch("midPlaneVarX"       ,&midPlaneVarX     ,"midPlaneVarX/D"     );
  fTree->Branch("midPlaneVarY"       ,&midPlaneVarY     ,"midPlaneVarY/D"     );
  fTree->Branch("midPlaneVarZ"       ,&midPlaneVarZ     ,"midPlaneVarZ/D"     );
  fTree->Branch("wc4ProjVar"         ,&wc4ProjVar       ,"wc4ProjVar/D"       );
  fTree->Branch("wc4ProjVarX"        ,&wc4ProjVarX      ,"wc4ProjVarX/D"      );
  fTree->Branch("wc4ProjVarY"        ,&wc4ProjVarY      ,"wc4ProjVarY/D"      );
  fTree->Branch("wc4ProjVarZ"        ,&wc4ProjVarZ      ,"wc4ProjVarZ/D"      );
  fTree->Branch("tofObject"          ,&tofObject        ,"tofObject/D"        );
  fTree->Branch("centerTOFsGeoDist"  ,&centerTOFsGeoDist,"centerTOFsGeoDist/D");
  fTree->Branch("mass"               ,&mass             ,"mass/D"             );	
  fTree->Branch("massApproxL"        ,&massApproxL      ,"massApproxL/D"      );	
  fTree->Branch("approxPathL"        ,&approxPathL      ,"approxPathL/D"      );
  	
  fTree->Branch("Mag1USAperaturePassX",&Mag1USPassX       ,"Mag1USPassX/O"       );
  fTree->Branch("Mag1USAperaturePassY",&Mag1USPassY       ,"Mag1USPassY/O"       );
  fTree->Branch("Mag1DSAperaturePassY",&Mag1DSPassY       ,"Mag1DSPassY/O"       );
  fTree->Branch("Mag1Pass"            ,&Mag1Pass         ,"Mag1Pass/O"       );
  
  fTree->Branch("Mag2USAperaturePassY", &Mag2USPassY       ,"Mag2USPassY/O"       );
  fTree->Branch("Mag2DSAperaturePassX", &Mag2DSPassX       ,"Mag2DSPassX/O"       );
  fTree->Branch("Mag2DSAperaturePassY", &Mag2DSPassY       ,"Mag2DSPassY/O"       );
  fTree->Branch("Mag2Pass"            , &Mag2Pass         ,"Mag2Pass/O"       );
  
  fTree->Branch("DSColAperaturePassX", &DSColPassX       ,"DSColPassX/O"       );
  fTree->Branch("DSColAperaturePassY", &DSColPassY       ,"DSColPassY/O"       ); 
  
  fTree->Branch("DSColPass",           &DSColPass         ,"DSColPass/O"       );
  
  fTree->Branch("AperturePass",       &AperturePass,      "AperturePass/O");
  
  hRadDist          = tfs->make<TH1F>("hRadDist","hRadDist", 200, 0.0, 100.0);  
  hRadDistMidPlane  = tfs->make<TH1F>("hRadDistMid","hRadDistmid", 200, 0.0, 10.0);  


}


KeepBeamFilter::KeepBeamFilter(fhicl::ParameterSet const & p)
: EDFilter(p)
// Initialize member data here.
{
  this->reconfigure(p);
  // Call appropriate produces<>() functions here.
}

bool KeepBeamFilter::filter(art::Event & evt)
{
  // Let's prepare for the ttree
  resetVar();  

  
  // This I can fetch from the Geo: much better!
  double USTOF_Center[3];
  double WC1_Center[3];
  double WC2_Center[3];
  double WC3_Center[3];
  double WC4_Center[3];
  double DSTOF_Center[3];

  //Load the geometry
  for( size_t iDet = 0; iDet < fGeo->NAuxDets() ; ++iDet ){
    geo::AuxDetGeo const& anAuxDetGeo = fGeo->AuxDet(iDet);
    std::string detName = anAuxDetGeo.Name();
    if(verbose)std::cout<<detName<<"\n";
    if( detName == "volAuxDetTOFUS")        anAuxDetGeo.GetCenter(USTOF_Center); 
    if( detName == "volAuxDetSensitiveWC1") anAuxDetGeo.GetCenter(WC1_Center); 
    if( detName == "volAuxDetSensitiveWC2") anAuxDetGeo.GetCenter(WC2_Center); 
    if( detName == "volAuxDetSensitiveWC3") anAuxDetGeo.GetCenter(WC3_Center); 
    if( detName == "volAuxDetSensitiveWC4") anAuxDetGeo.GetCenter(WC4_Center); 
    if( detName == "volAuxDetTOFDS")        anAuxDetGeo.GetCenter(DSTOF_Center); 
  }

  if (verbose) {
    std::cout<<"USTOF "<<USTOF_Center[0]<<" "<<USTOF_Center[1]<<" "<<USTOF_Center[2]<<" "<<"\n";
    std::cout<<"WC1   "<<WC1_Center[0]<<" "<<WC1_Center[1]<<" "<<WC1_Center[2]<<" "<<"\n";
    std::cout<<"WC2   "<<WC2_Center[0]<<" "<<WC2_Center[1]<<" "<<WC2_Center[2]<<" "<<"\n";
    std::cout<<"WC3   "<<WC3_Center[0]<<" "<<WC3_Center[1]<<" "<<WC3_Center[2]<<" "<<"\n";
    std::cout<<"WC4   "<<WC4_Center[0]<<" "<<WC4_Center[1]<<" "<<WC4_Center[2]<<" "<<"\n";
    std::cout<<"DSTOF "<<DSTOF_Center[0]<<" "<<DSTOF_Center[1]<<" "<<DSTOF_Center[2]<<" "<<"\n";
  }



  // Test if the TOF exists in the event, if not, filter out the event
  art::Handle< std::vector<ldp::TOF> > TOFColHandle;
  std::vector<art::Ptr<ldp::TOF> > tof;  
  if(!evt.getByLabel(fTOFModuleLabel,TOFColHandle)) return false; 
  art::fill_ptr_vector(tof, TOFColHandle);   
  if ( tof.size() != 1 ) return false; 
  else if ( tof[0]->NTOF() != 1) return false; 



  // Test if one WCTrack exists in the event, if not, filter out the event
  art::Handle< std::vector<ldp::WCTrack> > wctrackHandle;
  std::vector<art::Ptr<ldp::WCTrack> > wctrack;
  if(!evt.getByLabel(fWCTrackLabel, wctrackHandle)) return false;  
  art::fill_ptr_vector(wctrack, wctrackHandle);
  if (wctrack.size() != 1) return false;


  // Store a bunch of information for the ttree
  // 0: event information
  run         = evt.run();		
  subrun      = evt.subRun();		
  event       = evt.event();		
  // 1: Time of flight
  // The TOF calculated (in ns) for this TOF object   
  tofObject =  tof[0]->SingleTOF(0);
  centerTOFsGeoDist = TMath::Sqrt((USTOF_Center[0] - DSTOF_Center[0])*(USTOF_Center[0] - DSTOF_Center[0]) + 
				  (USTOF_Center[1] - DSTOF_Center[1])*(USTOF_Center[1] - DSTOF_Center[1]) + 
				  (USTOF_Center[2] - DSTOF_Center[2])*(USTOF_Center[2] - DSTOF_Center[2]) ) ;
  
  // 2: quantities relative to the WCs
  auto theWCTrack = wctrack[0];  
  // Let's store the hits first
  double WC1Hits[3] = {theWCTrack->HitPosition(0,0), theWCTrack->HitPosition(0,1), theWCTrack->HitPosition(0,2)};
  double WC2Hits[3] = {theWCTrack->HitPosition(1,0), theWCTrack->HitPosition(1,1), theWCTrack->HitPosition(1,2)};
  double WC3Hits[3] = {theWCTrack->HitPosition(2,0), theWCTrack->HitPosition(2,1), theWCTrack->HitPosition(2,2)};
  double WC4Hits[3] = {theWCTrack->HitPosition(3,0), theWCTrack->HitPosition(3,1), theWCTrack->HitPosition(3,2)};
  
  WC1xPos     = WC1Hits[0];
  WC1yPos     = WC1Hits[1];
  WC1zPos     = WC1Hits[2];
  WC2xPos     = WC2Hits[0];
  WC2yPos     = WC2Hits[1];
  WC2zPos     = WC2Hits[2];
  WC3xPos     = WC3Hits[0];
  WC3yPos     = WC3Hits[1];
  WC3zPos     = WC3Hits[2];
  WC4xPos     = WC4Hits[0];
  WC4yPos     = WC4Hits[1];
  WC4zPos     = WC4Hits[2];

  double PT          = theWCTrack->Momentum();
  double wctrk_theta = theWCTrack->Theta();
  double wctrk_phi   = theWCTrack->Phi();
  double tanThetaCosPhi = TMath::Tan(wctrk_theta) * TMath::Cos(wctrk_phi);
  double tanThetaSinPhi = TMath::Tan(wctrk_theta) * TMath::Sin(wctrk_phi);
  double den = TMath::Sqrt(1+tanThetaCosPhi*tanThetaCosPhi);
  wcPz = PT/den;
  wcPy = wcPz*tanThetaSinPhi;
  wcPx = wcPz*tanThetaCosPhi;
  wcP  = wcPz* TMath::Sqrt(1+TMath::Tan(wctrk_theta)*TMath::Tan(wctrk_theta));


  // require a hit on each wc plane ==> CHANGE CHANGE CHANGE
  if( wctrack[0]->NHits() != 8) return false;  

  //
  // Calculating the mass
  //
  double fDistanceTraveled = centerTOFsGeoDist; 
  double radical = tofObject*29.9792458*29.9792458*tofObject/(fDistanceTraveled*fDistanceTraveled) - 1;

  if (tofObject>0){
    if (radical < 0)
      {mass = -wcP*pow(-radical ,0.5);}
    else
      {mass = wcP*pow(radical ,0.5);} 
  }


  // Calculate the approximated path length: 
  // take hits on WC1 and WC2 project them to the USTOF z location: define upstream hit
  // take hits on WC1 and WC2 project them to the middle of the magnets in z: define mid1 hit
  // calculate L1 = distance between upstream and mid1 hits
  // take hits on WC3 and WC4 project them to the DSTOF z location: define downstream hit
  // take hits on WC3 and WC4 project them to the middle of the magnets in z: define mid2 hit
  // calculate L2 = distance between downstream and mid2 hits
  // approxPathL = L1 + L2
  double upstreamHit[3];
  double mid1Hit[3];
  double mid2Hit[3];
  double downstreamHit[3];
  double proj4[3];

  projToZ(WC1Hits, WC2Hits, upstreamHit  , USTOF_Center[2]);
  projToZ(WC1Hits, WC2Hits, mid1Hit      , Magnets_Mid [2]);
  projToZ(WC3Hits, WC4Hits, mid2Hit      , Magnets_Mid [2]);
  projToZ(WC3Hits, WC4Hits, downstreamHit, DSTOF_Center[2]);
  projToZ(mid1Hit, WC3Hits, proj4        ,   WC4_Center[2]);
  
  std::vector<bool> Mag1Bools=CheckUSMagApertures(WC1Hits, WC2Hits);  //{USX, USY, DSY, Total}
  std::vector<bool> Mag2Bools=CheckDSMagApertures(WC3Hits, WC4Hits);  //{USY, DSX, DSY, Total}
  std::vector<bool> DSColBools=CheckDSColApertures(WC3Hits, WC4Hits); //{X,Y,total}
  
 
  Mag1USPassX=Mag1Bools[0];
  Mag1USPassY=Mag1Bools[1]; 
  Mag1DSPassY=Mag1Bools[2]; 
  Mag1Pass=Mag1Bools[3]; 
  
  Mag2USPassY=Mag2Bools[0]; 
  Mag2DSPassX=Mag2Bools[1]; 
  Mag2DSPassY=Mag2Bools[2]; 
  Mag2Pass=Mag2Bools[3]; 
  
  DSColPassX=DSColBools[0]; 
  DSColPassY=DSColBools[1]; 
  DSColPass=DSColBools[2]; 
  
  if (Mag1Pass && Mag2Pass && DSColPass){AperturePass=true;}
  else {AperturePass=false;}
  double L1 = TMath::Sqrt((upstreamHit[0] - mid1Hit[0])*(upstreamHit[0] - mid1Hit[0]) +
			  (upstreamHit[1] - mid1Hit[1])*(upstreamHit[1] - mid1Hit[1]) +
			  (upstreamHit[2] - mid1Hit[2])*(upstreamHit[2] - mid1Hit[2]) ) ;
 
  double L2 = TMath::Sqrt((downstreamHit[0] - mid2Hit[0])*(downstreamHit[0] - mid2Hit[0]) +
			  (downstreamHit[1] - mid2Hit[1])*(downstreamHit[1] - mid2Hit[1]) +
			  (downstreamHit[2] - mid2Hit[2])*(downstreamHit[2] - mid2Hit[2]) ) ;
  approxPathL = L1 + L2;

  if (verbose)
    for (size_t index = 0; index<3; index++ ) std::cout<<"Calculated projections: "<< upstreamHit[index] << " "<< mid1Hit[index]<<" "<<mid2Hit[index]<<" "<<downstreamHit[index]<<"\n"; 

  // Mass with approximated length
  fDistanceTraveled = approxPathL; 
  radical = tofObject*29.9792458*29.9792458*tofObject/(fDistanceTraveled*fDistanceTraveled) - 1;

  if (tofObject>0){
    if (radical < 0)
      {massApproxL = -wcP*pow(-radical ,0.5);}
    else
      {massApproxL = wcP*pow(radical ,0.5);} 
  }
  
  //Fill midPlaneVar
  midPlaneVarX = mid1Hit[0] - mid2Hit[0];
  midPlaneVarY = mid1Hit[1] - mid2Hit[1];
  midPlaneVarZ = mid1Hit[2] - mid2Hit[2];
  midPlaneVar  = TMath::Sqrt(midPlaneVarX*midPlaneVarX + midPlaneVarY*midPlaneVarY + midPlaneVarZ*midPlaneVarZ);

  // Fill wc4Projection
  
  wc4ProjVarX = proj4[0] - WC4Hits[0];
  wc4ProjVarY = proj4[1] - WC4Hits[1];
  wc4ProjVarZ = proj4[2] - WC4Hits[2];
  wc4ProjVar  = TMath::Sqrt(wc4ProjVarX*wc4ProjVarX + wc4ProjVarY*wc4ProjVarY + wc4ProjVarZ*wc4ProjVarZ);

  fTree->Fill();

  return true;  
}



//==================================================================================================
void KeepBeamFilter::reconfigure(fhicl::ParameterSet const & p)
{                                                                                                   
  fTOFModuleLabel  = p.get< std::string >("TOFModuleLabel", "tof"    );
  fWCTrackLabel    = p.get< std::string >("WCTrackLabel"  , "wctrack");
  verbose          = p.get<     bool    >("verbose"       , false    );
}

void  KeepBeamFilter::projToZ(double hit0[3], double hit1[3], double (&result)[3] , double zpos){
  //
  // This code is used to find the point at z = zpos along 
  // the line created by hit0 and hit1. Uses the parameterized vector form of a line
  //
  // <x, y, z> = <sx, sy, sz> * t + <startx, starty, startz>
  // sx, sy, sz are all slopes
  //
  // (z - startz) / sz = t
  // x = sx * t + startx
  // y = sx * t + srarty
  //
      
  double sx = hit1[0] - hit0[0];
  double sy = hit1[1] - hit0[1];
  double sz = hit1[2] - hit0[2];

  double t = (zpos - hit0[2]) / sz;

  result[0] = sx * t + hit0[0]; 
  result[1] = sy * t + hit0[1]; 
  result[2] = zpos;

}

std::vector<bool> KeepBeamFilter::CheckUSMagApertures(double hit0[3], double hit1[3])
{

bool Mag1USPassX, Mag1USPassY, Mag1DSPassY, Mag1Pass;
//Front face checks
//Get slope-intercept form of track
double XZ_slope=(hit1[0]-hit0[0])/(hit1[2]-hit0[2]);
double XZ_intercept= hit0[0]-XZ_slope*hit0[2];

double z_intersect_us=(XZ_intercept-NDB1_FFace_XZ_intercept)/(NDB1_FFace_XZ_slope-XZ_slope);

//We now have the z coordinate where the track intersects the infinite plane of the US aperture. Get the 3D intersection point.
double USFFHit[3];
projToZ(hit0, hit1, USFFHit, z_intersect_us);

//And check whether this intersection point is in the finite bounds of the magnet

//US X Bound check
if(USFFHit[0]<NDB1_F_top_left[0] && USFFHit[0]>NDB1_F_top_right[0]) {Mag1USPassX=true;}
else{Mag1USPassX=false;}

//US Y Bound Check
if(USFFHit[1]<NDB1_F_top_left[1] && USFFHit[1]>NDB1_F_bottom_left[1]) {Mag1USPassY=true;}
else{Mag1USPassY=false;}  


//Same process for the DS aperture  
double z_intersect_ds=(XZ_intercept-NDB1_BFace_XZ_intercept)/(NDB1_BFace_XZ_slope-XZ_slope);
double USBFHit[3];
projToZ(hit0, hit1, USBFHit, z_intersect_ds); 

//We only check Y here, as there is a bend in X.
if(USBFHit[1]<NDB1_B_top_left[1] && USBFHit[1]>NDB1_B_bottom_left[1]) {Mag1DSPassY=true;}
else{Mag1DSPassY=false;} 

//lastly, get the overall boolean that for this magnet

if(Mag1USPassX && Mag1USPassY && Mag1DSPassY){Mag1Pass=true;}
else{Mag1Pass=false;}

std::vector<bool> result;
result.push_back(Mag1USPassX);
result.push_back(Mag1USPassY);
result.push_back(Mag1DSPassY);
result.push_back(Mag1Pass);
return result;
}

std::vector<bool> KeepBeamFilter::CheckDSMagApertures(double hit0[3], double hit1[3])
{
bool Mag2DSPassX, Mag2DSPassY, Mag2USPassY, Mag2Pass;
//Back face checks
//Get slope-intercept form of track
double XZ_slope=(hit1[0]-hit0[0])/(hit1[2]-hit0[2]);
double XZ_intercept= hit0[0]-XZ_slope*hit0[2];

double z_intersect_ds=(XZ_intercept-NDB2_BFace_XZ_intercept)/(NDB2_BFace_XZ_slope-XZ_slope);

//We now have the z coordinate where the track intersects the infinite plane of the DS aperture. Get the 3D intersection point.
double DSBFHit[3];
projToZ(hit0, hit1, DSBFHit, z_intersect_ds);

//And check whether this intersection point is in the finite bounds of the magnet

//DS X Bound check
if(DSBFHit[0]<NDB2_B_top_left[0] && DSBFHit[0]>NDB2_B_top_right[0]) {Mag2DSPassX=true;}
else{Mag2DSPassX=false;}

//US Y Bound Check
if(DSBFHit[1]<NDB2_B_top_left[1] && DSBFHit[1]>NDB2_B_bottom_left[1]) {Mag2DSPassY=true;}
else{Mag2DSPassY=false;}  


//Same process for the US aperture  
double z_intersect_us=(XZ_intercept-NDB2_FFace_XZ_intercept)/(NDB2_FFace_XZ_slope-XZ_slope);
double DSFFHit[3];
projToZ(hit0, hit1, DSFFHit, z_intersect_us); 

//We only check Y here, as there is a bend in X.
if(DSFFHit[1]<NDB2_F_top_left[1] && DSFFHit[1]>NDB2_F_bottom_left[1]) {Mag2USPassY=true;}
else{Mag2USPassY=false;} 

//lastly, get the overall boolean that for this magnet

if(Mag2DSPassX && Mag2DSPassY && Mag2USPassY){Mag2Pass=true;}
else{Mag2Pass=false;}

std::vector<bool> result;
result.push_back(Mag2DSPassX);
result.push_back(Mag2DSPassY);
result.push_back(Mag2USPassY);
result.push_back(Mag2Pass);
return result;
}


std::vector<bool> KeepBeamFilter::CheckDSColApertures(double hit0[3], double hit1[3])
{
bool DSColPassX, DSColPassY, DSColPass;
//Front face checks
//Get slope-intercept form of track
double XZ_slope=(hit1[0]-hit0[0])/(hit1[2]-hit0[2]);
double XZ_intercept= hit0[0]-XZ_slope*hit0[2];

double z_intersect_us=(XZ_intercept-DSCol_FFace_XZ_intercept)/(DSCol_FFace_XZ_slope-XZ_slope);

//We now have the z coordinate where the track intersects the infinite plane of the US aperture. Get the 3D intersection point.
double DSColFFHit[3];
projToZ(hit0, hit1, DSColFFHit, z_intersect_us);

//And check whether this intersection point is in the finite bounds of the DSCol

//US X Bound check
if(DSColFFHit[0]<DSCol_F_top_left[0] && DSColFFHit[0]>DSCol_F_top_right[0]) {DSColPassX=true;}
else{DSColPassX=false;}

//US Y Bound Check
if(DSColFFHit[1]<DSCol_F_top_left[1] && DSColFFHit[1]>DSCol_F_bottom_left[1]) {DSColPassY=true;}
else{DSColPassY=false;}  

if(DSColPassX && DSColPassY){DSColPass=true;}
else{DSColPass=false;}
std::vector<bool> result;
result.push_back(DSColPassX);
result.push_back(DSColPassY);
result.push_back(DSColPass);

return result;
}
DEFINE_ART_MODULE(KeepBeamFilter)


