////////////////////////////////////////////////////////////////////////
// Class:       PIDAFilter
// Module Type: filter
// File:        PIDAFilter_module.cc
//
// Generated at Thu Dec  6 14:39:58 2018 by Greg Pulliam using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#ifndef PIDAFILTER_H
#define PIDAFILTER_H

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include <memory>
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "LArIATDataProducts/WCTrack.h"
#include "art_root_io/TFileService.h"
#include "TH2D.h"
#include "TFile.h"

namespace pida{

class PIDAFilter;

class PIDAFilter : public art::EDFilter {
public:
  explicit PIDAFilter(fhicl::ParameterSet const& pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PIDAFilter(PIDAFilter const &) = delete;
  PIDAFilter(PIDAFilter &&) = delete;
  PIDAFilter & operator = (PIDAFilter const &) = delete;
  PIDAFilter & operator = (PIDAFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;
  void reconfigure(fhicl::ParameterSet const & p);
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const  &fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  std::string fTrackModuleLabel;
  std::string fWCTrackLabel;
  std::string fWC2TPCModuleLabel;
  std::string fParticleIDModuleLabel;
  TH1F *fPIDA;
  double fLowLimit;
  double fHighLimit;
  double TempTrackMatchedID;
};


PIDAFilter::PIDAFilter(fhicl::ParameterSet const& pset)
: EDFilter(pset)
{
  this->reconfigure(pset);
}

bool PIDAFilter::filter(art::Event & e)
{
  std::cout<<fTrackModuleLabel<<std::endl;
  art::Handle< std::vector<recob::Track> > trackListHandle; //<---Define trackListHandle as a vector of recob::Track objects
  std::vector<art::Ptr<recob::Track> > tracklist; //<---Define tracklist as a pointer to recob::tracks
  if (e.getByLabel(fTrackModuleLabel,trackListHandle)){std::cout<<"Filling pointer vector of tracks."<<std::endl; art::fill_ptr_vector(tracklist, trackListHandle);}
  art::Handle< std::vector<ldp::WCTrack> > wctrackHandle;
  std::vector<art::Ptr<ldp::WCTrack> > wctrack;
   
  // === Filling the tracklist from the tracklistHandle ===
  
  if(e.getByLabel(fWCTrackLabel, wctrackHandle))
  {
    art::FindOneP<recob::Track> fWC2TPC(wctrackHandle, e, fWC2TPCModuleLabel);    	
    if (fWC2TPC.isValid())
    {
    // === Loop on all the Assn WC-TPC tracks === 
      for (unsigned int indexAssn = 0; indexAssn < fWC2TPC.size(); ++indexAssn ) 
      {
		// =========================                                                                                       
		// === Get the TPC track ===
		// =========================                                                                      
        cet::maybe_ref<recob::Track const> trackWC2TPC(*fWC2TPC.at(indexAssn));		
	if (!trackWC2TPC) continue;
	recob::Track const& aTrack(trackWC2TPC.ref()); 
	TempTrackMatchedID = aTrack.ID();
	std::cout<<"Found a WC2TPCMatch"<<std::endl;
      }//<----End indexAssn loop                                                                                                                       
    }//<---End checking that the WC2TPC  
  }  
  art::FindManyP<anab::ParticleID>  fmpid(trackListHandle, e, fParticleIDModuleLabel);  
  for(size_t i=0; i<tracklist.size();++i)
  {
    if(tracklist[i]->ID() == TempTrackMatchedID)
    {  
     std::cout<<"Found the matched track, now to check pid"<<std::endl;
      if (fmpid.isValid())
      {
        std::cout<<"Valid fmpid"<<std::endl;
       // ### Putting PID information for this track (i) into pointer vector ###
        std::vector<art::Ptr<anab::ParticleID> > pids = fmpid.at(i);
        for (size_t j = 0; j<pids.size(); ++j)
        {	
	std::cout<<"looping over pids"<<std::endl;
          // ### Skip this PID info if not valid for this plane ###
          if (!pids[j]->PlaneID().isValid) continue;
	  std::cout<<"valid plane id"<<std::endl;
          int pl = pids[j]->PlaneID().Plane;
          // ### Skipping this point if the plane number doesn't make sense ###
          if (pl<0||pl>1) continue;
	  std::cout<<"good plane"<<std::endl;
          //pids[j]->PIDA();
	  fPIDA->Fill(pids[j]->PIDA());
	  if(pids[j]->PIDA()<fLowLimit || pids[j]->PIDA()>fHighLimit){return false;}
	  else if(pids[j]->PIDA()>fLowLimit && pids[j]->PIDA()<fHighLimit){std::cout<<"Keeping this Event with PIDA: "<<pids[j]->PIDA()<<std::endl; return true;}
	  else{return false;}
		
        }//<---End PID loop (j)
	    
      }//<---End checking PID info
    }
  }
  //If we get here, then we never found a good track. Return false.
  return false;  
}
void PIDAFilter::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  fPIDA=tfs->make<TH1F>("CandidatePIDA","CandidatePIDA",200,0,100);
}


void PIDAFilter::endJob()
{
  // Implementation of optional member function here.
}


void PIDAFilter::reconfigure(fhicl::ParameterSet const & p)
{
  fWC2TPCModuleLabel      	= p.get< std::string >("WC2TPCModuleLabel"     , "wctracktpctrackmatch");
  fWCTrackLabel 		= p.get< std::string >("WCTrackLabel", "wctrack");
  fParticleIDModuleLabel  	= p.get< std::string >("ParticleIDModuleLabel","pid");
  fTrackModuleLabel		= p.get< std::string >("TrackModuleLabel","pmtrack");
  fLowLimit		        = p.get< double >("LowerPIDLimit", 0);
  fHighLimit		        = p.get< double >("HigherPIDLimit", 20);
  
}

void PIDAFilter::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void PIDAFilter::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void PIDAFilter::respondToOpenInputFile(art::FileBlock const  &fb)
{
  // Implementation of optional member function here.
}

void PIDAFilter::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(PIDAFilter)
}
#endif
