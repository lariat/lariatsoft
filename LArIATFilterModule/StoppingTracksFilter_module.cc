////////////////////////////////////////////////////////////////////////
// Class:       StoppingTracksFilter
// Module Type: filter
// File:        StoppingTracksFilter_module.cc
//
// Generated at Wed Jan  6 11:59:49 2016 by Elena Gramellini using artmod
// from cetpkgsupport v1_08_06.
// Calorimetry and tagging for stopping tracks added by Irene Nutini on January 2016

// This filter works as follows:
// The filter rejects an event if all the "incoming" 
// tracks are stopping inside the TPC.
// 
// ### Failure mode in view of pion analysis ###
// Say that you have 2 incoming tracks
// Track1 is a stopping particle, Track2 is not.
// This filter would keep this event.
// You later find out that Track1 is the best match to wcTrack.
// You don't want to keep this track for the PionXSAnalysis!
////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////

// ##########################
// ### Framework Includes ###
// ##########################
#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/FindOneP.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Persistency/Common/Ptr.h" 
#include "art/Persistency/Common/PtrVector.h" 
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// ###########################
// ### LArIATsoft Includes ###
// ###########################
#include "Geometry/Geometry.h"
#include "RecoBase/Track.h"
#include "RecoBase/SpacePoint.h"
#include "Utilities/AssociationUtil.h"
#include "AnalysisBase/Calorimetry.h"
#include "AnalysisBase/ParticleID.h"

// ####################
// ### C++ Includes ###
// ####################
#include <iostream>
#include <memory>

// #####################
// ### ROOT includes ###
// #####################
#include <TH1F.h>
#include <TH2F.h>
#include <TGraph.h>
#include <TF1.h>

const int kMaxTrack      = 1000;  //maximum number of tracks

class StoppingTracksFilter;

class StoppingTracksFilter : public art::EDFilter {
public:
  explicit StoppingTracksFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  StoppingTracksFilter(StoppingTracksFilter const &) = delete;
  StoppingTracksFilter(StoppingTracksFilter &&) = delete;
  StoppingTracksFilter & operator = (StoppingTracksFilter const &) = delete;
  StoppingTracksFilter & operator = (StoppingTracksFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  /*
  bool beginRun(art::Run & r) override;
  bool beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  bool endRun(art::Run & r) override;
  bool endSubRun(art::SubRun & sr) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const  &fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;
  */

  bool isStoppingTrack( art::Ptr<recob::Track> aTrack, art::FindManyP<anab::Calorimetry> fmcal );
 // THIS IS CHEATING, WE CAN PASS BETTER THAN THIS
private:

  // Declare member data here.
  std::string fTrackModuleLabel;
  std::string fCalorimetryModuleLabel;
  double fupstreamZPosition;
  
  double fParticleMass;
  
  double fLowLimitStop;
  double fUpLimitStop;
  
  
  // === Storing the tracks Calorimetry Information
  int    trkhits[2];
  double trkke[2];
  double trkdedx[2][1000];
  double trkrr[2][1000];
  double trkpitchhit[2][1000];

  TH1F  *fTotNTrack;
  TH1F  *fStoppingTrack;
  TH1F  *fDifferenceTrack;
  TH1F  *fNTrackPassedCuts;
  
  TH1F *fdEdx;
  TH2F *fdEdxRange;
  TH1F *fFitPar;
};


StoppingTracksFilter::StoppingTracksFilter(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  this->reconfigure(p);
  std::string fTrackModuleLabel;
  std::string fCalorimetryModuleLabel;
  
}

bool StoppingTracksFilter::filter(art::Event & evt)
{
		
  // #####################################
  // ### Getting the Track Information ###
  // #####################################
   
  //####TPC Track####
  art::Handle< std::vector<recob::Track> > trackListHandle; //<---Define trackListHandle as a vector of recob::Track objects
  std::vector<art::Ptr<recob::Track> > tracklist; //<---Define tracklist as a pointer to recob::tracks
  
  // === Filling the tracklist from the tracklistHandle ===
  if (evt.getByLabel(fTrackModuleLabel,trackListHandle)) {
  art::fill_ptr_vector(tracklist, trackListHandle);}
   
  // === Association between SpacePoints and Tracks ===
  art::FindManyP<recob::SpacePoint> fmsp(trackListHandle, evt, fTrackModuleLabel); 
   
 // === Association between Calorimetry objects and Tracks ===
  art::FindManyP<anab::Calorimetry> fmcal(trackListHandle, evt, fCalorimetryModuleLabel);
  
  
  //std::cout<<"========================================="<<std::endl;
   std::cout<<"Run = "<<evt.run()<<", SubRun = "<<evt.subRun()<<", Evt = "<<evt.id().event()<<std::endl;
 // std::cout<<"========================================="<<std::endl;
	
  //======== Setting up my counters ========
  int nPassingZCut = 0;
  int nStopping    = 0;
  
  // ### Looping over tracks ###
  for ( auto const& thisTrack : tracklist )
    { 
      //
      std::cout << "TPC track key " << thisTrack.key() << std::endl;
      
      // ### Setting a temp variable for this track ###
      float tempZpoint = 100;
      
      // ### Grabbing the SpacePoints associated with this track ###
      std::vector<art::Ptr<recob::SpacePoint> > spts = fmsp.at(thisTrack.key());
      
      // ########################################
      // ### Looping over all the SpacePoints ###
      // ########################################
      for (size_t j = 0; j<spts.size(); ++j)
	{
	  // ################################################################################ 
	  // ### Tracking the lowest Z point that is inside fiducial boundries of the TPC ###
	  // ################################################################################
	  if(spts[j]->XYZ()[2] < tempZpoint && spts[j]->XYZ()[2] > 0 &&
	     spts[j]->XYZ()[2] < 90 && spts[j]->XYZ()[0] > 0 && spts[j]->XYZ()[0] < 42.5 &&
	     spts[j]->XYZ()[1] > -20 && spts[j]->XYZ()[1] < 20 )
	    {tempZpoint = spts[j]->XYZ()[2];}
	  
	  // ### Only passing events with a track that has ###
	  // ###  a spacepoint within the first N cm in Z  ### 
	  // ###    And requiring it to be inside the TPC  ###
	  if(tempZpoint < fupstreamZPosition)
	    {      
	      // ###     If the track passes this cut,      ###
	      // ###    add to the passingZCut counter      ###
	      nPassingZCut++;
	      // ###  Check if the track is stopping.       ###
	      // ###  If it is add to the stopping counter  ###
	      if (isStoppingTrack(thisTrack,fmcal)) nStopping++;
	      break; // You don't need to continue looping on the SpacePoints, you already found the track
	    }
		 	  
	}//<---End j loop	
      
    }//<---End i loop
  
  std::cout << "There are " << nStopping    << " stopping tracks for this event" << std::endl;
  std::cout << "There are " << nPassingZCut << " incoming tracks for this event" << std::endl;
  

  // If you want to implement the following logic:
  // "Keep the event if you find 1+ not stopping and incoming track"
  // You need to de-comment the following line and comment out the rest
  //  if (nStopping == nPassingZCut) return false;

  // If you want to implement the following logic:
  // "Reject the event if you find 1+ incoming and stopping track"
  // You need to de-comment the following line and comment out the previous lines
  if (nStopping) return false;

  // ### Otherwise, keep the event ###
  return true;
}

void StoppingTracksFilter::beginJob()
{
  // Declare checks histograms
  art::ServiceHandle<art::TFileService> tfs;

  fTotNTrack        = tfs->make<TH1F>("TotNTrack"        ,"TotNTrack       :Y:X"  ,30,-0.5,29.5);
  fStoppingTrack    = tfs->make<TH1F>("StoppingTrack"    ,"StoppingTrack   :Y:X"  ,30,-0.5,29.5);
  fDifferenceTrack  = tfs->make<TH1F>("DifferenceTrack"  ,"DifferenceTrack :Y:X"  ,30,-0.5,29.5);
  fNTrackPassedCuts = tfs->make<TH1F>("NTrackPassedCuts" ,"NTrackPassedCuts:Y:X"  ,30,-0.5,29.5);
  
  fdEdx = tfs->make<TH1F>("dEdx per each point", "dEdx per each point", 240,-10.,50.);
  fdEdxRange = tfs->make<TH2F>("dEdxVSresRange", "dEdxVSresRange for the tpc track selected", 100,0.,100., 100,0.,20.);
  fFitPar = tfs->make<TH1F>("expParLastHits fit", "expPar from lastHits fit", 100,-10.,10.);
  
}

void StoppingTracksFilter::reconfigure(fhicl::ParameterSet const & p)
{
  fTrackModuleLabel  = p.get< std::string >("TrackModuleLabel" );
  fupstreamZPosition = p.get< double >("upstreamZPosition", 2.0);
  fCalorimetryModuleLabel = p.get< std::string >("CalorimetryModuleLabel", "calo");
  fParticleMass = p.get< double >("ParticleMass", 139.57);//default particle: charged pion
  //Range for the p1 parameter of the fit dEdx vs RR (low RR) to select stopping particles 
  fLowLimitStop = p.get< double >("LowerLimitStoppingTrack", -0.43);
  fUpLimitStop = p.get< double >("UpperLimitStoppingTrack", -0.35);
}

bool StoppingTracksFilter::isStoppingTrack( art::Ptr<recob::Track> aTrack, art::FindManyP<anab::Calorimetry> fmcal )
{
  /**
     In this function we decide if the given track is stopping or not
  */
  bool StoppingTrack = false;
    bool StoppingTrack0 = false;
    bool StoppingTrack1 = false;
  // If the calorimetry is not valid, you consider the particle stopping. 
  // You want the particle out from the interaction pool
  if (!fmcal.isValid()) return true; 
    
  // ########################################################## 
  // ### Looping over Calorimetry information for the track ###
  // ########################################################## 
  
  // ### Putting calo information for this track (i) into pointer vector ###
  std::vector<art::Ptr<anab::Calorimetry> > calos = fmcal.at(aTrack.key());
  
  // ### Looping over each calorimetry point (similar to SpacePoint) ###
  for (size_t j = 0; j<calos.size(); ++j)
    {
      // ### If we don't have calorimetry information for this plane skip ###
      if (!calos[j]->PlaneID().isValid) continue;
      
      // ### Grabbing this calorimetry points plane number (0 == induction, 1 == collection) ###
      int pl = calos[j]->PlaneID().Plane;
      
      // ### Skipping this point if the plane number doesn't make sense ###
      if (pl<0||pl>1) continue;
      
      // ### Recording the number of calorimetry points for this track in this plane ####
      trkhits[pl] = calos[j]->dEdx().size();
      
      // #### Recording the kinetic energy for this track in this plane ###
      trkke[pl] = calos[j]->KineticEnergy();
      
      // ###############################################
      // ### Looping over all the calorimetry points ###
      // ###############################################
      
      //if(pl == 1) std::cout << "Number of calo hits for this track in plane 1 " << calos[j]->dEdx().size() << std::endl;
      
      double lastHitsdEdx[16]={0.};
      double lastHitsRR[16]={0.};
      
      double ordereddEdx[1000]={0.};
      double orderedRR[1000]={0.};
      
      for (size_t k = 0; k<calos[j]->dEdx().size(); ++k)
	{
	  // ### If we go over 1000 points just skip them ###
	  if (k>=1000) continue;
	  
	  // ### Recording the dE/dX information for this calo point along the track in this plane ###
	  trkdedx[pl][k] = calos[j]->dEdx()[k];
	  
	  // ### Recording the residual range for this calo point along the track in this plane ###
	  trkrr[pl][k] = calos[j]->ResidualRange()[k];
	  
	  // ### Recording the pitch of this calo point along the track in this plane ###
	  trkpitchhit[pl][k] = calos[j]->TrkPitchVec()[k];
	  
	  //### Analyzing caloHits ONLY from collection plane - 1
	  
	  if(pl == 1) {
	    
	    size_t dimCalo = 0;
	    dimCalo = calos[j]->dEdx().size();
	    //Fill histos with calo info from collection plane for each track
	    fdEdx->Fill((calos[j]->dEdx()[k]));
	    fdEdxRange->Fill(calos[j]->ResidualRange()[k],(calos[j]->dEdx()[k]));
	    //In case the recorded CaloPoints are not ordered with decreasing RR: 
	    if(k < calos[j]->dEdx().size()-1){
	      if(calos[j]->ResidualRange()[k] > calos[j]->ResidualRange()[k+1]) {
		//If the previous caloHit RR is higher than the next, that's the starting point of the track	
		ordereddEdx[k]= calos[j]->dEdx()[k];
		orderedRR[k]= calos[j]->ResidualRange()[k];
	      }
	      else {
		ordereddEdx[dimCalo-k]= calos[j]->dEdx()[k];
		orderedRR[dimCalo-k]= calos[j]->ResidualRange()[k];	
	      }
	    }
	  }
	}//<---End calo points (k)
      
      if(pl == 1){
	//Actually to study the dEdx vs RR 
	//and to provide a good fit for distinguishing stopping particles, I take in account only tracks longer than around 8 cm
	if(calos[j]->dEdx().size() > 18){
	  size_t hj=0;
	  
	  hj=calos[j]->dEdx().size()-17;
	  int hjj=0;
	  while(hj > calos[j]->dEdx().size()-18 && hj < calos[j]->dEdx().size()-1 ){
	    //lastHits are the one with lower RR
	    lastHitsdEdx[hjj]=ordereddEdx[hj];
	    lastHitsRR[hjj]=orderedRR[hj];
	    hj++;
	    hjj++;
	  }
	  
	  
	} else {std::cout << "Too short track: "<< std::endl; }
      }
      
      int check=0;
      int h=0;
      
      //Doublechecking the lastHits vector has been filled
      while(h < 16){
	if(lastHitsRR[h]==0.) {h++; check++;}
	else h++;
      }
      
      double p1=0.;
      double p0=0.;
      
      if(check != 16){
	TGraph *g1 = new TGraph(16,lastHitsRR,lastHitsdEdx);
	TF1 *fitFcn = new TF1("fitFcn","[0]*pow(x,[1])",0.,10.);
	fitFcn->SetParameter(1,-0.4);
	g1->Fit("fitFcn");
	//In case of "invalid fit" we have to add a control <------
	p1 = fitFcn->GetParameter(1);
    p0 = fitFcn->GetParameter(0);
          //std::cout << "RR Fit Parameters "<< p1 << std::endl;
	fFitPar->Fill(p1);
      } 
      
      if(p1 < fUpLimitStop && p1 > fLowLimitStop) {
	//std::cout << "Possible stopping track "	<< std::endl;
	StoppingTrack0 = true;
      }
        //over param p0 - A
        if(p0 < 20. && p0 > 5.){
            StoppingTrack1= true;
        }
      
	  
    }//<---End looping over calo points (j)
    if(StoppingTrack0==true && StoppingTrack1 == true) {std::cout << "Possible stopping track "	<< std::endl; StoppingTrack = true;}
  
  return StoppingTrack;
}


DEFINE_ART_MODULE(StoppingTracksFilter)

/*
bool StoppingTracksFilter::isEscapingTrack( recob::Track aTrack )
{
 
  return false;
}
*/



