////////////////////////////////////////////////////////////////////////
// Class:       StoppingTracksFilter
// Module Type: filter
// File:        StoppingTracksFilter_module.cc
//
// Generated at Wed Jan  6 11:59:49 2016 by Elena Gramellini using artmod
// from cetpkgsupport v1_08_06.
// The naive version of this filter works as follows:
// the filter rejects an event if all the tracks are stopping inside the TPC
// 
// ### Possible upgrade ###
// The naive version of this filter is quite inclusive:
// Consider the case of a stopping pion decaying into mu nu, 
// the mu could escape (not stopping) and the event would be kept by this filter
// Is this really what we want? We might decide not to consider the muons 
// in the track count.
////////////////////////////////////////////////////////////////////////

// ##########################
// ### Framework Includes ###
// ##########################
#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/FindOneP.h" 
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Persistency/Common/Ptr.h" 
#include "art/Persistency/Common/PtrVector.h" 
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// ###########################
// ### LArIATsoft Includes ###
// ###########################
#include "Geometry/Geometry.h"
#include "RecoBase/Track.h"
#include "RecoBase/SpacePoint.h"
#include "Utilities/AssociationUtil.h"
// ####################
// ### C++ Includes ###
// ####################
#include <iostream>
#include <memory>

// #####################
// ### ROOT includes ###
// #####################
#include <TH1F.h>

class StoppingTracksFilter;

class StoppingTracksFilter : public art::EDFilter {
public:
  explicit StoppingTracksFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  StoppingTracksFilter(StoppingTracksFilter const &) = delete;
  StoppingTracksFilter(StoppingTracksFilter &&) = delete;
  StoppingTracksFilter & operator = (StoppingTracksFilter const &) = delete;
  StoppingTracksFilter & operator = (StoppingTracksFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  /*
  bool beginRun(art::Run & r) override;
  bool beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  bool endRun(art::Run & r) override;
  bool endSubRun(art::SubRun & sr) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const  &fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;
  */
  bool isStoppingTrack( recob::Track aTrack ); // THIS IS CHEATING, WE CAN PASS BETTER THAN THIS
  bool isEscapingTrack( recob::Track aTrack ); // THIS IS CHEATING, WE CAN PASS BETTER THAN THIS

private:

  // Declare member data here.
  std::string fTrackModuleLabel;
  float fupstreamZPosition;

  TH1F  *fTotNTrack;
  TH1F  *fStoppingTrack;
  TH1F  *fDifferenceTrack;
  TH1F  *fNTrackPassedCuts;
};


StoppingTracksFilter::StoppingTracksFilter(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  this->reconfigure(p);
  std::string fTrackModuleLabel;
}

bool StoppingTracksFilter::filter(art::Event & evt)
{
  // #####################################
  // ### Getting the Track Information ###
  // #####################################
  art::Handle< std::vector<recob::Track> > trackListHandle; //<---Define trackListHandle as a vector of recob::Track objects
  std::vector<art::Ptr<recob::Track> > tracklist; //<---Define tracklist as a pointer to recob::tracks
  
  // === Filling the tracklist from the tracklistHandle ===
  if (!evt.getByLabel(fTrackModuleLabel,trackListHandle)) return false;
  art::fill_ptr_vector(tracklist, trackListHandle);
   
  // === Association between SpacePoints and Tracks ===
  art::FindManyP<recob::SpacePoint> fmsp(trackListHandle, evt, fTrackModuleLabel); 
   
  //======== Setting up my counters ========
  int i = -1;
  int nPassingZCut = 0;
  int nStopping    = 0;

  // ### Looping over tracks ###
  for ( auto const& thisTrack : (*trackListHandle) )
    { 
      ++i;
      // ### Setting a temp variable for this track ###
      float tempZpoint = 100;
      
      // ### Grabbing the SpacePoints associated with this track ###
      std::vector<art::Ptr<recob::SpacePoint> > spts = fmsp.at(i);
      
      // ########################################
      // ### Looping over all the SpacePoints ###
      // ########################################
      for (size_t j = 0; j<spts.size(); ++j)
	{
	  // ################################################################################ 
	  // ### Tracking the lowest Z point that is inside fiducial boundries of the TPC ###
	  // ################################################################################
	  if(spts[j]->XYZ()[2] < tempZpoint && spts[j]->XYZ()[2] > 0 &&
	     spts[j]->XYZ()[2] < 90 && spts[j]->XYZ()[0] > 0 && spts[j]->XYZ()[0] < 42.5 &&
	     spts[j]->XYZ()[1] > -20 && spts[j]->XYZ()[1] < 20 )
	    {tempZpoint = spts[j]->XYZ()[2];}
	  
	  // ### Only passing events with a track that has ###
	  // ###  a spacepoint within the first N cm in Z  ### 
	  // ###    And requiring it to be inside the TPC  ###
	  if(tempZpoint < fupstreamZPosition)
	    {      
	      // ###     If the track passes this cut,      ###
	      // ###    add to the passingZCut counter      ###
	      nPassingZCut++;
	      // ###  Check if the track is stopping.       ###
	      // ###  If it is add to the stopping counter  ###
	      if (isStoppingTrack(thisTrack)) nStopping++;
	      break; // You don't need to continue looping on the SpacePoints, you already found the track
	    }
	  
	}//<---End j loop
      
    }//<---End i loop

  //If all the tracks which passed the ZCut are stopping, you thow out the event
  if (nPassingZCut == nStopping) return false;
  //  if (passingZCut < stopping)  throw 20; // I'd like to put an exception here
  // ### Otherwise, keep the event ###
  return true;
}

void StoppingTracksFilter::beginJob()
{
  // Declare checks histograms
  art::ServiceHandle<art::TFileService> tfs;

  fTotNTrack        = tfs->make<TH1F>("TotNTrack"        ,"TotNTrack       :Y:X"  ,30,-0.5,29.5);
  fStoppingTrack    = tfs->make<TH1F>("StoppingTrack"    ,"StoppingTrack   :Y:X"  ,30,-0.5,29.5);
  fDifferenceTrack  = tfs->make<TH1F>("DifferenceTrack"  ,"DifferenceTrack :Y:X"  ,30,-0.5,29.5);
  fNTrackPassedCuts = tfs->make<TH1F>("NTrackPassedCuts" ,"NTrackPassedCuts:Y:X"  ,30,-0.5,29.5);
  
}

void StoppingTracksFilter::reconfigure(fhicl::ParameterSet const & p)
{
  fTrackModuleLabel  = p.get< std::string >("TrackModuleLabel" );
  fupstreamZPosition = p.get< double >("upstreamZPosition", 2.0);
}

bool StoppingTracksFilter::isStoppingTrack( recob::Track aTrack )
{
  /**
     In this function we decide if the given track is stopping or not
  */
  return false;
}


DEFINE_ART_MODULE(StoppingTracksFilter)

/*
bool StoppingTracksFilter::isEscapingTrack( recob::Track aTrack )
{
 
  return false;
}
*/


  /*
  // This is an idea I'm not sure I want to implement.... 
  // Counting the total number of Stopping and thru going tracks
  // ### Counting the number of stopping tracks ###
  // ###             for this event             ###
  unsigned int ntrksStopping = 0;
  unsigned int ntrksEscaping = 0;

  // ### Looping over tracks ###
  for ( auto const& thisTrack : (*trackListHandle) )
    {
      unsigned int S = isStoppingTrack(thisTrack);
      unsigned int E = isEscapingTrack(thisTrack);
      ntrksStopping += S;
      ntrksEscaping += E;
      std::cout<<"S*E "<<S*E<<std::endl;
    }//<---End of the loop on tracks
  
  //  Fill check histograms
  fTotNTrack->Fill(tracklist.size());
  fStoppingTrack->Fill(ntrksStopping);
  fDifferenceTrack->Fill(tracklist.size() - ntrksStopping);

  // ### If all the tracks of the event are stopping return false ###
  if(ntrksStopping                 == tracklist.size()) return false;
  if(ntrksStopping + ntrksEscaping == tracklist.size()) return false;
  */
