///////////////////////////////////////////////////////////////////////
// Class:       WC2TPCMatchExistenceFilter
// Module Type: filter
// File:        WC2TPCMatchExistenceFilter_module.cc
//
// Generated at Fri Oct 26 14:00:48 2018 by Greg Pulliam using artmod
// from cetpkgsupport v1_10_02.
//
//All this filter does is check that a WC2TPC match has been already been found. 
////////////////////////////////////////////////////////////////////////
#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "LArIATDataProducts/WCTrack.h"
#include "canvas/Persistency/Common/FindOneP.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h"
#include "cetlib/maybe_ref.h" 
//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardata/Utilities/AssociationUtil.h"
#include <memory>
#include "art/Framework/Services/Optional/TFileService.h"
#include <TH1.h>
class WC2TPCMatchExistenceFilter;
class WC2TPCMatchExistenceFilter : public art::EDFilter {
public:
  explicit WC2TPCMatchExistenceFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  // Plugins should not be copied or assigned.
  WC2TPCMatchExistenceFilter(WC2TPCMatchExistenceFilter const &) = delete;
  WC2TPCMatchExistenceFilter(WC2TPCMatchExistenceFilter &&) = delete;
  WC2TPCMatchExistenceFilter & operator = (WC2TPCMatchExistenceFilter const &) = delete;
  WC2TPCMatchExistenceFilter & operator = (WC2TPCMatchExistenceFilter &&) = delete;
  // Required functions.
  bool filter(art::Event & e) override;
  void beginJob() override;
private:
  std::string fTrackModuleLabel;
  std::string fWCTrackLabel;
  std::string fWC2TPCModuleLabel;
  TH1F* fWC2TPCPassFail;
};
WC2TPCMatchExistenceFilter::WC2TPCMatchExistenceFilter(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  fWC2TPCModuleLabel = p.get< std::string  >("WC2TPCModuleLabel", "WC2TPCtrk");
  fTrackModuleLabel = p.get< std::string  >("TrackModuleLabel","pmtracktc");
  fWCTrackLabel = p.get< std::string  >("WCTrackLabel","wctrack");
  //bData = p.get<bool>("isData");
}
bool WC2TPCMatchExistenceFilter::filter(art::Event & e)
{
    art::Handle< std::vector<ldp::WCTrack> > wctrackHandle;
    std::vector<art::Ptr<ldp::WCTrack> > wctrack;
    
    if(e.getByLabel(fWCTrackLabel, wctrackHandle))
    {
      art::fill_ptr_vector(wctrack, wctrackHandle);
    }
    art::FindOneP<recob::Track> WCTrackAssn(wctrackHandle,   e, fWC2TPCModuleLabel);
    if(WCTrackAssn.isValid())
    {
      for (unsigned int indexAssn = 0; indexAssn < WCTrackAssn.size(); ++indexAssn ) 
      {
        // =========================                                                                                       
        // === Get the TPC track ===
        // =========================                                                                      
        cet::maybe_ref<recob::Track const> trackWC2TPC(*WCTrackAssn.at(indexAssn));
        if (!trackWC2TPC){ fWC2TPCPassFail->Fill(0); return false;}
        else if (trackWC2TPC)
        { fWC2TPCPassFail->Fill(1);return true;}
        
      }
   }
   fWC2TPCPassFail->Fill(0);
   return false;
}
void WC2TPCMatchExistenceFilter::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  fWC2TPCPassFail=tfs->make<TH1F>("PassFail","PassFail",2,-0.5,1.5);
}
DEFINE_ART_MODULE(WC2TPCMatchExistenceFilter)
