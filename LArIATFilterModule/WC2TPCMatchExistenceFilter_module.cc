///////////////////////////////////////////////////////////////////////
// Class:       WC2TPCMatchExistenceFilter
// Module Type: filter
// File:        WC2TPCMatchExistenceFilter_module.cc
//
// Generated at Fri Oct 26 14:00:48 2018 by Greg Pulliam using artmod
// from cetpkgsupport v1_10_02.
//
//All this filter does is check that a WC2TPC match has been already been found. 
////////////////////////////////////////////////////////////////////////
#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "LArIATDataProducts/WCTrack.h"
#include "canvas/Persistency/Common/FindOneP.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h"
#include "cetlib/maybe_ref.h" 
//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardata/Utilities/AssociationUtil.h"
#include <memory>
#include "art/Framework/Services/Optional/TFileService.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include <TH1.h>
class WC2TPCMatchExistenceFilter;
class WC2TPCMatchExistenceFilter : public art::EDFilter {
public:
  explicit WC2TPCMatchExistenceFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  // Plugins should not be copied or assigned.
  WC2TPCMatchExistenceFilter(WC2TPCMatchExistenceFilter const &) = delete;
  WC2TPCMatchExistenceFilter(WC2TPCMatchExistenceFilter &&) = delete;
  WC2TPCMatchExistenceFilter & operator = (WC2TPCMatchExistenceFilter const &) = delete;
  WC2TPCMatchExistenceFilter & operator = (WC2TPCMatchExistenceFilter &&) = delete;
  // Required functions.
  bool filter(art::Event & e) override;
  void beginJob() override;
private:
  std::string fTrackModuleLabel;
  std::string fWCTrackLabel;
  //std::string fWC2TPCModuleLabel;
  std::string fWCTPCTrkProducerLabel;
  TH1F* hWC2TPCPassFail;
};
WC2TPCMatchExistenceFilter::WC2TPCMatchExistenceFilter(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  fTrackModuleLabel = p.get< std::string  >("TrackModuleLabel","pmtrack");
  fWCTrackLabel = p.get< std::string  >("WCTrackLabel","wctrack");
  
  fWCTPCTrkProducerLabel   = p.get< std::string >("WCTPCTrackMatchLabel", "wctracktpctrackuniquematch");
  //bData = p.get<bool>("isData");
}
bool WC2TPCMatchExistenceFilter::filter(art::Event & e)
{
  art::Handle< std::vector<ldp::WCTrack> > wctrackHandle;
  std::vector<art::Ptr<ldp::WCTrack> > wctrack;
   
  if(e.getByLabel(fWCTrackLabel, wctrackHandle))
    {art::fill_ptr_vector(wctrack, wctrackHandle);}
  art::FindOneP<recob::Track> fopwctpc(wctrackHandle, e, fWCTPCTrkProducerLabel);
  
  bool keepevent=false;
/*   art::Handle< std::vector<recob::Track> > TrackHandle;
  std::vector<art::Ptr<recob::Track> > tpctrack;
  
   if(e.getByLabel(fTrackModuleLabel, TrackHandle))
    {art::fill_ptr_vector(tpctrack, TrackHandle);}
    art::FindOneP<ldp::WCTrack> fopwctpc(TrackHandle, e, fWCTrackLabel);  */
    //std::cout<<wcquality_handle->size()<<std::endl; 
    if(!(fopwctpc.isValid()))
    { hWC2TPCPassFail->Fill(0); return false;}
    else if((fopwctpc.isValid()))
    {
       for (unsigned int iassn=0; iassn<fopwctpc.size(); ++iassn)
       {
         cet::maybe_ref<recob::Track const> trackWC2TPC(*fopwctpc.at(iassn));
	 if(trackWC2TPC){keepevent=true;}
       }
    }
    if(keepevent){hWC2TPCPassFail->Fill(1);}
    else{hWC2TPCPassFail->Fill(0);}
    
    return keepevent;

    
}
void WC2TPCMatchExistenceFilter::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  hWC2TPCPassFail=tfs->make<TH1F>("PassFail","PassFail",2,-0.5,1.5);
}
DEFINE_ART_MODULE(WC2TPCMatchExistenceFilter)
