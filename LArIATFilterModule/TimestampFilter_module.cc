////////////////////////////////////////////////////////////////////////
// Class:       TimestampFilter
// Module Type: filter
// File:        TimestampFilter_module.cc
//
// This filter checks the event timestamp (within spill) and requires
// that it be within some user-defined limit.  Useful way to select beam
// events (1.2 - 5.5 sec).
//
// Option to require event contain non-empty container of TPC wire digits.
//
// Generated at Wed Oct 12 15:23:51 2016 by William Foreman using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

// Framework includes
#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArSoft includes
#include "lardataobj/RawData/OpDetPulse.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/raw.h"
#include "larevt/Filters/ChannelFilter.h"

// ROOT includes
#include <TH1F.h>
#include <TH2F.h>

// C++ includes
#include <iostream>
#include <memory>

class TimestampFilter;

class TimestampFilter : public art::EDFilter {
public:
  explicit TimestampFilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TimestampFilter(TimestampFilter const &) = delete;
  TimestampFilter(TimestampFilter &&) = delete;
  TimestampFilter & operator = (TimestampFilter const &) = delete;
  TimestampFilter & operator = (TimestampFilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  float fT1;
  float fT2;
  bool  fRequireRawDigits;
  std::string fDAQModuleLabel;
  std::string fDAQModuleInstanceName;

  TH1F* hTimestamps;
  TH1F* hTimestamps_pass;
  TH1F* hEvtCount;
  TH1F* hEvtSelection;

};


TimestampFilter::TimestampFilter(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  this->reconfigure(p);
  art::ServiceHandle<art::TFileService> tfs;
  hTimestamps       = tfs->make<TH1F>("Timestamps",";Time in spill [sec]",300,0,60.);
  hTimestamps_pass  = tfs->make<TH1F>("Timestamps_pass",";Time in spill [sec]",300,0.,60.);
  
  hEvtCount         = tfs->make<TH1F>("EvtCount","Counted events",2,0,2);
  hEvtCount         ->SetOption("HIST TEXT");
  hEvtCount         ->GetXaxis()->SetBinLabel(1,"Beam");      
  hEvtCount         ->GetXaxis()->SetBinLabel(2,"Cosmic");         
  
  hEvtSelection     = tfs->make<TH1F>("EvtSelection","",3,0,3);
  hEvtSelection     ->SetOption("HIST TEXT");
  hEvtSelection     ->GetXaxis()->SetBinLabel(1,"Total evts");       
  hEvtSelection     ->GetXaxis()->SetBinLabel(2,"Raw digit check"); 
  hEvtSelection     ->GetXaxis()->SetBinLabel(3,"Timestamp cut");  
}

bool TimestampFilter::filter(art::Event & e)
{
  // Set flags
  bool timestampFlag  = true;
  bool rawDigitFlag   = true;
  
  // set timestamp
  float timeStamp     = -9.;

  // ------------------------------------------------------------------------
  // First do timestamp filtering (this only applies to real data)
  if( e.isRealData() ) {
    
    //std::cout<<"TimestampFilter: run "<<e.run()<<", subrun "<<e.subRun()<<", event "<<e.id().event()<<"\n";
    // Get the timestamp (within the spill cycle) from the opdetpulse
    // objects because I don't know where else this info is saved!
    art::Handle< std::vector< raw::OpDetPulse >> opdetHandle;
    e.getByLabel(fDAQModuleLabel, fDAQModuleInstanceName, opdetHandle);
    
    if( (size_t)opdetHandle->size() > 0 ){
      // All we want is the timestamp so just grab the first opdetpulse
      // we can find and call it a day
      art::Ptr< raw::OpDetPulse > ThePulsePtr(opdetHandle,0); 
      raw::OpDetPulse pulse = *ThePulsePtr;
      timeStamp = ((float)pulse.PMTFrame()*8.)/1.0e09;
      //std::cout<<"Timestamp = "<<timeStamp<<" sec\n";
    }
  
    if( timeStamp < fT1 || timeStamp > fT2 ) timestampFlag = false;
 
  }
    
  // ----------------------------------------------------------------------
  // Check that raw digits exist
  art::Handle< std::vector<raw::RawDigit> > DigitHandle;;
  std::vector<art::Ptr<raw::RawDigit> > digit;
  if(e.getByLabel("daq",DigitHandle))
    {art::fill_ptr_vector(digit, DigitHandle);} 
  if( fRequireRawDigits && digit.size() == 0 ) rawDigitFlag = false;
 
  bool passFlag = false;
  hEvtSelection->Fill(0);

  if( rawDigitFlag ) {
    hEvtSelection->Fill(1);
    
    // count up event types
    if( timeStamp >= 1.1 && timeStamp <= 5.2 )  hEvtCount->Fill(0);
    else if (timeStamp > 5.2 )                  hEvtCount->Fill(1);
    
    // fill timestamp histogram
    hTimestamps->Fill(timeStamp);

    if( timestampFlag ) {
      hEvtSelection->Fill(2);
      passFlag = true;
      hTimestamps_pass->Fill(timeStamp);
    }
  }
  
  return passFlag;

}

void TimestampFilter::beginJob()
{
}


void TimestampFilter::endJob()
{
  std::cout
  <<"====================================\n"
  <<"=====     TimestampFilter   ========\n\n"
  <<"Beam events  : "<<hEvtCount->GetBinContent(1)<<"\n"
  <<"Cosmic events: "<<hEvtCount->GetBinContent(2)<<"\n\n"
  <<"====================================\n";
}


void TimestampFilter::reconfigure(fhicl::ParameterSet const & p)
{
  fT1				= p.get< float  >("T1",0);
  fT2				= p.get< float  >("T2",60);
  fDAQModuleLabel               = p.get< std::string >  ("DAQModule","daq");
  fDAQModuleInstanceName        = p.get< std::string >  ("DAQInstanceName","");
  fRequireRawDigits             = p.get< bool >         ("RequireRawDigits",true);
}


DEFINE_ART_MODULE(TimestampFilter)
