////////////////////////////////////////////////////////////////////////
// Class:       ParticleIdentification
// Module Type: producer
// File:        ParticleIdentification_module.cc
//
// Generated at Tue Jul 21 10:59:53 2015 by Ryan Linehan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

//Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Services/Optional/TFileService.h"

//Lariatsoft includes
#include "LArIATDataProducts/WCTrack.h"
#include "LArIATDataProducts/TOF.h"
#include "RawDataUtilities/TriggerDigitUtility.h"

//C++ includes
#include <vector>
#include <memory>
#include <iostream>

//ROOT includes
#include <TH2F.h>
#include <TH1F.h>


class ParticleIdentification;

class ParticleIdentification : public art::EDProducer {
public:
  explicit ParticleIdentification(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ParticleIdentification(ParticleIdentification const &) = delete;
  ParticleIdentification(ParticleIdentification &&) = delete;
  ParticleIdentification & operator = (ParticleIdentification const &) = delete;
  ParticleIdentification & operator = (ParticleIdentification &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.
  std::string       fWCTrackModuleLabel;
  std::string       fTOFModuleLabel;
  bool              fVerbose;
  bool              fPlotHistograms;

  TH2F*             fPzVsTOF;
  TH1F*             fNTOF;
  TH1F*             fPz;
  TH1F*             fTOF;
  
};


ParticleIdentification::ParticleIdentification(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  this->reconfigure(p);

  
}

void ParticleIdentification::produce(art::Event & e)
{
  // Implementation of required member function here.
  


  //Get the collection of WCTracks produced by the WCTrackBuilder module
  art::Handle< std::vector<ldp::WCTrack> > WCTrackColHandle;
  e.getByLabel(fWCTrackModuleLabel,WCTrackColHandle);
  
  //Get the collection of TOF objects produced by the TOF module
  art::Handle< std::vector<ldp::TOF> > TOFColHandle;
  e.getByLabel(fTOFModuleLabel,TOFColHandle);

  std::cout << "Produce has commenced." << std::endl;

  if( fVerbose ){
    std::cout << "NumTracks in the event: " << WCTrackColHandle->size() << std::endl;
    std::cout << "NumTOF Objects in the event: " << TOFColHandle->size() << std::endl;
    std::cout << "NumTOFs for first event TOF objct: " << TOFColHandle->at(0).NTOF() << std::endl;
  }



  //Quick-and-dirty method for matching TOF and WCTracks: good WCTracks only have one track per trigger.
  //I think (?) that only one TOF comes out of the TimeOfFlight module, but just in case that's not true, we'll require
  //that only one TOF can correspond to one trigger
 
  //Temporary solution - need to address cases where there is more than 1 TOF per event
  if((WCTrackColHandle->size() == 1 && TOFColHandle->at(0).NTOF() == 1)){
    if( fPlotHistograms ){
      fPzVsTOF->Fill(WCTrackColHandle->at(0).Momentum(),TOFColHandle->at(0).SingleTOF(0));
      fPz->Fill(WCTrackColHandle->at(0).Momentum());
      fTOF->Fill(TOFColHandle->at(0).SingleTOF(0));
    }
  }

  
}

void ParticleIdentification::beginJob()
{
  // Implementation of optional member function here.
  if( fPlotHistograms ){
    art::ServiceHandle<art::TFileService> tfs;
    fPzVsTOF = tfs->make<TH2F>("PzVsTOF","Pz vs. Time of Flight",40,0,1600,40,20,80);
    fNTOF = tfs->make<TH1F>("NTOF","Number of TOF values per TOF object",10,0,10);
    fPz = tfs->make<TH1F>("Reco_Pz","Reconstructed momentum",180,0,1800);
    fTOF = tfs->make<TH1F>("Reco_TOF","Reconstructed Time of Flight",70,20,90);
    
  }
}

void ParticleIdentification::beginRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::beginSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::endJob()
{
  // Implementation of optional member function here.
}

void ParticleIdentification::endRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::endSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  fWCTrackModuleLabel           =p.get< std::string >("WCTrackModuleLabel");
  fTOFModuleLabel               =p.get< std::string >("TOFModuleLabel");
  fVerbose                      =p.get< bool >("Verbose");
  fPlotHistograms               =p.get< bool >("PlotHistograms");
}

void ParticleIdentification::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(ParticleIdentification)
