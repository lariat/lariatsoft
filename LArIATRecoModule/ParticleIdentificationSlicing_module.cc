////////////////////////////////////////////////////////////////////////
// Class:       ParticleIdentificationSlicing
// Module Type: producer
// File:        ParticleIdentificationSlicing_module.cc
//
// Generated at Tue Jul 21 10:59:53 2015 by Ryan Linehan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

//Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Services/Optional/TFileService.h"

//Lariatsoft includes
#include "LArIATDataProducts/WCTrack.h"
#include "LArIATDataProducts/TOF.h"
#include "LArIATDataProducts/MuonRangeStackHits.h"
#include "LArIATDataProducts/AGCounter.h"
#include "LArIATDataProducts/AuxDetParticleID.h"
#include "RawDataUtilities/TriggerDigitUtility.h"
#include "larcore/Geometry/Geometry.h"

//C++ includes
#include <vector>
#include <memory>
#include <iostream>

//ROOT includes
#include <TH2F.h>
#include <TH1F.h>
#include <TF1.h>

//LArIAT Includes
#include "Utilities/DatabaseUtilityT1034.h"

class ParticleIdentificationSlicing;

class ParticleIdentificationSlicing : public art::EDProducer {
public:
  explicit ParticleIdentificationSlicing(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ParticleIdentificationSlicing(ParticleIdentificationSlicing const &) = delete;
  ParticleIdentificationSlicing(ParticleIdentificationSlicing &&) = delete;
  ParticleIdentificationSlicing & operator = (ParticleIdentificationSlicing const &) = delete;
  ParticleIdentificationSlicing & operator = (ParticleIdentificationSlicing &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

  void doThePiMu_Proton_KaonSeparation( float reco_momentum,
					float reco_TOF,
					std::vector<float> & proton_kaon_pimu_likelihood_ratios );

  bool isThereAGoodMuRSTrack( art::Handle< std::vector<ldp::MuonRangeStackHits> > & MuRSColHandle,
			      int & thePenetrationDepth );

  void doTheMuRSPionMuonSeparation( float thePenetrationDepth,
				    float reco_momentum,
				    float & pion_muon_likelihood_ratio );

  void fillCharacterizationHistos( art::Handle< std::vector<ldp::WCTrack> > WCTrackColHandle,
				   art::Handle< std::vector<ldp::TOF> > TOFColHandle,
				   art::Handle< std::vector<ldp::MuonRangeStackHits> > MuRSColHandle );

  void plotTheGoodTracksAndTOFInfo( art::Handle< std::vector<ldp::WCTrack> > WCTrackColHandle,
				    art::Handle< std::vector<ldp::TOF> > TOFColHandle,
				    art::Handle< std::vector<ldp::MuonRangeStackHits> > MuRSColHandle );


  void setPriors( float momentum );
  void pullAllPPriorsFromTable();
  void pullSpecificPPriorsFromTable( float momentum );
  std::string parseMCPriorString( std::string theString );
  int generatePDGCode( std::vector<float> proton_kaon_pimu_likelihood_ratios,
		       float pion_muon_likelihood_ratio,
		       bool foundGoodMuRSTrack );

  void fillPIDHistos( int finalPDGCode,
		      float momentum,
		      float TOF );


  void queryDataBaseForMagnetAndEnergy();
  void makeMCPriorMap();

  /*
  void getActivePriors( std::string runSetting );
  void getActivePriorsDefault();
  */

private:

  //Run parameters and constants
  float fDistanceTraveled;           //Path length of particle, in meters
  float fSpeedOfLight;                
  float fMagnetSetting;
  float fEnergySetting;
  float fPolaritySetting;
  int   fRun;
  int   fSubRun;
  float fPathLength;
  int   fTriggerWindowFirstTick;
  int   fTriggerWindowLastTick;

  //Database Utility for getting run/subrun beam setting info
  art::ServiceHandle<util::DatabaseUtilityT1034> fDatabaseUtility;
  
  //Geometry serviece handle
  art::ServiceHandle<geo::Geometry> fGeo;

  //Priors storage
  float fMuonPrior;
  float fPionPrior;
  float fKaonPrior;
  float fProtonPrior;
  
  // Declare member data here.
  std::string       fWCTrackModuleLabel;
  std::string       fTOFModuleLabel;
  std::string       fMuRSModuleLabel;
  bool              fVerbose;
  bool              fGenerateFitsForMassDistribution;

  

  //Histogramming and distribution generation
  //parameters and hists
  TH2F*             fPzVsTOF;
  TH2F*             fPzVsTOFGood;
  TH1F*             fNTOF;
  TH1F*             fPz;
  TH1F*             fY_Kink;
  TH1F*             fX_Dist;
  TH1F*             fY_Dist;
  TH1F*             fZ_Dist;
  TH1F*             fX_Face_Dist;
  TH1F*             fY_Face_Dist;
  TH1F*             fTheta_Dist;
  TH1F*             fPhi_Dist;
  TH1F*             fTOF;
  TH1F*             fParticleMass;
  TH1F*             fTOFType;
  TH1F*             fMagnetSettingHist;
  TH1F*             fPolaritySettingHist;
  TH1F*             fEnergySettingHist;
  TH1F*             fBDiffHist;
  TH1F*             fEDiffHist;

  TH1F*             fTotalNTOFHist;
  TH1F*             fNTOFHist;
  TH1F*             fNWCTrackHist;
  TH1F*             fNMuRSHitsObjectHist;
  TH1F*             fNMuRSTrackHist;

  TH2F*             fPzVsTOFProtons;
  TH2F*             fPzVsTOFKaons;
  TH2F*             fPzVsTOFPiMu;
  TH2F*             fPzVsTOFPions;
  TH2F*             fPzVsTOFMuons;
  TH1F*             fPDGCodes;

  TH1F*             fMuRSTracks;

  TH1F*             fPiMuProb;
  TH1F*             fKaonProb;
  TH1F*             fProtonProb;

  std::vector<size_t>  fKaonRun;
  std::vector<size_t>  fKaonSubRun;
  std::vector<size_t>  fKaonEvent;
  int                  fGoodMuRSCounter;

  //Gaussian parameters for mass fits
  float             fPiMuMassMean;
  float             fPiMuMassSigma;
  float             fKaonMassMean;
  float             fKaonMassSigma;
  float             fProtonMassMean;
  float             fProtonMassSigma;

  //Misc Parameters
  float fMaxMomentumForPID;  //MeV/c
  float fPiMuLRThreshold;



  /////////////////////////////////////////////////////////////////
  //            BEAMSIM MONTE CARLO STORAGE VARIABLES            //
  /////////////////////////////////////////////////////////////////

  //Vectors with beamsim MC priors
  std::vector<float> fBeamProbE_08_pos350;
  std::vector<float> fBeamProbMu_08_pos350;
  std::vector<float> fBeamProbPi_08_pos350;
  std::vector<float> fBeamProbK_08_pos350;
  std::vector<float> fBeamProbProt_08_pos350;
  std::vector<float> fBeamProbAll_08_pos350;
 
  std::vector<float> fBeamProbE_08_pos175;
  std::vector<float> fBeamProbMu_08_pos175;
  std::vector<float> fBeamProbPi_08_pos175;
  std::vector<float> fBeamProbK_08_pos175;
  std::vector<float> fBeamProbProt_08_pos175;
  std::vector<float> fBeamProbAll_08_pos175;
  
  std::vector<float> fBeamProbE_08_neg175;
  std::vector<float> fBeamProbMu_08_neg175;
  std::vector<float> fBeamProbPi_08_neg175;
  std::vector<float> fBeamProbK_08_neg175;
  std::vector<float> fBeamProbProt_08_neg175;
  std::vector<float> fBeamProbAll_08_neg175;
  
  std::vector<float> fBeamProbE_08_neg350;
  std::vector<float> fBeamProbMu_08_neg350;
  std::vector<float> fBeamProbPi_08_neg350;
  std::vector<float> fBeamProbK_08_neg350;
  std::vector<float> fBeamProbProt_08_neg350;
  std::vector<float> fBeamProbAll_08_neg350;  

  std::vector<float> fBeamProbE_32_pos350;
  std::vector<float> fBeamProbMu_32_pos350;
  std::vector<float> fBeamProbPi_32_pos350;
  std::vector<float> fBeamProbK_32_pos350;
  std::vector<float> fBeamProbProt_32_pos350;
  std::vector<float> fBeamProbAll_32_pos350;
 
  std::vector<float> fBeamProbE_32_pos175;
  std::vector<float> fBeamProbMu_32_pos175;
  std::vector<float> fBeamProbPi_32_pos175;
  std::vector<float> fBeamProbK_32_pos175;
  std::vector<float> fBeamProbProt_32_pos175;
  std::vector<float> fBeamProbAll_32_pos175;  

  std::vector<float> fBeamProbE_32_neg175;
  std::vector<float> fBeamProbMu_32_neg175;
  std::vector<float> fBeamProbPi_32_neg175;
  std::vector<float> fBeamProbK_32_neg175;
  std::vector<float> fBeamProbProt_32_neg175;
  std::vector<float> fBeamProbAll_32_neg175;

  //Intermediate stage that allows for parsing of the vector
  //name to find the particle type.
  std::map< std::string, std::vector<float> > fMCPriorMap;

  //Final scalars denoting the probability of having each of these
  //particle types in the beam at the specified P, beam E, B, and polarity
  float              fCorrectPPiMCPrior;
  float              fCorrectPMuMCPrior;
  float              fCorrectPKMCPrior;
  float              fCorrectPProtMCPrior;
  float              fCorrectPEMCPrior;

  float              fAllPPiMCPrior;
  float              fAllPMuMCPrior;
  float              fAllPKMCPrior;
  float              fAllPProtMCPrior;
  float              fAllPEMCPrior;
  

  /////////////////////////////////////////////////////////////////
  //            MURS MONTE CARLO STORAGE VARIABLES               //
  /////////////////////////////////////////////////////////////////
  
  //Vectors with the MuRS MC priors (note: for ALL momentum ranges)
  //(so there are really many vectors smashed within this vector)
  std::vector<float> fPiPlusPenetrationDepth;
  std::vector<float> fPiMinusPenetrationDepth;
  std::vector<float> fMuPlusPenetrationDepth;
  std::vector<float> fMuMinusPenetrationDepth;
  std::vector<float> fKPlusPenetrationDepth;
  std::vector<float> fKMinusPenetrationDepth;
  std::vector<float> fEPenetrationDepth;
  std::vector<float> fProtPenetrationDepth;

  //Vectors with the MuRS MC priors (only one momentum range)
  std::vector<float> fCorrectPPiPenetrationDepth;
  std::vector<float> fCorrectPMuPenetrationDepth;
  std::vector<float> fCorrectPKPenetrationDepth;
  std::vector<float> fCorrectPProtPenetrationDepth;
  std::vector<float> fCorrectPEPenetrationDepth;

  
};


ParticleIdentificationSlicing::ParticleIdentificationSlicing(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  this->reconfigure(p);

  produces<std::vector<ldp::AuxDetParticleID> >();
  
}

void ParticleIdentificationSlicing::produce(art::Event & e)
{
  //Caution
  if( fPolaritySetting == 0 ){
    LOG_VERBATIM("ParticleIdentificationSlicing") << "Polarity is zero. Skipping this event.";
    return;
  }

  //Collection of particle id objects
  std::unique_ptr<std::vector<ldp::AuxDetParticleID> > AuxDetParticleIDCol(new std::vector<ldp::AuxDetParticleID>  );

  //Get the collection of WCTracks produced by the WCTrackBuilder module
  art::Handle< std::vector<ldp::WCTrack> > WCTrackColHandle;
  e.getByLabel(fWCTrackModuleLabel,WCTrackColHandle);
  
  //Get the collection of TOF objects produced by the TOF module
  art::Handle< std::vector<ldp::TOF> > TOFColHandle;
  e.getByLabel(fTOFModuleLabel,TOFColHandle);

  //Get the collection of MuonRangeStackHits objects produced by the MuonRangeStackHitsBuilder module
  art::Handle< std::vector<ldp::MuonRangeStackHits> > MuRSColHandle;
  e.getByLabel(fMuRSModuleLabel,MuRSColHandle);

  //Characterization of these objects
  fillCharacterizationHistos( WCTrackColHandle,
			      TOFColHandle,
			      MuRSColHandle );

  //we want to know the Pz vs. TOF, so make sure that there is only one TOF object with one TOF within. Find the TOF
  if( TOFColHandle->size() != 1 ) {e.put(std::move(AuxDetParticleIDCol)); return;}
  if( TOFColHandle->at(0).NTOF() != 1 ) {e.put(std::move(AuxDetParticleIDCol)); return;}
  float reco_TOF = TOFColHandle->at(0).SingleTOF(0);

  //Assume that there is only one good WCTrack. Identify the WCTrack's momentum.
  if( WCTrackColHandle->size() != 1 ) {e.put(std::move(AuxDetParticleIDCol)); return;}
  float reco_momentum = WCTrackColHandle->at(0).Momentum();
  setPriors( reco_momentum );

  //Fill the Pz vs. TOF histo before making the momentum cut
  fPzVsTOF->Fill(reco_momentum,reco_TOF);

  //Make a cut to reduce ambiguity in particle species based on mass distributions
  if(reco_momentum > fMaxMomentumForPID ){ e.put(std::move(AuxDetParticleIDCol)); return; }

  //Plot essential information about the incoming data products that passed the
  //cuts. Also, plot THE MASS!!!!
  plotTheGoodTracksAndTOFInfo( WCTrackColHandle,
			       TOFColHandle,
			       MuRSColHandle );

  
  
  //Tag possible kaon (for by-eye scans - not to be used in module)
  if((WCTrackColHandle->at(0).Momentum() < 950 && WCTrackColHandle->at(0).Momentum() > 500 ) &&
     (TOFColHandle->at(0).SingleTOF(0) < 42 && TOFColHandle->at(0).SingleTOF(0) > 37) ){
    fKaonRun.push_back(size_t(e.run()));
    fKaonSubRun.push_back(size_t(e.subRun()));
    fKaonEvent.push_back(size_t(e.event()));
  }
  
  

  ///////////////// PARTICLE ID Pz vs. TOF/////////////////////////////
  //We take the calculated mass of the particle and find the value of 3
  //p.d.f.s at that mass. Each p.d.f. is a gaussian with the parameters
  //defined in the class definition above, and represents a particle
  //flavor (pi/mu, kaon, proton). Each of these probabilities is equal
  //to the likelihood of the associated particle being the correct one
  //given the mass. We normalize these three probabilities and store them
  //for future use.

  //Indices after filling:
  //0: proton likelihood ratio (probability of proton/(probability of anything))
  //1: kaon likelihood ratio
  //2: pimu likelihood ratio
  //Note that the size might still be zero after the
  //following function if cuts aren't passed. Careful!
  std::vector<float> proton_kaon_pimu_likelihood_ratios;
  float pion_muon_likelihood_ratio;
  doThePiMu_Proton_KaonSeparation( reco_momentum,
				   reco_TOF,
				   proton_kaon_pimu_likelihood_ratios );
  ///////////////// PARTICLE ID ENDING Pz vs. TOF /////////////////////

  
  //Now we check to see if the pimu likelihood ratio is above some 
  //parametrized threshold. If it is, run pi/mu separation on it.
  bool foundGoodMuRSTrack = false;
  ldp::MuonRangeStackHits theMuRS = MuRSColHandle->at(0);
  if( fVerbose ) LOG_VERBATIM("ParticleIdentificationSlicing") << "PiMu likelihood: " << proton_kaon_pimu_likelihood_ratios.at(2);
  if( proton_kaon_pimu_likelihood_ratios.at(2) > fPiMuLRThreshold && theMuRS.WasItInitializedEmpty() == false ){
    
    ///////////////// PARTICLE ID Pion Vs. Muon /////////////////////////
    // We start with the assumption that there is only one good WCTrack,
    // the one that triggered the event. The trigger waveform times for
    // the wire chambers will therefore have hits at around time tick
    // 136. We then cut on track time, saying that the MuRS track must be
    // found within a reasonable distance of tick 136. This very roughly
    // matches the WCTrack to the MuRS track.
    //

    //One way to improve this PID is to look at incoming times of WCTracks and MuRSTracks and match them,
    //rather than relying on the above assumption.
    
    if( fVerbose )LOG_VERBATIM("ParticleIdentificationSlicing") << "PiMu probability above threshold.";
    
    
    MuRSTrack theGoodMuRSTrack;
    int thePenetrationDepth = 9989;
    bool goodMuRS = isThereAGoodMuRSTrack( MuRSColHandle, thePenetrationDepth );
    foundGoodMuRSTrack = goodMuRS;
    if( goodMuRS ){
      fGoodMuRSCounter++;
      doTheMuRSPionMuonSeparation( thePenetrationDepth, 
				   reco_momentum,
				   pion_muon_likelihood_ratio );
    }
    
  }
  

  //Generate the PDG code corresponding to the most likely particle
  int finalPDGCode = generatePDGCode( proton_kaon_pimu_likelihood_ratios,
				      pion_muon_likelihood_ratio,
				      foundGoodMuRSTrack);

  //Plot stuff about particle ID
  fillPIDHistos( finalPDGCode, reco_momentum, reco_TOF );

  //Build probabilities for pions and muons based on pion_muon_likelihood_ratio
  float pion_prob = pion_muon_likelihood_ratio/(pion_muon_likelihood_ratio+1);
  float muon_prob = 1/(pion_muon_likelihood_ratio+1);

  //Histos for checking proton/pimu/kaon probabilitites
  fPiMuProb->Fill(proton_kaon_pimu_likelihood_ratios.at(2));
  fKaonProb->Fill(proton_kaon_pimu_likelihood_ratios.at(1));
  fProtonProb->Fill(proton_kaon_pimu_likelihood_ratios.at(0));

  //Now fill in the AuxDetParticle with the likelihoods  
  ldp::AuxDetParticleID thePID( proton_kaon_pimu_likelihood_ratios.at(0),
				proton_kaon_pimu_likelihood_ratios.at(1),
				proton_kaon_pimu_likelihood_ratios.at(2),
				proton_kaon_pimu_likelihood_ratios.at(2)*pion_prob,
				proton_kaon_pimu_likelihood_ratios.at(2)*muon_prob,
				finalPDGCode );
  (*AuxDetParticleIDCol).push_back(thePID);
  e.put(std::move(AuxDetParticleIDCol));
						     			       
}


//============================================================================================
void ParticleIdentificationSlicing::fillCharacterizationHistos( art::Handle< std::vector<ldp::WCTrack> > WCTrackColHandle,
								art::Handle< std::vector<ldp::TOF> > TOFColHandle,
								art::Handle< std::vector<ldp::MuonRangeStackHits> > MuRSColHandle )
{
  //Basic object filling
  fNTOFHist->Fill(TOFColHandle->size());
  fNWCTrackHist->Fill(WCTrackColHandle->size());
  fNMuRSHitsObjectHist->Fill(MuRSColHandle->size());

  //Total TOF filling
  for( size_t iTOFObj = 0; iTOFObj < TOFColHandle->size(); ++iTOFObj ){
    fTotalNTOFHist->Fill(TOFColHandle->at(iTOFObj).NTOF());
  }

  //MuRSTrack filling
  for( size_t iMuRSObj = 0; iMuRSObj < MuRSColHandle->size(); ++iMuRSObj ){
    ldp::MuonRangeStackHits theMuRS = MuRSColHandle->at(iMuRSObj);
    fNMuRSTrackHist->Fill(float(theMuRS.NTracks()));
  }

}

//============================================================================================
void ParticleIdentificationSlicing::plotTheGoodTracksAndTOFInfo( art::Handle< std::vector<ldp::WCTrack> > WCTrackColHandle,
								 art::Handle< std::vector<ldp::TOF> > TOFColHandle,
								 art::Handle< std::vector<ldp::MuonRangeStackHits> > MuRSColHandle )
{
  fPzVsTOFGood->Fill(WCTrackColHandle->at(0).Momentum(),TOFColHandle->at(0).SingleTOF(0));
  fPz->Fill(WCTrackColHandle->at(0).Momentum());
  fTOF->Fill(TOFColHandle->at(0).SingleTOF(0));
  fY_Kink->Fill(WCTrackColHandle->at(0).YKink());
  fX_Dist->Fill(WCTrackColHandle->at(0).DeltaDist(0));
  fY_Dist->Fill(WCTrackColHandle->at(0).DeltaDist(1));
  fZ_Dist->Fill(WCTrackColHandle->at(0).DeltaDist(2));
  fX_Face_Dist->Fill(WCTrackColHandle->at(0).XYFace(0));
  fY_Face_Dist->Fill(WCTrackColHandle->at(0).XYFace(1));
  fTheta_Dist->Fill(WCTrackColHandle->at(0).Theta());
  fPhi_Dist->Fill(WCTrackColHandle->at(0).Phi());
        
  float mass = pow(pow((fSpeedOfLight*(TOFColHandle->at(0).SingleTOF(0))*1e-9/fDistanceTraveled)*WCTrackColHandle->at(0).Momentum(),2)-pow(WCTrackColHandle->at(0).Momentum(),2),0.5);
  fParticleMass->Fill(mass);
  LOG_VERBATIM("ParticleIdentificationSlicing") << "mass: " << mass;


  ldp::MuonRangeStackHits murs = MuRSColHandle->at(0);
  for( size_t iTrack = 0; iTrack < murs.NTracks(); ++iTrack ){
    fMuRSTracks->Fill(murs.GetArrivalTime(iTrack));
  }

  
		    

}


//============================================================================================
//Setting prior information on the likelihood
//of different particle ID hypotheses
void ParticleIdentificationSlicing::setPriors(float momentum)
{
  //Clear stuff
  fCorrectPPiPenetrationDepth.clear();
  fCorrectPMuPenetrationDepth.clear();
  fCorrectPKPenetrationDepth.clear();
  fCorrectPProtPenetrationDepth.clear();
  fCorrectPEPenetrationDepth.clear();

  fCorrectPPiMCPrior = 0;
  fCorrectPMuMCPrior = 0;
  fCorrectPKMCPrior = 0;
  fCorrectPProtMCPrior = 0;
  fCorrectPEMCPrior = 0;

  fAllPPiMCPrior = 0;
  fAllPMuMCPrior = 0;
  fAllPKMCPrior = 0;
  fAllPProtMCPrior = 0;
  fAllPEMCPrior = 0;



  //Two prior types: all momentum:
  pullAllPPriorsFromTable();
  
  //And specific momentum range
  //We have a magnet and energy setting. Use these with momentum to identify:
  //1. Which priors histogram file's associated vector to use (based on B field and Energy )
  //2. Which momentum range to draw our priors from
  //Now dig through the prior table (which is at the moment unfinished) using the momentum,
  //magnet settings, and energy settings
  pullSpecificPPriorsFromTable( momentum );
}


//============================================================================================
//Extracts all-momentum priors about beamline populations
void ParticleIdentificationSlicing::pullAllPPriorsFromTable()
{
  std::map< std::string, std::vector<float> >::iterator iter;
  for( iter = fMCPriorMap.begin(); iter != fMCPriorMap.end(); ++iter ){
    std::string particle = parseMCPriorString( iter->first );
    if( particle == "All" ){
      //Look for the right momentum
      std::vector<float> particleTypeProbs = iter->second;
      fAllPEMCPrior = particleTypeProbs.at(0);
      fAllPMuMCPrior = particleTypeProbs.at(1);
      fAllPPiMCPrior = particleTypeProbs.at(2);
      fAllPKMCPrior = particleTypeProbs.at(3);
      fAllPProtMCPrior = particleTypeProbs.at(4);
    }
  }
}

						       
//============================================================================================
//Extracts the p-specific prior information about beamline populations and MuRS penetration depth from vectors built from MC simulation
void ParticleIdentificationSlicing::pullSpecificPPriorsFromTable( float momentum )
{
  //Hard coded qualities about the MuRS and  MC information (shouldn't be parameters because
  //parameters are too tempting to tweak without understanding that you must tweak and
  //rerun the beamsim and MuRS MCs along with parameter tweaks)
  size_t entriesPerMomentum = 10; 
  float firstMomentum = 500; //MeV/c
  float pWindowWidth = 25; //MeV/c
  size_t numPWindows = 20; 
  int counter = 0;
  
  //Loop through the mc prior map and identify which beam setting vector to use
  std::map< std::string, std::vector<float> >::iterator iter;
  LOG_VERBATIM("ParticleIdentificationSlicing") << "Momentum: " << momentum << " MeV/c ";
  for( iter = fMCPriorMap.begin(); iter != fMCPriorMap.end(); ++iter ){
    std::string particle = parseMCPriorString( iter->first );
    if( particle == "Pi" ){
      //Look for the right momentum
      std::vector<float> probabilityInPRange = iter->second;
      for( size_t iP = 0; iP < numPWindows; ++iP ){
	if( momentum >= iP*pWindowWidth+firstMomentum && momentum < (iP+1)*pWindowWidth+firstMomentum ){
	  fCorrectPPiMCPrior = probabilityInPRange.at(iP);
	}
      }
    }
    if( particle == "Mu" ){
      //Look for the right momentum
      std::vector<float> probabilityInPRange = iter->second;
      for( size_t iP = 0; iP < numPWindows; ++iP ){
	if( momentum >= iP*pWindowWidth+firstMomentum && momentum < (iP+1)*pWindowWidth+firstMomentum ){
	  fCorrectPMuMCPrior = probabilityInPRange.at(iP);
	}
      }
    }
    if( particle == "K" ){
      //Look for the right momentum
      std::vector<float> probabilityInPRange = iter->second;
      for( size_t iP = 0; iP < numPWindows; ++iP ){
	if( momentum >= iP*pWindowWidth+firstMomentum && momentum < (iP+1)*pWindowWidth+firstMomentum ){
	  fCorrectPKMCPrior = probabilityInPRange.at(iP);
	}
      }
    }
    if( particle == "Prot" ){
      //Look for the right momentum
      std::vector<float> probabilityInPRange = iter->second;
      for( size_t iP = 0; iP < numPWindows; ++iP ){
	if( momentum >= iP*pWindowWidth+firstMomentum && momentum < (iP+1)*pWindowWidth+firstMomentum ){
	  fCorrectPProtMCPrior = probabilityInPRange.at(iP);
	}
      }
    }
    if( particle == "E" ){
      //Look for the right momentum
      std::vector<float> probabilityInPRange = iter->second;
      for( size_t iP = 0; iP < numPWindows; ++iP ){
	if( momentum >= iP*pWindowWidth+firstMomentum && momentum < (iP+1)*pWindowWidth+firstMomentum ){
	  fCorrectPEMCPrior = probabilityInPRange.at(iP);
	}
      }
    }


  }
  //Now we should have two scalar priors denoting the probabilitity of seeing 
  //a muon or a pion in the beam. These won't add to 1, but 
  
  //Sanity check
  if( fVerbose ){
    LOG_VERBATIM("ParticleIdentificationSlicing") << "After setting, Correct-Momentum MC priors are: \n" << 
      "Pion: " << fCorrectPPiMCPrior << "\n" <<
      "Muon: " << fCorrectPMuMCPrior << "\n" << 
      "Kaon: " << fCorrectPKMCPrior << "\n" << 
      "Proton: " << fCorrectPProtMCPrior << "\n" << 
      "Electron: " << fCorrectPEMCPrior; 
  }


  //Pull the pion and muon penetration depth 
  //The struture of the pion and muon penetration depth tables is such:
  //Vector1 = first 10 entries, all for momentum range 0:
  //Entry1: # particles incident on TPC in energy range 0
  //Entry2: # particles surviving to MuRS in energy range 0
  //Entry3: Probability of a particle stopping after the first slab
  //Entry4: Probability of a particle stopping after the second slab
  //...
  //Entry10: Probability of a particle stopping after the 8th slab
  //Vector2 = entries 11-20, all for momentum range 1:
  //...repeat.

  //First loop through momentum range
  for( size_t iP = 0; iP < numPWindows; ++iP ){
    if( momentum >= iP*pWindowWidth+firstMomentum && momentum < (iP+1)*pWindowWidth+firstMomentum ){
      counter++;
      for( size_t iEntry = 0; iEntry < entriesPerMomentum ; ++iEntry ){
	if( fPolaritySetting == 1 ){
	  fCorrectPMuPenetrationDepth.push_back(fMuPlusPenetrationDepth.at(iP*entriesPerMomentum+iEntry));
	  fCorrectPPiPenetrationDepth.push_back(fPiPlusPenetrationDepth.at(iP*entriesPerMomentum+iEntry));
	  fCorrectPKPenetrationDepth.push_back(fKPlusPenetrationDepth.at(iP*entriesPerMomentum+iEntry));
	  fCorrectPProtPenetrationDepth.push_back(fProtPenetrationDepth.at(iP*entriesPerMomentum+iEntry));
	}
	else if( fPolaritySetting == -1 ){
	  fCorrectPEPenetrationDepth.push_back(fEPenetrationDepth.at(iP*entriesPerMomentum+iEntry));
	  fCorrectPMuPenetrationDepth.push_back(fMuMinusPenetrationDepth.at(iP*entriesPerMomentum+iEntry));
	  fCorrectPPiPenetrationDepth.push_back(fPiMinusPenetrationDepth.at(iP*entriesPerMomentum+iEntry));
	  fCorrectPKPenetrationDepth.push_back(fKMinusPenetrationDepth.at(iP*entriesPerMomentum+iEntry));
	} 
	else{ LOG_VERBATIM("ParticleIdentificationSlicing") << "MAGNET SETTING IS NOT POSITIVE OR NEGATIVE. ABORT."; }
      }
    }
  }
  //Now we have a set of four vectors of the applicable particles for that magnet polarity, each only
  //containing information about the specified momentum range


    
}


//============================================================================================
//Parsing the strings in the MCPrior maps to figure out which particles, energies, and beam 
//settings that they represent.
std::string ParticleIdentificationSlicing::parseMCPriorString( std::string theString )
{
  std::string tempStr;
  std::vector<std::string> tempStringVect;
  for( size_t iChar = 0; iChar < theString.size(); ++iChar ){
    if( theString.at(iChar) == '_' ){
      tempStringVect.push_back(tempStr);
      tempStr.clear();
    }
    else{ tempStr.push_back(theString.at(iChar)); }
    if( iChar == theString.size()-1 ){
      tempStringVect.push_back(tempStr);
      tempStr.clear();
    }
  }

  //Sanity check
  //  if( fVerbose ){
  if(0){
    LOG_VERBATIM("ParticleIdentificationSlicing") << "In parseMCPriorString, we find " << tempStringVect.size() << " strings. These are: ";
    for( size_t iString = 0; iString < tempStringVect.size(); ++iString ){
      LOG_VERBATIM("ParticleIdentificationSlicing") << "String " << iString << ": " << tempStringVect.at(iString);
    }
    LOG_VERBATIM("ParticleIdentificationSlicing") << "Testing stoi capabilities for strings (1,2): (" << stoi(tempStringVect.at(1)) << "," << stoi(tempStringVect.at(3)) << ")";
  }

  if( stoi(tempStringVect.at(1)) == fEnergySetting &&
      stoi(tempStringVect.at(3)) == fMagnetSetting*1000*0.0035 ){ //have to compensate for current-bfield conversion and parser, which doesn't have periods
    if( (fPolaritySetting == 1 && tempStringVect.at(2) == "+") ||
	(fPolaritySetting == -1 && tempStringVect.at(2) == "-")){
      return tempStringVect.at(0);
    }
  }
  
  //  LOG_VERBATIM("ParticleIdentificationSlicing") << "Something not matched. Returning abort string.";
  return "abort";
  
}


//============================================================================================  
void ParticleIdentificationSlicing::doThePiMu_Proton_KaonSeparation( float reco_momentum,
								     float reco_TOF,
								     std::vector<float> & proton_kaon_pimu_likelihood_ratios )
{
  //Finding the mass
  float mass = pow(pow((fSpeedOfLight*(reco_TOF)*1e-9/fDistanceTraveled)*reco_momentum,2)-pow(reco_momentum,2),0.5);

  //Sanity check
  if( fVerbose ){
    LOG_VERBATIM("ParticleIdentificationSlicing")
    << "Integrated Proton Prior: " << fAllPProtMCPrior
    << "Integrated Kaon Prior: " << fAllPKMCPrior
    << "Integrated Pi Prior: " << fAllPPiMCPrior
    << "Integrated Mu Prior: " << fAllPMuMCPrior;
  }
    
  
  //Finding values of pdf for mass given proton, kaon, pi/mu distributions
  float proton_prob = fAllPProtMCPrior*(1/pow(2*3.1415926,0.5)/fProtonMassSigma)*exp(-0.5*pow((mass-fProtonMassMean)/fProtonMassSigma,2));
  float kaon_prob = fAllPKMCPrior*(1/pow(2*3.1415926,0.5)/fKaonMassSigma)*exp(-0.5*pow((mass-fKaonMassMean)/fKaonMassSigma,2));
  float pimu_prob = (fAllPMuMCPrior+fAllPPiMCPrior)*(1/pow(2*3.1415926,0.5)/fPiMuMassSigma)*exp(-0.5*pow((mass-fPiMuMassMean)/fPiMuMassSigma,2));
  
  //These ^ are likelihoods, so find the likelihood ratio of each to the total
  float proton_likelihood = proton_prob/(proton_prob+kaon_prob+pimu_prob);
  float kaon_likelihood = kaon_prob/(proton_prob+kaon_prob+pimu_prob);
  float pimu_likelihood = pimu_prob/(proton_prob+kaon_prob+pimu_prob);

  //Account for resolution of TOF system: make these cases default to pimu
  if(pow((fSpeedOfLight*(reco_TOF)*1e-9/fDistanceTraveled)*reco_momentum,2)-pow(reco_momentum,2) < 0 ){
    pimu_likelihood = 1.0;
    proton_likelihood = 0;
    kaon_likelihood = 0;
  }

  //Account for terrible kaon peak fitting (initial stages only)
  if( mass > fProtonMassMean && kaon_likelihood > proton_likelihood && kaon_likelihood > pimu_likelihood ){
    pimu_likelihood = 0;
    proton_likelihood = 0;
    kaon_likelihood = 0;
  }
  
  proton_kaon_pimu_likelihood_ratios.push_back(proton_likelihood);
  proton_kaon_pimu_likelihood_ratios.push_back(kaon_likelihood);
  proton_kaon_pimu_likelihood_ratios.push_back(pimu_likelihood);
 
 
}


//============================================================================================
//Finding whether there is a MuRSTrack at the appropriate time
bool ParticleIdentificationSlicing::isThereAGoodMuRSTrack(art::Handle< std::vector<ldp::MuonRangeStackHits> > & MuRSColHandle,
                                                          int & thePenetrationDepth)
{
  //Loop through the MuRS objects
  int counter = 0;
  for (size_t iMuRS = 0; iMuRS < MuRSColHandle->size(); ++iMuRS) {
    ldp::MuonRangeStackHits theMuRS = MuRSColHandle->at(iMuRS);
    for (size_t iTrack = 0; iTrack < theMuRS.NTracks(); ++iTrack) {
      float theTrackTime = theMuRS.GetArrivalTime(iTrack);
      if (theTrackTime >= fTriggerWindowFirstTick && theTrackTime <= fTriggerWindowLastTick) {
        thePenetrationDepth = theMuRS.GetPenetrationDepth(iTrack);
        counter++;
      }
    }

  }

  if (counter == 1) {
    LOG_VERBATIM("ParticleIdentificationSlicing") << "There was a good MuRS track.";
    return true;
  }
  else if (counter == 0) return false;
  else {
    LOG_VERBATIM("ParticleIdentificationSlicing") << "I'm not sure what to do here. There were 2+ good murs tracks. Returning true.";
    return true;
  }
}


//============================================================================================m
//Finding the likelihood ratio of pions and muons
void ParticleIdentificationSlicing::doTheMuRSPionMuonSeparation( float thePenetrationDepth,
								 float reco_momentum,
								 float & pion_muon_likelihood_ratio )
{
  if( fVerbose )
    LOG_VERBATIM("ParticleIdentificationSlicing") << "Doing the pion muon separation.";

  //Calculate the final likelihood ratio for pions/muons for positive polarity
  if( fPolaritySetting == 1 ){
    float P_depth_given_pi = fCorrectPPiPenetrationDepth.at( thePenetrationDepth+2 ); //Always +2 because first 2 entries are header with other info
    float P_depth_given_mu = fCorrectPMuPenetrationDepth.at( thePenetrationDepth+2 );
    float P_depth_given_k = fCorrectPKPenetrationDepth.at( thePenetrationDepth+2 );
    float P_depth_given_prot = fCorrectPProtPenetrationDepth.at( thePenetrationDepth+2 );
    
    float P_murs_given_pi = fCorrectPPiPenetrationDepth.at( thePenetrationDepth+1 )/fCorrectPPiPenetrationDepth.at( thePenetrationDepth );
    float P_murs_given_mu = fCorrectPMuPenetrationDepth.at( thePenetrationDepth+1 )/fCorrectPMuPenetrationDepth.at( thePenetrationDepth );
    float P_murs_given_k = fCorrectPKPenetrationDepth.at( thePenetrationDepth+1 )/fCorrectPKPenetrationDepth.at( thePenetrationDepth );
    float P_murs_given_prot = fCorrectPProtPenetrationDepth.at( thePenetrationDepth+1 )/fCorrectPProtPenetrationDepth.at( thePenetrationDepth );
 
    float P_pi_given_murs = (fCorrectPPiMCPrior*P_murs_given_pi)/(fCorrectPPiMCPrior*P_murs_given_pi +
								    fCorrectPMuMCPrior*P_murs_given_mu +
								    fCorrectPKMCPrior*P_murs_given_k +
								    fCorrectPProtMCPrior*P_murs_given_prot );
    float P_mu_given_murs = (fCorrectPMuMCPrior*P_murs_given_mu)/(fCorrectPPiMCPrior*P_murs_given_pi +
								    fCorrectPMuMCPrior*P_murs_given_mu +
								    fCorrectPKMCPrior*P_murs_given_k +
								    fCorrectPProtMCPrior*P_murs_given_prot );
    float P_k_given_murs = (fCorrectPKMCPrior*P_murs_given_k)/(fCorrectPPiMCPrior*P_murs_given_pi +
								  fCorrectPMuMCPrior*P_murs_given_mu +
								  fCorrectPKMCPrior*P_murs_given_k +
								  fCorrectPProtMCPrior*P_murs_given_prot );
    float P_prot_given_murs = (fCorrectPProtMCPrior*P_murs_given_prot)/(fCorrectPPiMCPrior*P_murs_given_pi +
									  fCorrectPMuMCPrior*P_murs_given_mu +
									  fCorrectPKMCPrior*P_murs_given_k +
									  fCorrectPProtMCPrior*P_murs_given_prot );
    

    
    float P_pi_given_depth = P_depth_given_pi*P_pi_given_murs/(P_depth_given_pi*P_pi_given_murs +
							       P_depth_given_mu*P_mu_given_murs +
							       P_depth_given_k*P_k_given_murs +
							       P_depth_given_prot*P_prot_given_murs );
    float P_mu_given_depth = P_depth_given_mu*P_mu_given_murs/(P_depth_given_pi*P_pi_given_murs +
							       P_depth_given_mu*P_mu_given_murs +
							       P_depth_given_k*P_k_given_murs +
							       P_depth_given_prot*P_prot_given_murs );
    /*
    float P_k_given_depth = P_depth_given_k*P_k_given_murs/(P_depth_given_pi*P_pi_given_murs +
							    P_depth_given_mu*P_mu_given_murs +
							    P_depth_given_k*P_k_given_murs +
							    P_depth_given_prot*P_prot_given_murs );
    float P_prot_given_depth = P_depth_given_prot*P_prot_given_murs/(P_depth_given_pi*P_pi_given_murs +
								     P_depth_given_mu*P_mu_given_murs +
								     P_depth_given_k*P_k_given_murs +
								     P_depth_given_prot*P_prot_given_murs );
							       */    

    if( fVerbose ) LOG_VERBATIM("ParticleIdentificationSlicing") << "Pi/mu ratio: " << pion_muon_likelihood_ratio;
    
    pion_muon_likelihood_ratio = P_pi_given_depth/P_mu_given_depth;

  }

  //Calculate the final likelihood ratio for pions/muons for negative polarity
  else if( fPolaritySetting == -1 ){
    float P_depth_given_pi = fCorrectPPiPenetrationDepth.at( thePenetrationDepth+2 ); //Always +2 because first 2 entries are header with other info
    float P_depth_given_mu = fCorrectPMuPenetrationDepth.at( thePenetrationDepth+2 );
    float P_depth_given_k = fCorrectPKPenetrationDepth.at( thePenetrationDepth+2 );
    float P_depth_given_E = fCorrectPEPenetrationDepth.at( thePenetrationDepth+2 );
    
    float P_murs_given_pi = fCorrectPPiPenetrationDepth.at( thePenetrationDepth+1 )/fCorrectPPiPenetrationDepth.at( thePenetrationDepth );
    float P_murs_given_mu = fCorrectPMuPenetrationDepth.at( thePenetrationDepth+1 )/fCorrectPMuPenetrationDepth.at( thePenetrationDepth );
    float P_murs_given_k = fCorrectPKPenetrationDepth.at( thePenetrationDepth+1 )/fCorrectPKPenetrationDepth.at( thePenetrationDepth );
    float P_murs_given_E = fCorrectPEPenetrationDepth.at( thePenetrationDepth+1 )/fCorrectPEPenetrationDepth.at( thePenetrationDepth );
 
    float P_pi_given_murs = (fCorrectPPiMCPrior*P_murs_given_pi)/(fCorrectPPiMCPrior*P_murs_given_pi +
								    fCorrectPMuMCPrior*P_murs_given_mu +
								    fCorrectPKMCPrior*P_murs_given_k +
								    fCorrectPEMCPrior*P_murs_given_E );
    float P_mu_given_murs = (fCorrectPMuMCPrior*P_murs_given_mu)/(fCorrectPPiMCPrior*P_murs_given_pi +
								    fCorrectPMuMCPrior*P_murs_given_mu +
								    fCorrectPKMCPrior*P_murs_given_k +
								    fCorrectPEMCPrior*P_murs_given_E );
    float P_k_given_murs = (fCorrectPKMCPrior*P_murs_given_k)/(fCorrectPPiMCPrior*P_murs_given_pi +
								  fCorrectPMuMCPrior*P_murs_given_mu +
								  fCorrectPKMCPrior*P_murs_given_k +
								  fCorrectPEMCPrior*P_murs_given_E );
    float P_E_given_murs = (fCorrectPEMCPrior*P_murs_given_E)/(fCorrectPPiMCPrior*P_murs_given_pi +
									  fCorrectPMuMCPrior*P_murs_given_mu +
									  fCorrectPKMCPrior*P_murs_given_k +
									  fCorrectPEMCPrior*P_murs_given_E );
    

    
    float P_pi_given_depth = P_depth_given_pi*P_pi_given_murs/(P_depth_given_pi*P_pi_given_murs +
							       P_depth_given_mu*P_mu_given_murs +
							       P_depth_given_k*P_k_given_murs +
							       P_depth_given_E*P_E_given_murs );
    float P_mu_given_depth = P_depth_given_mu*P_mu_given_murs/(P_depth_given_pi*P_pi_given_murs +
							       P_depth_given_mu*P_mu_given_murs +
							       P_depth_given_k*P_k_given_murs +
							       P_depth_given_E*P_E_given_murs );
    /*
    float P_k_given_depth = P_depth_given_k*P_k_given_murs/(P_depth_given_pi*P_pi_given_murs +
							    P_depth_given_mu*P_mu_given_murs +
							    P_depth_given_k*P_k_given_murs +
							    P_depth_given_E*P_E_given_murs );
    float P_E_given_depth = P_depth_given_E*P_E_given_murs/(P_depth_given_pi*P_pi_given_murs +
								     P_depth_given_mu*P_mu_given_murs +
								     P_depth_given_k*P_k_given_murs +
								     P_depth_given_E*P_E_given_murs );
    */    

    pion_muon_likelihood_ratio = P_pi_given_depth/P_mu_given_depth;

  }

  else{ LOG_VERBATIM("ParticleIdentificationSlicing") << "Polarity is zero. Aborting."; }

  /*
  float P_depth_given_pion = getProbabilityOfDepthGivenPionAtPunchThrough( reco_momentum, thePenetrationDepth );
  float P_pion = getProbabilityOfPionAtPunchThrough( reco_momentum );
  float P_depth_given_muon = getProbabilityOfDepthGivenMuonAtPunchThrough( reco_momentum, thePenetrationDepth );
  float P_muon = getProbabilityOfMuonAtPunchThrough( reco_momentum );
  
  float P_pion_given_depth = (P_depth_given_pion*P_pion)/(P_depth_given_pion*P_pion+P_depth_given_muon*P_muon);
  float P_muon_given_depth = (P_depth_given_muon*P_muon)/(P_depth_given_pion*P_pion+P_depth_given_muon*P_muon);
  
  pion_muon_likelihood_ratios.push_back(P_pion_given_depth,P_muon_given_depth);*/
}

//============================================================================================
int ParticleIdentificationSlicing::generatePDGCode( std::vector<float> proton_kaon_pimu_likelihood_ratios,
						    float pion_muon_likelihood_ratio,
						    bool foundGoodMuRSTrack )
{
  float p_prob = proton_kaon_pimu_likelihood_ratios.at(0);
  float k_prob = proton_kaon_pimu_likelihood_ratios.at(1);
  float pimu_prob = proton_kaon_pimu_likelihood_ratios.at(2);
  float pi_g_pimu_prob = pion_muon_likelihood_ratio/(pion_muon_likelihood_ratio+1);
  float mu_g_pimu_prob = 1/(pion_muon_likelihood_ratio+1);

  LOG_VERBATIM("ParticleIdentificationSlicing") << "pi_g_pimu_prob: " << pi_g_pimu_prob << ", mu_g_pimu_prob: " << mu_g_pimu_prob;
  

  int pdgCode = 0; //Zero is unsuccessful decision of PDG code

  //Setting the particle ID
  if( p_prob > k_prob && p_prob > pimu_prob ){
    if( fPolaritySetting == 1 ) pdgCode = 2212;
    else if( fPolaritySetting == -1 ) pdgCode = -2212;
    else{ pdgCode = 0; }
  }
  else if( k_prob > p_prob && k_prob > pimu_prob ){
    if( fPolaritySetting == 1 ) pdgCode = 321;
    else if( fPolaritySetting == -1 ) pdgCode = -321;
    else{ pdgCode = 0; }
  }
  else if( pimu_prob > p_prob && pimu_prob > k_prob ){
    //Taking care of a bad default case when there is no MuRSTrack
    if( !foundGoodMuRSTrack ) return 21113; //21113 is for Pi: 211, Mu: 13, so this is PiMu.
    else if( fPolaritySetting == 1 ){
      if( pi_g_pimu_prob > mu_g_pimu_prob ) pdgCode = 211;
      else if( pi_g_pimu_prob < mu_g_pimu_prob )pdgCode = -13;
      else{ LOG_VERBATIM("ParticleIdentificationSlicing") << "It seems as if no murs was run. The muon and pion probs are equal."; }
    }
    else if( fPolaritySetting == -1 ){
      if( pi_g_pimu_prob > mu_g_pimu_prob ) pdgCode = -211;
      else if( pi_g_pimu_prob < mu_g_pimu_prob )pdgCode = 13;
      else{ LOG_VERBATIM("ParticleIdentificationSlicing") << "It seems as if no murs was run. The muon and pion probs are equal."; }

    }
    else{ pdgCode = 0; }
  }
  
  return pdgCode;

}

//============================================================================================
void ParticleIdentificationSlicing::fillPIDHistos( int finalPDGCode,
						   float momentum,
						   float TOF )
						   
						   
{
  LOG_VERBATIM("ParticleIdentificationSlicing") << "TOF: " << TOF << ", P: " << momentum;

  if( finalPDGCode == 2212 || finalPDGCode == -2212 ){
    fPzVsTOFProtons->Fill(momentum,TOF);
  }
  if( finalPDGCode == 321 || finalPDGCode == -321 ){
    fPzVsTOFKaons->Fill(momentum,TOF);
  }
  if( finalPDGCode == 21113 ){
    fPzVsTOFPiMu->Fill(momentum,TOF);
  } 
  if( finalPDGCode == 211 || finalPDGCode == -211 ){
    fPzVsTOFPions->Fill(momentum,TOF);
  }
  if( finalPDGCode == 13 || finalPDGCode == -13 ){
    fPzVsTOFMuons->Fill(momentum,TOF);
  }

  fPDGCodes->Fill(finalPDGCode);
 
}

//============================================================================================
//Gets the settings and rounds them to the nearest discrete setting that we use
//(example: 99.7 Amps would round to 100 A)
void ParticleIdentificationSlicing::queryDataBaseForMagnetAndEnergy()
{
  fMagnetSetting = std::stod(fDatabaseUtility->GetIFBeamValue("mid_f_mc7an",fRun,fSubRun));
  fEnergySetting = std::stod(fDatabaseUtility->GetIFBeamValue("mid_f_mcenrg",fRun,fSubRun));
  if( fMagnetSetting > 0 ) fPolaritySetting = 1;
  else if( fMagnetSetting < 0 ) fPolaritySetting = -1;
  else fPolaritySetting = 0;

  //Sanity check
  if( fVerbose ){
    LOG_VERBATIM("ParticleIdentificationSlicing")
    << "Magnet Setting: " << fMagnetSetting
    << "Magnet Polarity: " << fPolaritySetting
    << "Energy Setting: " << fEnergySetting;
  }

  //Known settings
  int magSettingSize = 5;
  int energySettingSize = 4;
  //  float I2B = 0.0035;
  float magSettings[magSettingSize] = {40,50,60,80,100};
  float energySettings[energySettingSize] = {8,16,32,64};
  
  
  //Loop through and find the closest discrete/known settings
  float theTrueMagSetting = 9996;
  float theLowestDifference = 9995;
  float theBDiff = 0;
  for( int iMag = 0; iMag < magSettingSize; ++iMag ){
    if( fabs(magSettings[iMag] - fabs(fMagnetSetting)) < theLowestDifference ){
      theLowestDifference = fabs(magSettings[iMag]-fabs(fMagnetSetting));
      theTrueMagSetting = magSettings[iMag];
      theBDiff = fabs(theTrueMagSetting - fabs(fMagnetSetting) );
    }
  }
  float theTrueEnergySetting = 9994;
  theLowestDifference = 9994;
  float theEDiff = 0;
  for( int iEn = 0; iEn < energySettingSize; ++iEn ){
    if( fabs(energySettings[iEn] - fabs(fEnergySetting)) < theLowestDifference ){
      theLowestDifference = fabs(energySettings[iEn]-fabs(fEnergySetting));
      theTrueEnergySetting = energySettings[iEn];
      theEDiff = fabs(theTrueEnergySetting - fabs(fEnergySetting));
    }
  }
  
  //Sanity check
  if( fVerbose ){
    LOG_VERBATIM("ParticleIdentificationSlicing")
    << "Magnet Setting: " << fMagnetSetting << ", Closest accepted: " << theTrueMagSetting
    << "Magnet Polarity: " << fPolaritySetting
    << "Energy Setting: " << fEnergySetting << ", Closest accepted: " << theTrueEnergySetting;
  }

  //More Sanity checks
  fMagnetSettingHist->Fill(fMagnetSetting);
  fPolaritySettingHist->Fill(fPolaritySetting);
  fEnergySettingHist->Fill(fEnergySetting);
  fBDiffHist->Fill(theBDiff);
  fEDiffHist->Fill(theEDiff);

  //Assign these true/known values 
  fMagnetSetting = theTrueMagSetting;
  fEnergySetting = theTrueEnergySetting;

}

//============================================================================================  
void ParticleIdentificationSlicing::makeMCPriorMap()
{
  fMCPriorMap.emplace("E_8_+_350",fBeamProbE_08_pos350);
  fMCPriorMap.emplace("Mu_8_+_350",fBeamProbMu_08_pos350);
  fMCPriorMap.emplace("Pi_8_+_350",fBeamProbPi_08_pos350);
  fMCPriorMap.emplace("K_8_+_350",fBeamProbK_08_pos350);
  fMCPriorMap.emplace("Prot_8_+_350",fBeamProbProt_08_pos350);
  fMCPriorMap.emplace("All_8_+_350",fBeamProbAll_08_pos350);
 
  fMCPriorMap.emplace("E_8_+_175",fBeamProbE_08_pos175);
  fMCPriorMap.emplace("Mu_8_+_175",fBeamProbMu_08_pos175);
  fMCPriorMap.emplace("Pi_8_+_175",fBeamProbPi_08_pos175);
  fMCPriorMap.emplace("K_8_+_175",fBeamProbK_08_pos175);
  fMCPriorMap.emplace("Prot_8_+_175",fBeamProbProt_08_pos175);
  fMCPriorMap.emplace("All_8_+_175",fBeamProbAll_08_pos175);
  
  fMCPriorMap.emplace("E_8_-_175",fBeamProbE_08_neg175);
  fMCPriorMap.emplace("Mu_8_-_175",fBeamProbMu_08_neg175);
  fMCPriorMap.emplace("Pi_8_-_175",fBeamProbPi_08_neg175);
  fMCPriorMap.emplace("K_8_-_175",fBeamProbK_08_neg175);
  fMCPriorMap.emplace("Prot_8_-_175",fBeamProbProt_08_neg175);
  fMCPriorMap.emplace("All_8_-_175",fBeamProbAll_08_neg175);

  fMCPriorMap.emplace("E_8_-_350",fBeamProbE_08_neg350);
  fMCPriorMap.emplace("Mu_8_-_350",fBeamProbMu_08_neg350);
  fMCPriorMap.emplace("Pi_8_-_350",fBeamProbPi_08_neg350);
  fMCPriorMap.emplace("K_8_-_350",fBeamProbK_08_neg350);
  fMCPriorMap.emplace("Prot_8_-_350",fBeamProbProt_08_neg350);
  fMCPriorMap.emplace("All_8_-_350",fBeamProbAll_08_neg350);

  fMCPriorMap.emplace("E_32_+_350",fBeamProbE_32_pos350);
  fMCPriorMap.emplace("Mu_32_+_350",fBeamProbMu_32_pos350);
  fMCPriorMap.emplace("Pi_32_+_350",fBeamProbPi_32_pos350);
  fMCPriorMap.emplace("K_32_+_350",fBeamProbK_32_pos350);
  fMCPriorMap.emplace("Prot_32_+_350",fBeamProbProt_32_pos350);
  fMCPriorMap.emplace("All_32_+_350",fBeamProbAll_32_pos350);

  fMCPriorMap.emplace("E_32_+_175",fBeamProbE_32_pos175);
  fMCPriorMap.emplace("Mu_32_+_175",fBeamProbMu_32_pos175);
  fMCPriorMap.emplace("Pi_32_+_175",fBeamProbPi_32_pos175);
  fMCPriorMap.emplace("K_32_+_175",fBeamProbK_32_pos175);
  fMCPriorMap.emplace("Prot_32_+_175",fBeamProbProt_32_pos175);
  fMCPriorMap.emplace("All_32_+_175",fBeamProbAll_32_pos175);

  fMCPriorMap.emplace("E_32_-_175",fBeamProbE_32_neg175);
  fMCPriorMap.emplace("Mu_32_-_175",fBeamProbMu_32_neg175);
  fMCPriorMap.emplace("Pi_32_-_175",fBeamProbPi_32_neg175);
  fMCPriorMap.emplace("K_32_-_175",fBeamProbK_32_neg175);
  fMCPriorMap.emplace("Prot_32_-_175",fBeamProbProt_32_neg175);
  fMCPriorMap.emplace("All_32_-_175",fBeamProbAll_32_neg175);
}

//============================================================================================  
void ParticleIdentificationSlicing::beginJob()
{
  // Implementation of optional member function here.
  art::ServiceHandle<art::TFileService> tfs;
  fPzVsTOF = tfs->make<TH2F>("PzVsTOF","Pz vs. Time of Flight",160,0,1600,70,10,80);
  fPzVsTOFGood = tfs->make<TH2F>("PzVsTOFGood","Pz vs. Time of Flight for used events",160,0,1600,70,10,80);
  fNTOF = tfs->make<TH1F>("NTOF","Number of TOF values per TOF object",10,0,10);
  fPz = tfs->make<TH1F>("Reco_Pz","Reconstructed momentum",180,0,1800);
  fTOF = tfs->make<TH1F>("Reco_TOF","Reconstructed Time of Flight",70,20,90);
  fY_Kink = tfs->make<TH1F>("Y_Kink","Angle between US/DS tracks in Y direction (degrees)",100,-5*3.1415926/180,5*3.141592654/180);
  fX_Dist = tfs->make<TH1F>("X_Dist","X distance between US/DS tracks at midplane (mm)",120,-60,60);
  fY_Dist = tfs->make<TH1F>("Y_Dist","Y distance between US/DS tracks at midplane (mm)",120,-60,60);
  fZ_Dist = tfs->make<TH1F>("Z_Dist","Z distance between US/DS tracks at midplane (mm)",120,-60,60);
  fX_Face_Dist = tfs->make<TH1F>("X_Face","X Location of Track's TPC Entry (mm)",800,-200,600);
  fY_Face_Dist = tfs->make<TH1F>("Y_Face","Y Location of Track's TPC Entry (mm)",800,-400,400);
  fTheta_Dist = tfs->make<TH1F>("Theta","Track Theta (w.r.t. TPC Z axis), (radians),",100,0,0.2);
  fPhi_Dist = tfs->make<TH1F>("Phi","Track Phi (w.r.t. TPC X axis), (radians)",100,0,6.28318);
  fTOFType = tfs->make<TH1F>("TOFType","Number of valid times of flight per event",10,0,10);
  fParticleMass = tfs->make<TH1F>("Mass","Particle Mass",200,0,2000);
  
  fMagnetSettingHist = tfs->make<TH1F>("MagnetSetting","Magnet Setting",1,0,-1);
  fPolaritySettingHist = tfs->make<TH1F>("PolaritySetting","Polarity Setting",4,-2,2);
  fEnergySettingHist = tfs->make<TH1F>("EnergySetting","Energy Setting",1,0,-1);
  fBDiffHist = tfs->make<TH1F>("BDiff","Difference between B field setting and closest discrete one",1,0,-1);
  fEDiffHist = tfs->make<TH1F>("EDiff","Difference between Energy setting and closest discrete one",1,0,-1);
  
  fTotalNTOFHist = tfs->make<TH1F>("TotalNTOF","Total number of times-of-flight in an event (over all TOF objects)",15,0,15);
  fNTOFHist = tfs->make<TH1F>("TofObjects","Number of TOF objects per event",10,0,10);
  fNWCTrackHist = tfs->make<TH1F>("NWCTracks","Number of WCTracks per event",10,0,10);
  fNMuRSHitsObjectHist = tfs->make<TH1F>("MuRSHitObjects","Number of MuRSHits Objects in the event",5,0,5);
  fNMuRSTrackHist = tfs->make<TH1F>("NMuRSTracks","Number of MuRSTracks per event",15,0,15);

  fPzVsTOFProtons = tfs->make<TH2F>("PzVsTOFProtons","Pz Vs. TOF for Protons",160,0,1600,70,10,80);
  fPzVsTOFKaons = tfs->make<TH2F>("PzVsTOFKaons","Pz Vs. TOF for Kaons",160,0,1600,70,10,80);
  fPzVsTOFPiMu = tfs->make<TH2F>("PzVsTOFPiMu","Pz Vs. TOF for Pions/Muons",160,0,1600,70,10,80);
  fPzVsTOFPions = tfs->make<TH2F>("PzVsTOFPions","Pz Vs. TOF for Pions",160,0,1600,70,10,80);
  fPzVsTOFMuons = tfs->make<TH2F>("PzVsTOFMuons","Pz Vs. TOF for Muons",160,0,1600,70,10,80);
  fPDGCodes = tfs->make<TH1F>("PDGCodes","PDG Codes", 4425,-2212,2213);
  
  fMuRSTracks = tfs->make<TH1F>("GoodTrackTimes","Good MuRS Track Times",3072,0,3072);

  fPiMuProb = tfs->make<TH1F>("PiMuProb","Probability of a PiMu for each event.",100,0,1);
  fKaonProb = tfs->make<TH1F>("KaonProb","Probability of a Kaon for each event.",100,0,1);
  fProtonProb = tfs->make<TH1F>("ProtonProb","Probability of a Proton for each event.",100,0,1);
  
  
  fPz->GetXaxis()->SetTitle("Reconstructed momentum (MeV/c)");
  fPz->GetYaxis()->SetTitle("Tracks per 10 MeV/c");
  fY_Kink->GetXaxis()->SetTitle("Reconstructed y_kink (radians)");
  fY_Kink->GetYaxis()->SetTitle("Tracks per 0.000872 radians");
  fX_Dist->GetXaxis()->SetTitle("X distance between US and DS track ends");
  fX_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
  fY_Dist->GetXaxis()->SetTitle("Y distance between US and DS track ends");
  fY_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
  fZ_Dist->GetXaxis()->SetTitle("Z distance between US and DS track ends");
  fZ_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
  fX_Face_Dist->GetXaxis()->SetTitle("X (mm)");
  fX_Face_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
  fY_Face_Dist->GetXaxis()->SetTitle("Y (mm)");
  fY_Face_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
  fTheta_Dist->GetXaxis()->SetTitle("Theta (radians)");
  fTheta_Dist->GetYaxis()->SetTitle("Tracks per .002 radians");
  fPhi_Dist->GetXaxis()->SetTitle("Phi (radians)");
  fPhi_Dist->GetYaxis()->SetTitle("Tracks per 0.0628 radians");
  fParticleMass->GetXaxis()->SetTitle("Particle Mass (MeV/c^2)");
  fParticleMass->GetYaxis()->SetTitle("Counts");
  fPzVsTOF->GetXaxis()->SetTitle("Momentum (MeV/c)");
  fPzVsTOF->GetYaxis()->SetTitle("TOF (ns)");
  fPzVsTOFGood->GetXaxis()->SetTitle("Momentum (MeV/c)");
  fPzVsTOFGood->GetYaxis()->SetTitle("TOF (ns)");
  fPzVsTOFProtons->GetXaxis()->SetTitle("Momentum (MeV/c)");
  fPzVsTOFProtons->GetYaxis()->SetTitle("TOF (ns)");
  fPzVsTOFKaons->GetXaxis()->SetTitle("Momentum (MeV/c)");
  fPzVsTOFKaons->GetYaxis()->SetTitle("TOF (ns)");
  fPzVsTOFPiMu->GetXaxis()->SetTitle("Momentum (MeV/c)");
  fPzVsTOFPiMu->GetYaxis()->SetTitle("TOF (ns)");
  fPzVsTOFPions->GetXaxis()->SetTitle("Momentum (MeV/c)");
  fPzVsTOFPions->GetYaxis()->SetTitle("TOF (ns)");
  fPzVsTOFMuons->GetXaxis()->SetTitle("Momentum (MeV/c)");
  fPzVsTOFMuons->GetYaxis()->SetTitle("TOF (ns)");




 
  //Setting the distance traveled by a particle via the geometry service
  float usTOFctr[3] = {0,0,0};
  float dsTOFctr[3] = {0,0,0};

  //Testing the AuxDetGeo capabilitites
  std::vector<geo::AuxDetGeo*> const & theAuxDetGeoVect = fGeo->AuxDetGeoVec();
  double centerOfDet[3] = {0,0,0};
  for( size_t iDet = 0; iDet < fGeo->NAuxDets() ; ++iDet ){
    geo::AuxDetGeo* anAuxDetGeo = theAuxDetGeoVect.at(iDet);
    anAuxDetGeo->GetCenter(centerOfDet);

    //    LOG_VERBATIM("ParticleIdentificationSlicing") << "AuxDetGeo " << iDet << " center: (" << centerOfDet[0] << "," << centerOfDet[1] << "," << centerOfDet[2] << ")";
    //0 and 6 are US and DS TOF
    if( iDet == 0 ){
      usTOFctr[0] = centerOfDet[0] * CLHEP::cm;
      usTOFctr[1] = centerOfDet[1] * CLHEP::cm;
      usTOFctr[2] = centerOfDet[2] * CLHEP::cm; 
    }
    if( iDet == 6 ){
      dsTOFctr[0] = centerOfDet[0] * CLHEP::cm;
      dsTOFctr[1] = centerOfDet[1] * CLHEP::cm;
      dsTOFctr[2] = centerOfDet[2] * CLHEP::cm; 
    }

  }

  //Since there's no Bending magnet info in the geometry file, we assume that it is 
  //sufficient to say that there is a 13 degree bend at the target and a 10 degree bend
  //in the bending magnets. We then just use the law of sines to get the total distance
  float rad2deg = 180/3.1415926539;
  TVector3 us2ds(dsTOFctr[0]-usTOFctr[0],
		 dsTOFctr[1]-usTOFctr[1],
		 dsTOFctr[2]-usTOFctr[2]);
  TVector3 zHat(0,0,1);
  float us2dsAngle = acos(us2ds.Dot(zHat)/us2ds.Mag());
  float angle1 = 13-rad2deg*us2dsAngle;
  float angle2 = 170;
  float angle3 = 180-angle1-angle2;
  float shortDist1 = sin(angle3/rad2deg)/sin(angle2/rad2deg)*us2ds.Mag();
  float shortDist2 = sin(angle1/rad2deg)/sin(angle2/rad2deg)*us2ds.Mag();


  
  fDistanceTraveled = (shortDist1+shortDist2)/1000;

  if( fVerbose ){
    LOG_VERBATIM("ParticleIdentificationSlicing") << "us2dsAngle: " << us2dsAngle*rad2deg << "\nangle1: " << angle1 << "\nangle3: " << angle3 << "\nshortDist1: " << shortDist1 << "\nshortDist2: " << shortDist2 << "\nDistanceTraveled: " << fDistanceTraveled; 
  }

}

void ParticleIdentificationSlicing::beginRun(art::Run & r)
{
  // getActivePriorsDefault();
}

void ParticleIdentificationSlicing::beginSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
  fRun = sr.run();
  fSubRun = sr.subRun();

  //Reset and draw information from database on the beam settings
  fMagnetSetting = 0;
  fEnergySetting = 0;
  fPolaritySetting = 0;
  queryDataBaseForMagnetAndEnergy();
}

void ParticleIdentificationSlicing::endJob()
{
  // Implementation of optional member function here.
  for( size_t iKaon = 0; iKaon < fKaonRun.size() ; ++iKaon ){
    LOG_VERBATIM("ParticleIdentificationSlicing") << "Kaon Run: " << fKaonRun.at(iKaon) << ", SubRun: " << fKaonSubRun.at(iKaon) << ", Event: " << fKaonEvent.at(iKaon);
  }
  LOG_VERBATIM("ParticleIdentificationSlicing") << "Good MuRS Tracks: " << fGoodMuRSCounter;

  //Fitting the mass histogram in the appropriate regions to get the
  //parameters used for likelihood estimation of particle flavor
  if( fGenerateFitsForMassDistribution ){
    TF1 * f1 = new TF1("f1","[2]/pow(2*3.14159265,0.5)*exp(-pow((x-[0])/[1],2)/2)",0,400);
    TF1 * f2 = new TF1("f2","[2]/pow(2*3.14159265,0.5)*exp(-pow((x-[0])/[1],2)/2)",400,700);
    TF1 * f3 = new TF1("f3","[2]/pow(2*3.14159265,0.5)*exp(-pow((x-[0])/[1],2)/2)",700,1300);
    f1->SetParameter(0,140);
    f1->SetParameter(1,50);
    f1->SetParameter(2,50);
    f2->SetParameter(0,490);
    f2->SetParameter(1,20);
    f2->SetParameter(2,5);
    f3->SetParameter(0,940);
    f3->SetParameter(1,100);
    f3->SetParameter(2,20);
    LOG_VERBATIM("ParticleIdentificationSlicing") << "Fitting to Pi/Mu peak: ";
    fParticleMass->Fit("f1","R");
    LOG_VERBATIM("ParticleIdentificationSlicing") << "Fitting to Kaon peak: ";
    fParticleMass->Fit("f2","R");
    LOG_VERBATIM("ParticleIdentificationSlicing") << "Fitting to Proton peak: ";
    fParticleMass->Fit("f3","R");
    
    // clean up the pointers - not sure why ROOT seems to require everything to
    // be in pointer form...
    delete f1;
    delete f2;
    delete f3;
  }
  


}

void ParticleIdentificationSlicing::endRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void ParticleIdentificationSlicing::endSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

void ParticleIdentificationSlicing::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  fPathLength                      =p.get< float >("TrajectoryPathLength",6.7);
  fSpeedOfLight                    = 3e+8;
  fTriggerWindowFirstTick          =p.get< int >("TriggerWindowFirstTick",135);
  fTriggerWindowLastTick           =p.get< int >("TriggerWindowLastTick",138);

  fWCTrackModuleLabel              =p.get< std::string >("WCTrackModuleLabel");
  fTOFModuleLabel                  =p.get< std::string >("TOFModuleLabel");
  fMuRSModuleLabel                 =p.get< std::string >("MuRSModuleLabel");
  fVerbose                         =p.get< bool >("Verbose",true);
  fGenerateFitsForMassDistribution = p.get< bool >("GenerateFitsForMassDistribution",false);

  //OLD VALUES
  fPiMuMassMean                    =p.get< float >("PiMuMassMean",1.900e+2);
  fPiMuMassSigma                   =p.get< float >("PiMuMassSigma",8.818e+1);
  fKaonMassMean                    =p.get< float >("KaonMassMean",5.49e+2);
  fKaonMassSigma                   =p.get< float >("KaonMassSigma",2.65e+2);
  fProtonMassMean                  =p.get< float >("ProtonMassMean",1.042e+3);
  fProtonMassSigma                 =p.get< float >("ProtonMassSigma",1.08e+2);
  
  fMaxMomentumForPID               =p.get< float >("MaxMomentumForPID",1000);
  fPiMuLRThreshold                 =p.get< float >("PiMuLikelihoodRatioThreshold",0.5);

  //Beam Probabilities (priors) initialization
  fBeamProbE_08_pos350 = p.get< std::vector<float> >("beamProbE_08_pos350");
  fBeamProbMu_08_pos350 = p.get< std::vector<float> >("beamProbMu_08_pos350");
  fBeamProbPi_08_pos350 = p.get< std::vector<float> >("beamProbPi_08_pos350");
  fBeamProbK_08_pos350 = p.get< std::vector<float> >("beamProbK_08_pos350");
  fBeamProbProt_08_pos350 = p.get< std::vector<float> >("beamProbProt_08_pos350");
  fBeamProbAll_08_pos350 = p.get< std::vector<float> >("beamProbAll_08_pos350");
  
  fBeamProbE_08_pos175 = p.get< std::vector<float> >("beamProbE_08_pos175");
  fBeamProbMu_08_pos175 = p.get< std::vector<float> >("beamProbMu_08_pos175");
  fBeamProbPi_08_pos175 = p.get< std::vector<float> >("beamProbPi_08_pos175");
  fBeamProbK_08_pos175 = p.get< std::vector<float> >("beamProbK_08_pos175");
  fBeamProbProt_08_pos175 = p.get< std::vector<float> >("beamProbProt_08_pos175");
  fBeamProbAll_08_pos175 = p.get< std::vector<float> >("beamProbAll_08_pos175");
  
  fBeamProbE_08_neg175 = p.get< std::vector<float> >("beamProbE_08_neg175");
  fBeamProbMu_08_neg175 = p.get< std::vector<float> >("beamProbMu_08_neg175");
  fBeamProbPi_08_neg175 = p.get< std::vector<float> >("beamProbPi_08_neg175");
  fBeamProbK_08_neg175 = p.get< std::vector<float> >("beamProbK_08_neg175");
  fBeamProbProt_08_neg175 = p.get< std::vector<float> >("beamProbProt_08_neg175");
  fBeamProbAll_08_neg175 = p.get< std::vector<float> >("beamProbAll_08_neg175");  

  fBeamProbE_08_neg350 = p.get< std::vector<float> >("beamProbE_08_neg350");
  fBeamProbMu_08_neg350 = p.get< std::vector<float> >("beamProbMu_08_neg350");
  fBeamProbPi_08_neg350 = p.get< std::vector<float> >("beamProbPi_08_neg350");
  fBeamProbK_08_neg350 = p.get< std::vector<float> >("beamProbK_08_neg350");
  fBeamProbProt_08_neg350 = p.get< std::vector<float> >("beamProbProt_08_neg350");
  fBeamProbAll_08_neg350 = p.get< std::vector<float> >("beamProbAll_08_neg350");
  
  fBeamProbE_32_pos350 = p.get< std::vector<float> >("beamProbE_32_pos350");
  fBeamProbMu_32_pos350 = p.get< std::vector<float> >("beamProbMu_32_pos350");
  fBeamProbPi_32_pos350 = p.get< std::vector<float> >("beamProbPi_32_pos350");
  fBeamProbK_32_pos350 = p.get< std::vector<float> >("beamProbK_32_pos350");
  fBeamProbProt_32_pos350 = p.get< std::vector<float> >("beamProbProt_32_pos350");
  fBeamProbAll_32_pos350 = p.get< std::vector<float> >("beamProbAll_32_pos350");
  
  fBeamProbE_32_pos175 = p.get< std::vector<float> >("beamProbE_32_pos175");
  fBeamProbMu_32_pos175 = p.get< std::vector<float> >("beamProbMu_32_pos175");
  fBeamProbPi_32_pos175 = p.get< std::vector<float> >("beamProbPi_32_pos175");
  fBeamProbK_32_pos175 = p.get< std::vector<float> >("beamProbK_32_pos175");
  fBeamProbProt_32_pos175 = p.get< std::vector<float> >("beamProbProt_32_pos175");
  fBeamProbAll_32_pos175 = p.get< std::vector<float> >("beamProbAll_32_pos175");
  
  fBeamProbE_32_neg175 = p.get< std::vector<float> >("beamProbE_32_neg175");
  fBeamProbMu_32_neg175 = p.get< std::vector<float> >("beamProbMu_32_neg175");
  fBeamProbPi_32_neg175 = p.get< std::vector<float> >("beamProbPi_32_neg175");
  fBeamProbK_32_neg175 = p.get< std::vector<float> >("beamProbK_32_neg175");
  fBeamProbProt_32_neg175 = p.get< std::vector<float> >("beamProbProt_32_neg175");
  fBeamProbAll_32_neg175 = p.get< std::vector<float> >("beamProbAll_32_neg175");

  makeMCPriorMap();

  fPiPlusPenetrationDepth = p.get< std::vector<float> >("penetrationDepthPiPlus");
  fPiMinusPenetrationDepth = p.get< std::vector<float> >("penetrationDepthPiMinus");
  fMuPlusPenetrationDepth = p.get< std::vector<float> >("penetrationDepthMuPlus");
  fMuMinusPenetrationDepth = p.get< std::vector<float> >("penetrationDepthMuMinus");
  fKPlusPenetrationDepth = p.get< std::vector<float> >("penetrationDepthKPlus");
  fKMinusPenetrationDepth = p.get< std::vector<float> >("penetrationDepthKMinus");
  fEPenetrationDepth = p.get< std::vector<float> >("penetrationDepthElectron");
  fProtPenetrationDepth = p.get< std::vector<float> >("penetrationDepthProton");

  fGoodMuRSCounter = 0;
  
}

void ParticleIdentificationSlicing::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void ParticleIdentificationSlicing::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void ParticleIdentificationSlicing::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void ParticleIdentificationSlicing::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(ParticleIdentificationSlicing)
