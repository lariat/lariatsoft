////////////////////////////////////////////////////////////////////////
// Class:       Edge
// 
// Module Type: producer
// File:        Edge_module.cc
//
// Generated at Mon Jul  6 12:05:12 2015 by Jessica Esquivel using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art_root_io/TFileService.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <stdint.h>
#include <string>
#include <sstream>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <iostream>
#include <vector>


//Larsoft Includes

#include "larcoreobj/SimpleTypesAndConstants/RawTypes.h"
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/CryostatGeo.h"
#include "larcorealg/Geometry/TPCGeo.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "lardataobj/RecoBase/Wire.h"
#include "LArIATDataProducts/Edge.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardata/ArtDataHelper/HitCreator.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/Utilities/AssociationUtil.h"

// ROOT Includes
#include "TGraphErrors.h"
#include "TH1D.h"
#include "TDecompSVD.h"
#include "TMath.h"
#include "TF1.h"
#include "TTree.h"
#include "TStopwatch.h"

//LArIAT Specific Includes

#include "RawDataUtilities/TriggerDigitUtility.h"

namespace edge{
class Edge;

class Edge : public art::EDProducer {
public:
  explicit Edge(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  Edge(Edge const &) = delete;
  Edge(Edge &&) = delete;
  Edge & operator = (Edge const &) = delete;
  Edge & operator = (Edge &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void reconfigure(fhicl::ParameterSet const & p) ;

private:

  // Declare member data here.
  //double threshold = 0; // unused
  //double fitWidth = 0; // unused
  //double minWidth = 0; // unused
  std::string fCalDataModuleLabel;
  std::string fDigitModuleLabel;
  int fTimeBins;

  std::vector<double> fMinSig;
  std::vector<double> fMinWidth;


        int W, H;               // Width and Height of current frame [pixels]
        int iterator=1; 
        //float collectioniterator; // unused         // 
        //float inductioniterator; // unused         // 
        int edgeDircol[240][256]; // 
        int edgeDirind[240][256]; // 
        float gradientcol[240][256];      // 
        float gradientind[240][256];      // 
        float data1collection[240][256]; // 
        float data1induction[240][256]; // 
        float datapiccollection[240][256];
        float datapicinduction[240][256];
        float wire_map[480][256];
        float wire_signal[480][3072];
        int row, col;           // Pixel's row and col positions
        //int row1, col1; // unused         // Pixel's row and col positions
        // kludge for c2:  set these to zero since that is what the conversion to int does
        //int upperThreshold = .8;        // Gradient strength nessicary to start edge
        //int lowerThreshold = .02;               // Minimum gradient strength to continue edge
        int upperThreshold = 0;        // Gradient strength nessicary to start edge
        int lowerThreshold = 0;               // Minimum gradient strength to continue edge
        //unsigned long iOffset; // unused          // Variable to offset row-column vector during sobel mask
        //unsigned long iOffset1; // unused         // Variable to offset row-column vector during sobel mask
        int rowOffset;                  // Row offset from the current pixel
        int colOffset;                  // Col offset from the current pixel
        int rowTotal = 0;               // Row position of offset pixel
        int colTotal = 0;               // Col position of offset pixel
        //int rowOffset1; // unused                 // Row offset from the current pixel
        //int colOffset1; // unused                 // Col offset from the current pixel
        //int rowTotal1 = 0; // unused              // Row position of offset pixel
        //int colTotal1 = 0; // unused              // Col position of offset pixel
        float Gxcol;                       // Sum of Sobel mask products values in the x direction
        float Gycol;                       // Sum of Sobel mask products values in the y direction
        float thisAnglecol;                // Gradient direction based on Gx and Gy
        int newAnglecol;                   // Approximation of the gradient direction
        float Gxind;                       // Sum of Sobel mask products values in the x direction
        float Gyind;                       // Sum of Sobel mask products values in the y direction
        float thisAngleind;                // Gradient direction based on Gx and Gy
        int newAngleind;                   // Approximation of the gradient direction
        bool edgeEnd;                   // Stores whether or not the edge is at the edge of the possible image
        int GxMask[3][3];               // Sobel mask in the x direction
        int GyMask[3][3];               // Sobel mask in the y direction
        //float newPixelcollection; // unused                 // Sum pixel values for gaussian
        //float newPixelinduction; // unused                 // Sum pixel values for gaussian
        float gaussianMask[5][5];               // Gaussian mask
        //float CollectionPic[240*3072]; // unused
        //float InductionPic[240*3072]; // unused



  double Gaussian(float x, int y, double sigma);
  void findEdgecol(int rowShift, int colShift, int row, int col, int dir, int lowerThreshold);
  void suppressNonMaxcol(int rowShift, int colShift, int row, int col, int dir, int lowerThreshold);
  void findEdgeind(int rowShift, int colShift, int row, int col, int dir, int lowerThreshold);
  void suppressNonMaxind(int rowShift, int colShift, int row, int col, int dir, int lowerThreshold);
  void SaveBMPFile(const char *fileName, unsigned char *pix, int dx, int dy);
  

};


Edge::Edge(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  this->reconfigure(p);
  produces< std::vector<ldp::Edge> >();
  produces<art::Assns<raw::Trigger, ldp::Edge>>();
}

void Edge::reconfigure(fhicl::ParameterSet const& p)
{
  //Implementation of optional member functions here.
  fCalDataModuleLabel = p.get< std::string >("CalDataModuleLabel");
  fTimeBins =256;
  //fTriggerUtility = p.get< std::string >("TriggerUtility");
  fDigitModuleLabel ="SlicerInput";
  //fCalDataModuleLabel = "caldata";
}
void Edge::beginJob()
{
  // Implementation of optional member function here.
  art::ServiceHandle<art::TFileService> tfs;
  //add histogram information here
}
double edge::Edge::Gaussian(float x, int y, double sigma)
{
  double Norm  = 1./std::sqrt(2*TMath::Pi()*pow(sigma,2));
  double value = Norm*exp(-(pow(x,2)+pow(y,2))/(2*pow(sigma,2)));
  return value;
}
void edge::Edge::findEdgecol(int rowShift, int colShift, int row, int col, int dir, int lowerThreshold)
{
        int W = 240;
        int H = fTimeBins;
        int newRow=0;
        int newCol=0;
        bool edgeEnd = false;
/*        std::cout<<"In findEdgeLoop"<<std::endl;*/
        /* Find the row and column values for the next possible pixel on the edge */
        if (colShift < 0) {
                if (col > 0)
                        newCol = col + colShift;
                else
                        edgeEnd = true;
        } else if (col < W - 1) {
                newCol = col + colShift;
        } else
                edgeEnd = true;         // If the next pixel would be off image, don't do the while loop
        if (rowShift < 0) {
                if (row > 0)
                        newRow = row + rowShift;
                else
                        edgeEnd = true;
        } else if (row < H - 1) {
                newRow = row + rowShift;
        } else
                edgeEnd = true;

        /* Determine edge directions and gradient strengths */
        while ( (edgeDircol[newRow][newCol]==dir) && !edgeEnd && (gradientcol[newRow][newCol] > lowerThreshold) ) {
                /* Set the new pixel as white to show it is an edge */
                data1collection[newRow][newCol]=255;  //may have to set to 255 
 /*       std::cout<<"In findEdgeLoop: just set data1 to 1:"<<data1[newRow][newCol]<<std::endl;*/
                if (colShift < 0) {
                        if (newCol > 0)
                                newCol = newCol + colShift;
                        else
                                edgeEnd = true;
                } else if (newCol < W - 1) {
                        newCol = newCol + colShift;
                } else
                        edgeEnd = true;
                if (rowShift < 0) {
                        if (newRow > 0)
                                newRow = newRow + rowShift;
                        else
                                edgeEnd = true;
                } else if (newRow < H - 1) {
                        newRow = newRow + rowShift;
                } else
                        edgeEnd = true;
        }
}
void edge::Edge::findEdgeind(int rowShift, int colShift, int row, int col, int dir, int lowerThreshold)
{
        int W = 240;
        int H = fTimeBins;
        int newRow=0;
        int newCol=0;
        bool edgeEnd = false;
/*        std::cout<<"In findEdgeLoop"<<std::endl;*/
        /* Find the row and column values for the next possible pixel on the edge */
        if (colShift < 0) {
                if (col > 0)
                        newCol = col + colShift;
                else
                        edgeEnd = true;
        } else if (col < W - 1) {
                newCol = col + colShift;
        } else
                edgeEnd = true;         // If the next pixel would be off image, don't do the while loop
        if (rowShift < 0) {
                if (row > 0)
                        newRow = row + rowShift;
                else
                        edgeEnd = true;
        } else if (row < H - 1) {
                newRow = row + rowShift;
        } else
                edgeEnd = true;

        /* Determine edge directions and gradient strengths */
        while ( (edgeDirind[newRow][newCol]==dir) && !edgeEnd && (gradientind[newRow][newCol] > lowerThreshold) ) {
                /* Set the new pixel as white to show it is an edge */
                data1induction[newRow][newCol]=255;  //may have to set to 255 
 /*       std::cout<<"In findEdgeLoop: just set data1 to 1:"<<data1[newRow][newCol]<<std::endl;*/
                if (colShift < 0) {
                        if (newCol > 0)
                                newCol = newCol + colShift;
                        else
                                edgeEnd = true;
                } else if (newCol < W - 1) {
                        newCol = newCol + colShift;
                } else
                        edgeEnd = true;
                if (rowShift < 0) {
                        if (newRow > 0)
                                newRow = newRow + rowShift;
                        else
                                edgeEnd = true;
                } else if (newRow < H - 1) {
                        newRow = newRow + rowShift;
                } else
                        edgeEnd = true;
        }
}

void edge::Edge::suppressNonMaxcol(int rowShift, int colShift, int row, int col, int dir, int lowerThreshold)
{
        int W = 240;
        int H = fTimeBins;
        int newRow = 0;
        int newCol = 0;
        bool edgeEnd = false;
        float nonMax[2048][3];          // Temporarily stores gradients and positions of pixels in parallel edges
        int pixelCount = 0;             // Stores the number of pixels in parallel edges
        int count;
        int max[3];                     // Maximum point in a wide edge

        if (colShift < 0) {
                if (col > 0)
                        newCol = col + colShift;
                else
                        edgeEnd = true;
        } else if (col < W - 1) {
                newCol = col + colShift;
        } else
                edgeEnd = true;         // If the next pixel would be off image, don't do the while loop
        if (rowShift < 0) {
                if (row > 0)
                        newRow = row + rowShift;
                else
                        edgeEnd = true;
        } else if (row < H - 1) {
                newRow = row + rowShift;
        } else
                edgeEnd = true;
        /* Find non-maximum parallel edges tracing up */
        while ((edgeDircol[newRow][newCol] == dir) && !edgeEnd && (data1collection[newRow][newCol] == 255)) {
                if (colShift < 0) {
                        if (newCol > 0)
                                newCol = newCol + colShift;
                        else
                                edgeEnd = true;
                } else if (newCol < W - 1) {
                        newCol = newCol + colShift;
                } else
                        edgeEnd = true;
                if (rowShift < 0) {
                        if (newRow > 0)
                                newRow = newRow + rowShift;
                        else
                                edgeEnd = true;
                } else if (newRow < H - 1) {
                        newRow = newRow + rowShift;
                } else
                        edgeEnd = true;
                nonMax[pixelCount][0] = newRow;
                nonMax[pixelCount][1] = newCol;
                nonMax[pixelCount][2] = gradientcol[newRow][newCol];
                pixelCount++;
        }
                           
        /* Find non-maximum parallel edges tracing down */
        edgeEnd = false;
        colShift *= -1;
        rowShift *= -1;
        if (colShift < 0) {
                if (col > 0)
                        newCol = col + colShift;
                else
                        edgeEnd = true;
        } else if (col < W - 1) {
                newCol = col + colShift;
        } else
                edgeEnd = true;
        if (rowShift < 0) {
                if (row > 0)
                        newRow = row + rowShift;
                else
                        edgeEnd = true;
        } else if (row < H - 1) {
                newRow = row + rowShift;
        } else
                edgeEnd = true;
        /*i = (unsigned long)(newRow*3*W + 3*newCol);*/
        while ((edgeDircol[newRow][newCol] == dir) && !edgeEnd && (data1collection[newRow][newCol] == 255)) {
                if (colShift < 0) {
                        if (newCol > 0)
                                newCol = newCol + colShift;
                        else
                                edgeEnd = true;
                } else if (newCol < W - 1) {
                        newCol = newCol + colShift;
                } else
                        edgeEnd = true;
                if (rowShift < 0) {
                        if (newRow > 0)
                                newRow = newRow + rowShift;
                        else
                                edgeEnd = true;
                } else if (newRow < H - 1) {
                        newRow = newRow + rowShift;
                } else
                        edgeEnd = true;
                nonMax[pixelCount][0] = newRow;
                nonMax[pixelCount][1] = newCol;
                nonMax[pixelCount][2] = gradientcol[newRow][newCol];
                pixelCount++;
        }

        /* Suppress non-maximum edges */
        max[0] = 0;
        max[1] = 0;
        max[2] = 0;
        for (count = 0; count < pixelCount; count++) {
                if (nonMax[count][2] > max[2]) {
                        max[0] = nonMax[count][0];
                        max[1] = nonMax[count][1];
                        max[2] = nonMax[count][2];
                }
        }
        for (count = 0; count < pixelCount; count++) {
                row=nonMax[count][0];
                col=nonMax[count][1];
                data1collection[row][col] = 0;
        }
}
void edge::Edge::suppressNonMaxind(int rowShift, int colShift, int row, int col, int dir, int lowerThreshold)
{
        int W = 240;
        int H = fTimeBins;
        int newRow = 0;
        int newCol = 0;
        bool edgeEnd = false;
        float nonMax[2048][3];          // Temporarily stores gradients and positions of pixels in parallel edges
        int pixelCount = 0;             // Stores the number of pixels in parallel edges
        int count;
        int max[3];                     // Maximum point in a wide edge

        if (colShift < 0) {
                if (col > 0)
                        newCol = col + colShift;
                else
                        edgeEnd = true;
        } else if (col < W - 1) {
                newCol = col + colShift;
        } else
                edgeEnd = true;         // If the next pixel would be off image, don't do the while loop
        if (rowShift < 0) {
                if (row > 0)
                        newRow = row + rowShift;
                else
                        edgeEnd = true;
        } else if (row < H - 1) {
                newRow = row + rowShift;
        } else
                edgeEnd = true;
        /* Find non-maximum parallel edges tracing up */
        while ((edgeDirind[newRow][newCol] == dir) && !edgeEnd && (data1induction[newRow][newCol] == 255)) {
                if (colShift < 0) {
                        if (newCol > 0)
                                newCol = newCol + colShift;
                        else
                                edgeEnd = true;
                } else if (newCol < W - 1) {
                        newCol = newCol + colShift;
                } else
                        edgeEnd = true;
                if (rowShift < 0) {
                        if (newRow > 0)
                                newRow = newRow + rowShift;
                        else
                                edgeEnd = true;
                } else if (newRow < H - 1) {
                        newRow = newRow + rowShift;
                } else
                        edgeEnd = true;
                nonMax[pixelCount][0] = newRow;
                nonMax[pixelCount][1] = newCol;
                nonMax[pixelCount][2] = gradientind[newRow][newCol];
                pixelCount++;
        }
                           
        /* Find non-maximum parallel edges tracing down */
        edgeEnd = false;
        colShift *= -1;
        rowShift *= -1;
        if (colShift < 0) {
                if (col > 0)
                        newCol = col + colShift;
                else
                        edgeEnd = true;
        } else if (col < W - 1) {
                newCol = col + colShift;
        } else
                edgeEnd = true;
        if (rowShift < 0) {
                if (row > 0)
                        newRow = row + rowShift;
                else
                        edgeEnd = true;
        } else if (row < H - 1) {
                newRow = row + rowShift;
        } else
                edgeEnd = true;
        /*i = (unsigned long)(newRow*3*W + 3*newCol);*/
        while ((edgeDirind[newRow][newCol] == dir) && !edgeEnd && (data1induction[newRow][newCol] == 255)) {
                if (colShift < 0) {
                        if (newCol > 0)
                                newCol = newCol + colShift;
                        else
                                edgeEnd = true;
                } else if (newCol < W - 1) {
                        newCol = newCol + colShift;
                } else
                        edgeEnd = true;
                if (rowShift < 0) {
                        if (newRow > 0)
                                newRow = newRow + rowShift;
                        else
                                edgeEnd = true;
                } else if (newRow < H - 1) {
                        newRow = newRow + rowShift;
                } else
                        edgeEnd = true;
                nonMax[pixelCount][0] = newRow;
                nonMax[pixelCount][1] = newCol;
                nonMax[pixelCount][2] = gradientind[newRow][newCol];
                pixelCount++;
        }

        /* Suppress non-maximum edges */
        max[0] = 0;
        max[1] = 0;
        max[2] = 0;
        for (count = 0; count < pixelCount; count++) {
                if (nonMax[count][2] > max[2]) {
                        max[0] = nonMax[count][0];
                        max[1] = nonMax[count][1];
                        max[2] = nonMax[count][2];
                }
        }
        for (count = 0; count < pixelCount; count++) {
                row=nonMax[count][0];
                col=nonMax[count][1];
                data1induction[row][col] = 0;
        }
}



void Edge::beginRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void Edge::beginSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

void Edge::endJob()
{
  // Implementation of optional member function here.
}
void Edge::produce(art::Event & evt)
{
  // Implementation of required member function here.
   std::cout<<"Inside Produce Loop"<<std::endl; 
  // #################################
  // ###List of variables for code ###
  // #################################

   std::cout<<"declaring sobel masks"<<std::endl;
        GxMask[0][0] = -1; GxMask[0][1] = 0; GxMask[0][2] = 1;
        GxMask[1][0] = -2; GxMask[1][1] = 0; GxMask[1][2] = 2;
        GxMask[2][0] = -1; GxMask[2][1] = 0; GxMask[2][2] = 1;

        GyMask[0][0] =  1; GyMask[0][1] =  2; GyMask[0][2] =  1;
        GyMask[1][0] =  0; GyMask[1][1] =  0; GyMask[1][2] =  0;
        GyMask[2][0] = -1; GyMask[2][1] = -2; GyMask[2][2] = -1;

        gaussianMask[0][0] = 2;  gaussianMask[0][1] = 4;  gaussianMask[0][2] = 5;  gaussianMask[0][3] = 4;  gaussianMask[0][4] = 2;
        gaussianMask[1][0] = 4;  gaussianMask[1][1] = 9;  gaussianMask[1][2] = 12; gaussianMask[1][3] = 9;  gaussianMask[1][4] = 4;
        gaussianMask[2][0] = 5;  gaussianMask[2][1] = 12; gaussianMask[2][2] = 15; gaussianMask[2][3] = 12; gaussianMask[2][4] = 2;
        gaussianMask[3][0] = 4;  gaussianMask[3][1] = 9;  gaussianMask[3][2] = 12; gaussianMask[3][3] = 9;  gaussianMask[3][4] = 4;
        gaussianMask[4][0] = 2;  gaussianMask[4][1] = 4;  gaussianMask[4][2] = 5;  gaussianMask[4][3] = 4;  gaussianMask[4][4] = 2;




   
  // ##########################
  // ###Detector Properties ###
  // ##########################
  //auto const* detprop = lar::providerFrom<detinfo::DetectorPropertiesService>();
 
  
  // #######################
  // ###Geometry Service ###
  // #######################
  //art::ServiceHandle<geo::Geometry> geom;
  

  // ############################################
  // ###Making a pnt vector to put onto event ###
  // ############################################
  std::unique_ptr<std::vector<ldp::Edge> > ecol(new std::vector<ldp::Edge>);


  // ##########################################
  // ###Reading in the wire list object(s)  ###
  // ##########################################
 art::Handle<std::vector<recob::Wire> >wireVecHandle;
 evt.getByLabel(fCalDataModuleLabel,wireVecHandle);

  art::FindOneP<raw::RawDigit> RawDigits (wireVecHandle, evt, fCalDataModuleLabel);
 
  //Signal Type(Collection or Induction)
  //geo::SigType_t sigType;

 
  // ###############################################
  // ###Making association of Triggers to Edges  ###
  // ###############################################
  //std::unique_ptr<art::Assns<raw::Trigger, ldp::Edge> >TrigEdgeAssn(new art::Assns<raw::Trigger,ldp::Edge>);


 
  // ##########################################
  // ###Grab the trigger data utility(tdu)  ###
  // ##########################################
  //rdu::TriggerDigitUtility tdu(evt, fTriggerUtility);
  //art::PtrVector<raw::Trigger> const& EventTriggersPtr = tdu.EventTriggersPtr();

  // ##########################################################
  // ###Reading in the RawDigit associated with these wires ###
  // ##########################################################
  //art::FindManyP<raw::RawDigit> RawDigits(tdu.EventTriggersPtr(), evt, fTriggerUtility);
  //art::FindManyP<recob::Wire> CalWireDigits(tdu.EventTriggersPtr(), evt, fCalDataModuleLabel);


    //art::Handle< std::vector<raw::RawDigit> > digitVecHandle;
    //evt.getByLabel(fDigitModuleLabel, fSpillName, digitVecHandle);

  //  if (!digitVecHandle->size())  return;
  //  mf::LogInfo("CalWireROIT1034") << "CalWireROIT1034:: digitVecHandle size is " << digitVecHandle->size();
    
    //art::Ptr<raw::RawDigit> digitVec0(digitVecHandle, 0);
   
  //Channel Number
  //raw::ChannelID_t channel = raw::InvalidChannelID;
  
 // unsigned int dataSize = digitVec0->Samples();

W=wireVecHandle->size()/2;
H=256;
int H1=3072;


        for (row = 0; row < W*2; row++) {
                for (col = 0; col < H1; col++) {
                        wire_signal[row][col] = 0;
                }
        }

        for (row = 0; row < W*2; row++) {
                for (col = 0; col < H; col++) {
                        wire_map[row][col] = 0;
                }
        }
  

        for (row = 0; row < W; row++) {
                for (col = 0; col < H; col++) {
                        edgeDircol[row][col] = 0;
                        edgeDirind[row][col] = 0;
                        gradientcol[row][col] = 0;
                        gradientind[row][col] = 0;
                        data1collection[row][col] = 0;
                        data1induction[row][col] = 0;
                        datapiccollection[row][col] = 0;
                        datapicinduction[row][col] = 0;
                }
        }
	
   std::cout<<"above wireIter loop"<<std::endl;
  	// ############################
  	// ###pixelization of wires ###
  	// ############################
    std::cout<<"wireVecHandle size: "<<wireVecHandle->size()<<std::endl;

  	for(unsigned int wireIter = 0; wireIter < wireVecHandle->size(); wireIter++)
	{

  	 	art::Ptr<recob::Wire> wire(wireVecHandle, wireIter);
  		std::vector<float> signal(wire->Signal());
		const float TicksPerBin = signal.size() / fTimeBins;
	
               	std::vector<float>::iterator timeIter;	
               	int centerIter=0;	
               	int timeiter=0;	
		float center = 0;
  		for(timeIter= signal.begin(); timeIter<signal.end();timeIter++)
		{
			if(center<=*timeIter) {center=*timeIter; centerIter=timeiter;}
			wire_signal[wireIter][timeiter]=*timeIter;
			timeiter++;
		
		}
		float rms=TMath::RMS(signal.begin(),signal.end());
		float iFirstBin = (centerIter-3*rms)/TicksPerBin;
		float iLastBin = (centerIter+3*rms)/TicksPerBin;
		
		std::cout<<"Center: "<<center<<" CenterIter: "<<centerIter<<" RMS: "<<rms<<" iFirstBin: "<<int(std::round(iFirstBin))<<" iLastBin: "<<int(std::round(iLastBin))<<std::endl;	
		
               	for (float iBin = iFirstBin; iBin <iLastBin; ++iBin) 
		{
               		const float bin_center = iBin * TicksPerBin;
               		wire_map[wireIter][int(std::round(iBin))] += Gaussian(bin_center, centerIter, rms);
         	}
		for(int TickIter=0; TickIter<fTimeBins; TickIter++)
		{
			std::cout<<"WireIter: "<<wireIter<<" TickIter: "<<TickIter<<" iFirstTick: "<<int(std::round(iFirstBin*TicksPerBin))
				 <<" iLastTick: "<<int(std::round(iLastBin*TicksPerBin))<<" wire_map: "<<wire_map[wireIter][TickIter];
			if(int(std::round(iFirstBin))==256) 
			{
				iFirstBin=255;
				iLastBin=255;
			}
			if(TickIter==int(std::round(iFirstBin)))
			{
               			for (float iBin = iFirstBin; iBin <iLastBin; ++iBin) 
				{
					if(int(std::round(iLastBin))-int(std::round(iFirstBin))==0) 
					{
						wire_map[wireIter][int(std::round(iBin))]=fabs(wire_signal[wireIter][centerIter]);
					}

					if(int(std::round(iLastBin))-int(std::round(iFirstBin))==1 && iLastBin<255) 
					{
						wire_map[wireIter][int(std::round(iBin))]=fabs(wire_signal[wireIter][centerIter]);
						
						if(fabs(wire_signal[wireIter][centerIter+1])<fabs(wire_signal[wireIter][centerIter-1]))
							wire_map[wireIter][int(std::round(iBin+1))]=fabs(wire_signal[wireIter][centerIter-1]);
						
						else if(fabs(wire_signal[wireIter][centerIter-1])<fabs(wire_signal[wireIter][centerIter+1]))
							wire_map[wireIter][int(std::round(iBin+1))]=fabs(wire_signal[wireIter][centerIter+1]);
					}
					else if(int(std::round(iLastBin))-int(std::round(iFirstBin))==1 && iLastBin==255) 
					{
						wire_map[wireIter][int(std::round(iBin))]=fabs(wire_signal[wireIter][centerIter]);

						if(fabs(wire_signal[wireIter][centerIter+1])<fabs(wire_signal[wireIter][centerIter-1]))
							wire_map[wireIter][int(std::round(iBin+1))]=fabs(wire_signal[wireIter][centerIter-1]);
						
						else if(fabs(wire_signal[wireIter][centerIter-1])<fabs(wire_signal[wireIter][centerIter+1]))
							wire_map[wireIter][int(std::round(iBin+1))]=fabs(wire_signal[wireIter][centerIter+1]);

					}
					else
					{
						wire_map[wireIter][int(std::round(iBin))]=fabs(wire_signal[wireIter][int(std::round(iBin*TicksPerBin))]);
						/*
						for(float iTick=iBin*TicksPerBin; iTick<=iLastBin*TicksPerBin; iTick++)
						{
							if(fabs(wire_signal[wireIter][int(std::round(iTick))])<fabs(wire_signal[wireIter][int(std::round(iTick+1))]))
								wire_map[wireIter][int(std::round(iBin))]=fabs(wire_signal[wireIter][int(std::round(iTick+1))]);
						}
						*/
					}

				}	
			}
			std::cout<<" wire_map_centerIter: "<<wire_map[wireIter][centerIter];	
			std::cout<<" wire_map_override: "<<wire_map[wireIter][TickIter]<<std::endl;  	//-----------LOOK HERE!!!!	
			iFirstBin = (centerIter-3*rms)/TicksPerBin;
		  	iLastBin = (centerIter+3*rms)/TicksPerBin;
		}
		
	}

   	std::cout<<"finished with pixelization loop"<<std::endl;

  	for(unsigned int wireIter= 0; wireIter<wireVecHandle->size();wireIter++)
	{
  		for(int timeIter= 0; timeIter<=fTimeBins;timeIter++)
		{
		//	std::cout<<"WireIter: "<<wireIter<<" timeiter: "<<timeIter<<" wire_map: "<<wire_map[wireIter][timeIter]<<std::endl;	
			//std::cout<<"Inside Signal Vector Loop"<<std::endl;	
			if ((wireIter)<240)
			{
        			//std::cout<<"Inside collection/induction splitting if statement loop: "<<wireIter<<std::endl;
        			//std::cout<<"wire_map output: "<<wire_map[wireIter][timeIter]<<std::endl;
				datapiccollection[wireIter][timeIter]=wire_map[wireIter][timeIter];
			//	std::cout<<fabs(*timeIter)<<",";
			}
			else 
			{
        			//std::cout<<"Inside collection/induction splitting else statement loop: "<<wireIter<<std::endl;
        			//std::cout<<"wire_map output: "<<wire_map[wireIter][timeIter]<<std::endl;
				datapicinduction[wireIter-240][timeIter]=wire_map[wireIter][timeIter];
			//	std::cout<<fabs(*timeIter)<<",";
			}
		}
	}
/*

        std::cout<<"At gaussian smoothing loop"<<std::endl;
  	for (row = 2; row < W-2; row++) 
	{
            	for (col = 2; col < H-2; col++) 
		{
                	newPixelcollection = 0;
                	newPixelinduction = 0;
                	for (rowOffset=-2; rowOffset<=2; rowOffset++) 
			{
                     		for (colOffset=-2; colOffset<=2; colOffset++) 
				{
                          		rowTotal = row + rowOffset;
                          		colTotal = col + colOffset;
                          		newPixelcollection += datapiccollection[rowTotal][colTotal] * gaussianMask[2 + rowOffset][2 + colOffset];
                          		newPixelinduction  += datapicinduction[rowTotal][colTotal]  * gaussianMask[2 + rowOffset][2 + colOffset];
                     		}
                	}
                        data1collection[row][col] = newPixelcollection / 159;
                        data1induction[row][col] = newPixelinduction / 159;
			//std::cout<<data1[row][col]<<", ";
            	}
		
   //         std::cout<<""<<std::endl;			
        }
*/
        std::cout<<"At edge finding loop"<<std::endl;

        for (row = 1; row < W-1; row++) 
  	{
        	for (col = 1; col < H-1; col++) 
		{
                        Gxcol = 0;
                        Gycol = 0;
                        Gxind = 0;
                        Gyind = 0;
                        /* Calculate the sum of the Sobel mask times the nine surrounding pixels in the x and y direction*/

                        for (rowOffset=-1; rowOffset<=1; rowOffset++) 
			{
                                for (colOffset=-1; colOffset<=1; colOffset++) 
				{
                                        rowTotal = row + rowOffset;
                                        colTotal = col + colOffset;
                                        Gxcol = Gxcol + datapiccollection[rowTotal][colTotal] * GxMask[rowOffset + 1][colOffset + 1];
                                        Gycol = Gycol + datapiccollection[rowTotal][colTotal] * GyMask[rowOffset + 1][colOffset + 1];
                                        Gxind = Gxind + datapicinduction[rowTotal][colTotal]  * GxMask[rowOffset + 1][colOffset + 1];
                                        Gyind = Gyind + datapicinduction[rowTotal][colTotal]  * GyMask[rowOffset + 1][colOffset + 1];
                                }
                        }


                        gradientcol[row][col] = sqrt(pow(Gxcol,2.0) + pow(Gycol,2.0));   // Calculate gradient strength          
                        /*std::cout<<gradient[row][col]<<",";*/
                        thisAnglecol = (atan2(Gycol,Gxcol)/3.14159) * 180.0;             // Calculate actual direction of edge
                        /* Convert actual edge direction to approximate value*/
                        if ( ( (thisAnglecol < 22.5) && (thisAnglecol > -22.5) ) || (thisAnglecol > 157.5) || (thisAnglecol < -157.5) )
                                newAnglecol = 0;
                        if ( ( (thisAnglecol > 22.5) && (thisAnglecol < 67.5) ) || ( (thisAnglecol < -112.5) && (thisAnglecol > -157.5) ) )
                                newAnglecol = 45;
                        if ( ( (thisAnglecol > 67.5) && (thisAnglecol < 112.5) ) || ( (thisAnglecol < -67.5) && (thisAnglecol > -112.5) ) )
                                newAnglecol = 90;
                        if ( ( (thisAnglecol > 112.5) && (thisAnglecol < 157.5) ) || ( (thisAnglecol < -22.5) && (thisAnglecol > -67.5) ) )
                                newAnglecol = 135;

                        edgeDircol[row][col] = newAnglecol;           // Store the approximate edge direction of each pixel in one array

                        gradientind[row][col] = sqrt(pow(Gxind,2.0) + pow(Gyind,2.0));   // Calculate gradient strength          
                        /*std::cout<<gradient[row][ind]<<",";*/
                        thisAngleind = (atan2(Gyind,Gxind)/3.14159) * 180.0;             // Calculate actual direction of edge
                        /* Convert actual edge direction to approximate value*/
                        if ( ( (thisAngleind < 22.5) && (thisAngleind > -22.5) ) || (thisAngleind > 157.5) || (thisAngleind < -157.5) )
                                newAngleind = 0;
                        if ( ( (thisAngleind > 22.5) && (thisAngleind < 67.5) ) || ( (thisAngleind < -112.5) && (thisAngleind > -157.5) ) )
                                newAngleind = 45;
                        if ( ( (thisAngleind > 67.5) && (thisAngleind < 112.5) ) || ( (thisAngleind < -67.5) && (thisAngleind > -112.5) ) )
                                newAngleind = 90;
                        if ( ( (thisAngleind > 112.5) && (thisAngleind < 157.5) ) || ( (thisAngleind < -22.5) && (thisAngleind > -67.5) ) )
                                newAngleind = 135;

                        edgeDirind[row][col] = newAngleind;           // Store the approximate edge direction of each pixel in one array
                }
        }
        
std::cout<<"At edge writing loop"<<std::endl;
/* Trace along all the edges in the image */
        for (row = 0; row < W; row++) 
	{
        	for (col = 0; col < H; col++) 
		{
                        edgeEnd = false;
                        if (gradientcol[row][col] > upperThreshold) 
			{      
                                /* Switch based on current pixel's edge direction*/

                                switch (edgeDircol[row][col])
				{
                                        case 0:
                                                findEdgecol(0, 1, row, col, 0, lowerThreshold);
                                                break;
                                        case 45:
                                                findEdgecol(1, 1, row, col, 45, lowerThreshold);
                                                break;
                                        case 90:
                                                findEdgecol(1, 0, row, col, 90, lowerThreshold);
                                                break;
                                        case 135:
                                                findEdgecol(1, -1, row, col, 135, lowerThreshold);
                                                break;
                                        default :
                                                data1collection[row][col]=0;
                                                break;
                                }
                        }
                        else 
			{
                                data1collection[row][col]=0;
                        }
                }
        }



        for (row = 0; row < W; row++) 
	{
        	for (col = 0; col < H; col++) 
		{
                        edgeEnd = false;
                        if (gradientind[row][col] > upperThreshold) 
			{      
                                /* Switch based on current pixel's edge direction*/

                                switch (edgeDirind[row][col])
				{
                                        case 0:
                                                findEdgeind(0, 1, row, col, 0, lowerThreshold);
                                                break;
                                        case 45:
                                                findEdgeind(1, 1, row, col, 45, lowerThreshold);
                                                break;
                                        case 90:
                                                findEdgeind(1, 0, row, col, 90, lowerThreshold);
                                                break;
                                        case 135:
                                                findEdgeind(1, -1, row, col, 135, lowerThreshold);
                                                break;
                                        default :
                                                data1induction[row][col]=0;
                                                break;
                                }
                        }
                        else 
			{
                                data1induction[row][col]=0;
                        }
                }
        }
        /* Suppress any pixels not changed by the edge tracing */
        for (row = 0; row < W; row++) {
                for (col = 0; col < H; col++) {
                        /* If a pixel's grayValue is not black or white make it black*/
                        if( (data1collection[row][col] != 255) && (data1collection[row][col] != 0))
                                data1collection[row][col]= 0;
                               /* std::cout<<data1[row][col]<<",";*/
                }
                /*std::cout<<""<<std::endl;*/
        }

	for (row = 1; row < W - 1; row++) {
                for (col = 1; col < H - 1; col++) {
                        if (data1collection[row][col] == 255) {             // Check to see if current pixel is an edge
                                /* Switch based on current pixel's edge direction */
                                switch (edgeDircol[row][col]) {
                                        case 0:
                                                suppressNonMaxcol( 1, 0, row, col, 0, lowerThreshold);
                                                break;
                                        case 45:
                                                suppressNonMaxcol( 1, -1, row, col, 45, lowerThreshold);
                                                break;
                                        case 90:
                                                suppressNonMaxcol( 0, 1, row, col, 90, lowerThreshold);
                                                break;
                                        case 135:
                                                suppressNonMaxcol( 1, 1, row, col, 135, lowerThreshold);
                                                break;
                                        default :
                                                break;
                                }
                        }
                }
        }

        /* Suppress any pixels not changed by the edge tracing */
        for (row = 0; row < W; row++) {
                for (col = 0; col < H; col++) {
                        /* If a pixel's grayValue is not black or white make it black*/
                        if( (data1induction[row][col] != 255) && (data1induction[row][col] != 0))
                                data1induction[row][col]= 0;
                               /* std::cout<<data1[row][col]<<",";*/
                }
                /*std::cout<<""<<std::endl;*/
        }

	for (row = 1; row < W - 1; row++) {
                for (col = 1; col < H - 1; col++) {
                        if (data1induction[row][col] == 255) {             // Check to see if current pixel is an edge
                                /* Switch based on current pixel's edge direction */
                                switch (edgeDirind[row][col]) {
                                        case 0:
                                                suppressNonMaxind( 1, 0, row, col, 0, lowerThreshold);
                                                break;
                                        case 45:
                                                suppressNonMaxind( 1, -1, row, col, 45, lowerThreshold);
                                                break;
                                        case 90:
                                                suppressNonMaxind( 0, 1, row, col, 90, lowerThreshold);
                                                break;
                                        case 135:
                                                suppressNonMaxind( 1, 1, row, col, 135, lowerThreshold);
                                                break;
                                        default :
                                                break;
                                }
                        }
                }
        }

    

std::cout<<"At output image loop"<<std::endl;
unsigned char *outPixcol = new unsigned char [H*W];
unsigned char *outPixind = new unsigned char [H*W];

      float cellcol, pixcol=0, maxCellcol=0;
      float cellind, pixind=0, maxCellind=0;
      for (int y = 0; y < H; ++y){
        for (int x = 0; x < W; ++x){
          cellcol = (int)(data1collection[x][y]);
          cellind =(int)(data1induction[x][y]);
          if (cellcol > maxCellcol){
            maxCellcol = cellcol;
          }
          if (cellind > maxCellind){
            maxCellind = cellind;
          }
        }
      }
        for (row = 0; row <H ; row++) {
        	for (col= W-1; col >=0; col--) {
       /*                std::cout<<data1[row][col]<<",";*/
			if(maxCellcol>0)
            		pixcol = (int)((data1collection[col][row]/maxCellcol)*255);
			if(maxCellind>0)
            		pixind = (int)((data1induction[col][row]/maxCellind)*255);
                     	outPixcol[row*W+(W-col-1)]=pixcol;
                     	outPixind[row*W+(W-col-1)]=pixind;
                }
        /*       std::cout<<""<<std::endl;*/
        }


std::ostringstream fn;
fn<<"collection_bmpfile"<<iterator<<".bmp";
std::string filenamecol=fn.str();
const char* filename1col = filenamecol.c_str();
SaveBMPFile(filename1col, outPixcol,W,H);
delete [] outPixcol;

std::ostringstream fn1;
fn1<<"induction_bmpfile"<<iterator<<".bmp";
std::string filenameind=fn1.str();
const char* filename1ind = filenameind.c_str();
SaveBMPFile(filename1ind, outPixind,W,H);
delete [] outPixind;
iterator++;


  
}//end produce loop
}//end namespace edge

void edge::Edge::SaveBMPFile(const char *fileName, unsigned char *pix, int dx, int dy)
{
  std::ofstream bmpFile(fileName, std::ios::binary);
  bmpFile.write("B", 1);
  bmpFile.write("M", 1);
  int bitsOffset = 54 +256*4;
  int size = bitsOffset + dx*dy; //header plus 256 entry LUT plus pixels
  bmpFile.write((const char *)&size, 4);
  int reserved = 0;
  bmpFile.write((const char *)&reserved, 4);
  bmpFile.write((const char *)&bitsOffset, 4);
  int bmiSize = 40;
  bmpFile.write((const char *)&bmiSize, 4);
  bmpFile.write((const char *)&dx, 4);
  bmpFile.write((const char *)&dy, 4);
  short planes = 1;
  bmpFile.write((const char *)&planes, 2);
  short bitCount = 8;
  bmpFile.write((const char *)&bitCount, 2);
  int i, temp = 0;
  for (i=0; i<6; i++)
    bmpFile.write((const char *)&temp, 4);  // zero out optional color info
  /* write a linear LUT*/
  char lutEntry[4]; // blue,green,red
  lutEntry[3] = 0;  // reserved part
  for (i=0; i<256; i++)
    {
      lutEntry[0] = lutEntry[1] = lutEntry[2] = i;
      bmpFile.write(lutEntry, sizeof lutEntry);
    }
  /* write the actual pixels*/
  bmpFile.write((const char *)pix, dx*dy);
}
 
namespace edge{
DEFINE_ART_MODULE(Edge)
}//end namespace
