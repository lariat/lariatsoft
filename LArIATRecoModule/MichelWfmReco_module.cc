////////////////////////////////////////////////////////////////////////
// Class:       MichelWfmReco
// Module Type: producer
// File:        MichelWfmReco_module.cc
//
// This module is used to perform some ID and reconstruction of PMT
// waveforms from stopping/decaying muons (primarily in the Michel 
// trigger sample).
//
// Eventually it may be used to create a new data product related to 
// Michel events, but for now, it does not add to the data file.
//
// Output histograms include:
//  - # hits found in each waveform
//  - amplitude of Michel-candidate pulses
//  - integrated charge of Michel candidates (100ns window)
//  - time difference between 1st and 2nd pulse
//    when exactly two pulses are found
//
// Authors: William Foreman, wforeman@uchicago.edu
//
// Generated at Wed Jul 15 13:09:43 2015 by William Foreman using artmod
// from cetpkgsupport v1_08_06.
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

//C++ Includes
#include <iostream>
#include <fstream>
#include <vector>
#include <memory>
#include <utility>

//ROOT Includes
#include <TH1F.h>
#include <TTree.h>

// LArSoft Includes
#include "Utilities/AssociationUtil.h"
#include "RawData/TriggerData.h"

//LAriatSoft Includes
#include "RawDataUtilities/TriggerDigitUtility.h"
#include "LArIATRecoAlg/OpHitBuilderAlg.h"
#include "LArIATRecoAlg/TriggerFilterAlg.h"
#include "Utilities/DatabaseUtilityT1034.h"


class MichelWfmReco;

class MichelWfmReco : public art::EDProducer {
public:
  explicit MichelWfmReco(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MichelWfmReco(MichelWfmReco const &) = delete;
  MichelWfmReco(MichelWfmReco &&) = delete;
  MichelWfmReco & operator = (MichelWfmReco const &) = delete;
  MichelWfmReco & operator = (MichelWfmReco &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Name of the module producing the triggers
  std::string fTriggerUtility;

  // Switch to use the trigger filter or not
  bool            bUseTriggerFilter;
  bool            bVerbose;
  float           V1751PostPercent;
  std::string     fInputModule;
  std::string     fInstanceName;

  // Alg objects
  OpHitBuilderAlg   fOpHitBuilderAlg; 
  TriggerFilterAlg  fTrigFiltAlg;

  // Variables
  Double_t    Timestamp;
  Double_t    DeltaTime;
  Int_t       NumHits;
  Double_t    Amplitude;
  Double_t    Charge_100ns; 

  // Histograms
  TH1F* h_NumOpHits;
  TH1F* h_DeltaTime;
  TH1F* h_Amplitude;
  TH1F* h_Charge100ns;
  
  // TTree info
  TTree* MichelDataTree;
  TBranch* b_Timestamp;
  TBranch* b_NumHits;
  TBranch* b_DeltaTime;
  TBranch* b_Amplitude;
  TBranch* b_Charge_100ns;

};



MichelWfmReco::MichelWfmReco(fhicl::ParameterSet const & p)
: fOpHitBuilderAlg(p), fTrigFiltAlg(p)
{

  // Configures the ROOT histograms
  this->reconfigure(p);
  
  // Produces the LArSoft object to be outputted
  // (none for now!) 
  
}


void MichelWfmReco::produce(art::Event & e)
{

  std::cout<<"New event --------------------------------\n";

  // Set up loop over triggers in the inputted ROOT file
  //rdu::TriggerDigitUtility tdu(e, fTriggerUtility);

  // Defint the vector of associations to be saved
  // (none yet!)

  std::vector<short> ETL_waveform;
  short PostPercentMark;
  Int_t NSamples;

  // get the OpDetPulses; skip if empty
  art::Handle< std::vector< raw::OpDetPulse >> WaveformHandle;
  e.getByLabel(fInputModule,fInstanceName,WaveformHandle);
  
  //art::PtrVector<raw::OpDetPulse> OpPulses = e.TriggerOpDetPulsesPtr(trig);
  
  if( (int)WaveformHandle->size() == 0 )
  {
    std::cout<<"OpDetPulses size = 0 -- skipping event\n";
    return;
  }

  std::cout<<"WaveformHandle->size() = "<<WaveformHandle->size()<<"\n";

  // loop through pulse and grab the ETL
  for( int pulse_index = 0; pulse_index < (int)WaveformHandle->size(); pulse_index++){
    art::Ptr< raw::OpDetPulse > ThePulsePtr(WaveformHandle,pulse_index);
    raw::OpDetPulse ThePulse = *ThePulsePtr;
    if( ThePulse.OpChannel() == 1) {
      ETL_waveform = ThePulse.Waveform();
      Timestamp = (double(ThePulse.FirstSample())*8.)/1.0e09;
      NSamples = ETL_waveform.size();
      PostPercentMark = NSamples*V1751PostPercent;
      std::cout<<"ETL pulse recorded: Nsamples = "<<NSamples<<", trigger time at "<<PostPercentMark<<"  Timestamp: "<<Timestamp<<"\n";
    }
  }
    
  // filter for the MICHEL trigger pattern (note that for some runs,
  // particularly for those with the optimized Michel trigger setup, 
  // unfortunately the trigger inputs were not being saved and thus 
  // the filter won't work).
  
  bool isMichel = 1; 
  /*
  if (bUseTriggerFilter){
    std::string myFilter = "+MICHEL";
    isMichel = fTrigFiltAlg.doesTriggerPassFilter( thisTrigger, myFilter ); 
  } else {
    isMichel = 1;
  }
  */
  
  if ( !isMichel ) return;

  // Initialize variables to be added to tree
  NumHits     = -9;
  DeltaTime   = -99.;
  Amplitude   = -99.;
  Charge_100ns= -99.;

  // perform hit-finding/filtering
  std::vector<short> hit_times = fOpHitBuilderAlg.GetHits(ETL_waveform);
  NumHits = hit_times.size();
  std::cout << "We found "<<NumHits<<" hits\n";
  for (int i=0; i<NumHits; i++) std::cout<<"   "<<i<<"    t = "<<hit_times[i]<<"\n";

  // fill Nhits histo
  h_NumOpHits ->Fill(NumHits);
        
  // Filter:
  // if there were only 2 hits (one before PostPercent, one ~at PostPercent within 1%) 
  if( (NumHits == 2) && (hit_times[0] < PostPercentMark) && ( abs(hit_times[1]-PostPercentMark) <= 0.01*NSamples) && (Timestamp >= 5.3)){
    std::cout << "    passes Michel cut \n";
    DeltaTime = hit_times[1] - hit_times[0];
    h_DeltaTime->Fill(DeltaTime);
        
    // calculate integral of Michel candidate pulse
    std::vector<double> hit_info = fOpHitBuilderAlg.IntegrateHit(ETL_waveform, hit_times[1]);
    
    Amplitude     = hit_info[0];
    Charge_100ns  = hit_info[1];
    
    h_Amplitude->Fill(Amplitude);
    h_Charge100ns->Fill(Charge_100ns); 

  }
        
  MichelDataTree->Fill();
    
}

void MichelWfmReco::beginJob()
{
  // Opens up the file service to read information from the ROOT file input
  art::ServiceHandle<art::TFileService> tfs;

  MichelDataTree        = tfs->make<TTree>("MichelDataTree","MichelDataTree");
  b_Timestamp           = MichelDataTree->Branch("Timestamp",&Timestamp,"Timestamp/D");
  b_NumHits             = MichelDataTree->Branch("NumHits",&NumHits,"NumHits/I");
  b_DeltaTime           = MichelDataTree->Branch("DeltaTime",&DeltaTime,"DeltaTime/D");
  b_Amplitude           = MichelDataTree->Branch("Amplitude",&Amplitude,"Amplitude/D");
  b_Charge_100ns        = MichelDataTree->Branch("Charge_100ns",&Charge_100ns,"Charge_100ns/D");
  
  h_NumOpHits           = tfs->make<TH1F>("OpHitsPerEvent"    , "OpHitsPerEvent",     10,    0., 10.);
  h_NumOpHits           ->GetXaxis()->SetTitle("Num hits");
  h_NumOpHits           ->GetYaxis()->SetTitle("Counts");

  h_DeltaTime           = tfs->make<TH1F>("DeltaTime"         , "DeltaTime",          700,    0., 7000.);
  h_DeltaTime           ->GetXaxis()->SetTitle("Time difference in two-hit events");
  h_DeltaTime           ->GetYaxis()->SetTitle("Counts");

  h_Amplitude           = tfs->make<TH1F>("Amplitude"         , "Amplitude",          5000,   0., 500.);
  h_Amplitude           ->GetXaxis()->SetTitle("Amplitude of Michel pulse (ADC)");
  h_Amplitude           ->GetYaxis()->SetTitle("Counts");
  
  h_Charge100ns          = tfs->make<TH1F>("Charge100ns"         , "Charge100ns",      1000,  0., 20000.);
  h_Charge100ns          ->GetXaxis()->SetTitle("Integrated prompt light, 100ns (ADC*ns)");
  h_Charge100ns          ->GetYaxis()->SetTitle("Counts");
}

void MichelWfmReco::beginRun(art::Run & r)
{
  fTrigFiltAlg.loadXMLDatabaseTable( r.run() ); 
}

void MichelWfmReco::beginSubRun(art::SubRun & sr)
{
}

void MichelWfmReco::endJob()
{
}

void MichelWfmReco::endRun(art::Run & r)
{
}

void MichelWfmReco::endSubRun(art::SubRun & sr)
{
}

void MichelWfmReco::reconfigure(fhicl::ParameterSet const & p)
{
  // Pass name of TriggerUtility
  fTriggerUtility         = p.get< std::string >("TriggerUtility","FragmentToDigit");
  bUseTriggerFilter       = p.get< bool >("UseTriggerFilter","false");
  bVerbose                = p.get< bool >("Verbosity","false");
  fInputModule            = p.get< std::string >("InputModule","daq");
  fInstanceName           = p.get< std::string >("InstanceName","");
  V1751PostPercent        = p.get< float >("V1751PostPercent",0.3);
  
}

void MichelWfmReco::respondToCloseInputFile(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToCloseOutputFiles(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToOpenInputFile(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToOpenOutputFiles(art::FileBlock const & fb)
{
}

DEFINE_ART_MODULE(MichelWfmReco)
