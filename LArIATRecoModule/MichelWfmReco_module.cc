////////////////////////////////////////////////////////////////////////
// Class:       MichelWfmReco
// Module Type: producer
// File:        MichelWfmReco_module.cc
//
// This module is used to perform some ID and reconstruction of PMT
// waveforms from stopping/decaying muons (primarily in the Michel 
// trigger sample).
//
// Eventually it may be used to create a new data product related to 
// Michel events, but for now, it does not add to the data file (despite
// being a producer).
//
// Authors: William Foreman, wforeman@uchicago.edu
//
// Generated at Wed Jul 15 13:09:43 2015 by William Foreman using artmod
// from cetpkgsupport v1_08_06.
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

//C++ Includes
#include <iostream>
#include <fstream>
#include <vector>
#include <memory>
#include <utility>

//ROOT Includes
#include <TF1.h>
#include <TH1F.h>
#include <TH1I.h>
#include <TH2F.h>
#include <TH3F.h>
#include <TTree.h>

// LArSoft Includes
#include "lardataobj/RawData/TriggerData.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/AnalysisBase/ParticleID.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/RawData/TriggerData.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"

//LAriatSoft Includes
#include "RawDataUtilities/TriggerDigitUtility.h"
#include "LArIATRecoAlg/OpHitBuilderAlg.h"
#include "LArIATRecoAlg/TriggerFilterAlg.h"
#include "Utilities/DatabaseUtilityT1034.h"


class MichelWfmReco;

class MichelWfmReco : public art::EDProducer {
public:
  explicit MichelWfmReco(fhicl::ParameterSet const & pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MichelWfmReco(MichelWfmReco const &) = delete;
  MichelWfmReco(MichelWfmReco &&) = delete;
  MichelWfmReco & operator = (MichelWfmReco const &) = delete;
  MichelWfmReco & operator = (MichelWfmReco &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & pset) ;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;
  
  // Custom functions
  bool IsPointInFiducialVolume(TVector3);
  bool IsHitAtTrigger(short, short, int, float);

private:

  // Name of the module producing the triggers
  std::string fTriggerUtility;

  // Tunable parameters from fcl
  bool                bUseTriggerFilter;
  bool                bUseTrackInformation;
  std::string         fDAQModule;
  std::string         fTrackModule;
  std::string         fParticleIDModule;
  std::string         fTrackCalModule;
  std::string         fInstanceName;
  float               fTimestampCut;
  short               fGateDelay;
  short               fBaselineWindowLength;
  short               fPromptWindowLength;
  short               fFullWindowLength;
  std::vector<short>  fIntegrationWindows;
  short               fPrePulseBaselineFit;
  short               fPromptLightDtCut;
  short               fPrePulseDisplay;
  float               fTriggerTolerancePercent;
  float               fFiducialMargin_X;
  float               fFiducialMargin_Y;
  float               fFiducialMargin_Z; 
  float               fSinglePE;
  float               fAveWfmCut_Dt;
  bool                fCorrectAveWfms;
  bool                fSaveHitWfmsToTree;
  bool                fSaveAllTrackInfoToTree;
  float               fHitTimeCutoffLow;
  float               fHitTimeCutoffHigh;
  bool                fUsePrepulseFit;
  float               fMvPerADC;
  float               fHitPromptPEThreshLow;
  float               fLY;

  // Alg objects
  OpHitBuilderAlg     fOpHitBuilderAlg; 
  OpHitBuilderAlg     fOpHitBuilderAlg_aveMichel;
  OpHitBuilderAlg     fOpHitBuilderAlg_aveBG;
  OpHitBuilderAlg     fOpHitBuilderAlg_aveBG_lowPromptPE;
  OpHitBuilderAlg     fOpHitBuilderAlg_aveMIP;
  TriggerFilterAlg    fTrigFiltAlg;

  // Variables/vectors
  int                   iEvent;
  bool                  GotETL;
  bool                  flag;
  std::vector<short>    PMT_wfm;
  short                 PostPercentMark;
  int                   NSamples;
  int                   MuTrackIndex;
  TVector3              region_centerpoint;
  float                 region_radius;
  std::vector<float>    hit_info;
  std::vector<TVector3> vTrackVertex;
  std::vector<TVector3> vTrackEnd;
  TVector3              MuTrackVertex;
  TVector3              MuTrackEnd;
  int                   HitWaveformBins;
  char                  buffer[200];
  raw::OpDetPulse       ETL_opdetpulse;
  int                   N_Events;
  int                   N_MichelCandidates;
  int                   N_MichelNonBG;
  int                   N_PEs;
  float                 T_PEs;
  size_t                hit_i;
  int                 closest_track_i;
  float                 closestSoFar;
  float                 resR_histRange;

  // Histograms
  TH1F* h_EventTypeCount;
  TH1F* h_Michel_IsInSignal;
  TH1F* h_TimeStructure;
  TH1I* h_NumOpHits;
  TH2I* h_NumOpHits_vs_NumTracks;
  TH1I* h_NumOpHits_beam;
  TH1I* h_NumOpHits_offbeam;
  TH2F* h_dT_vs_MuPE_100ns;
  TH2F* h_MuPf_100_250_vs_MuPE250ns;
  TH2F* h_dT_vs_MuPf_100_250;
  TH2F* h_PE100ns_vs_MuPf_100_250;
  TH1F* h_dT;
  TH1F* h_dT_PEcut;
  TH1F* h_dT_PEcut_MuPEcut;
  TH1F* h_dT_PEcutLow;
  TH1F* h_dT_PEcutBelow20pe;
  TH1F* h_dT_PEcutBelow20pe_stopTrk;
  TH1F* h_dT_PEcutBelow20pe_thruTrk;
  TH1F* h_dT_BkgCut;
  TH1F* h_dT_stoppingMu;
  TH2F* h_dT_vs_Energy;
  TH2F* h_dT_vs_Energy_stopTrk;

  TH1F* h_Amplitude;
  TH1F* h_HitTime;
  TH1F* h_HitTime_beam;
  TH1F* h_HitAmplitude;
  TH1F* h_HitPE_100ns;
  TH1F* h_PE_100ns;
  TH1F* h_PE_100ns_popCut;
  TH1F* h_PE_100ns_popCut_DtCut;
  TH1F* h_PE_100ns_stoppingMu;
  TH1F* h_PE_Total;
  TH1F* h_PE_Total_popCut;
  TH1F* h_PE_Total_popCut_DtCut;
  TH1F* h_PE_100ns_region;
  TH1F* h_PE_Total_region;
  TH1F* h_Energy_region;
  TH1F* h_PE_Total_region_dTcut;
  TH1F* h_Energy_region_dTcut;
  TH2F* h_Pf_vs_PE_Total;
  TH2F* h_Pf_vs_PE_Total_Michel;
  TH2F* h_Pf_vs_Energy;
  TH2F* h_Pf_vs_Energy_Michel;
  TH2F* h_Pf_vs_Energy_LowE;
  TH2F* h_Pf_100_500_vs_PE_Total;
  TH2F* h_Pf_100_500_vs_PE_Total_Michel;
  TH2F* h_Pf_100_500_vs_PE_500ns;
  TH2F* h_Pf_100_500_vs_PE_500ns_BeamPreTrig;
  TH2F* h_Pf_100_500_vs_PE_500ns_Michel;
  TH2F* h_Pf_100_500_vs_PE_500ns_Mu;
  TH2F* h_Pf_100_1000_vs_PE_Total;
  TH2F* h_Pf_100_500_vs_Energy;
  TH2F* h_Pf_100_500_vs_Energy_Michel;
  TH2F* h_Pf_100_1000_vs_Energy;
  TH2F* h_PE_100ns_vs_Amplitude;
  TH2F* h_PE100ns_vs_Amplitude_BeamPreTrig;
  TH1F* h_TrackVertex_x;
  TH1F* h_TrackVertex_y;
  TH1F* h_TrackVertex_z;
  TH1F* h_TrackEnd_x;
  TH1F* h_TrackEnd_y;
  TH1F* h_TrackEnd_z;
  TH2F* h_TrackNode_zx;
  TH2F* h_TrackNode_zy;
  TH2F* h_TrackEnergy_vs_PE_Total;
  TH2I* h_InFiducialVolume;
  TH1F* h_SecondTrackOffset;
  TH2F* h_ResRange_dEdx_mu;
  TH2F* h_ResRange_dEdx_michel;
  TH1F* h_AverageWaveform_Michel;
  TH1F* h_AverageWaveform_BG;
  TH1F* h_AverageWaveform_BG_lowPromptPE;
  TH1F* h_AverageWaveformMIP;

  // TTree
  TTree* MichelDataTree;
  
  // Storing run information
  int                     RunNumber;
  int                     SubRunNumber;
  int                     EventNumber;
  float                   Timestamp;

  // Storing optical hit information
  int                     NumHits;
  std::vector<short>      vHitTimes;
  std::vector<float>      vHitAmplitude;
  std::vector<float>      vHitADC_100ns;
  std::vector<float>      vHitADC_250ns;
  std::vector<float>      vHitADC_500ns;
  std::vector<float>      vHitADC_1000ns;
  std::vector<float>      vHitADC_Total;
  std::vector<float>      vHitPE_100ns;
  std::vector<float>      vHitPE_250ns;
  std::vector<float>      vHitPE_500ns;
  std::vector<float>      vHitPE_1000ns;
  std::vector<float>      vHitPE_Total;
  std::vector<float>      vPrepulseBaseline;
  std::vector<float>      vPrepulseRMS;
  std::vector<float>      vPrepulseSlowNorm;
  std::vector<float>      vPrepulseSlowTau;
  std::vector<float>      vPrepulseReducedChi2;
  std::vector<float>      vHitPf;
  std::vector<bool>       vIsInSignalPopulation;
  std::vector<bool>       vIsInBGPopulation;
  std::vector<bool>       vHitIsAtTrigger; 
  std::vector<short>      HitWaveform; 
  int                     HitWaveformIndex;
  float                   WaveformBaseline;
  float                   WaveformBaselineRMS;
  int                     IsBeamEvent;
  bool                    IsCleanBeamWaveform;
  float                   dT;
  float                   Amplitude;
  float                   ADC_100ns;
  float                   ADC_250ns; 
  float                   ADC_500ns;
  float                   ADC_1000ns;
  float                   ADC_Total;
  float                   PE_100ns;
  float                   PE_250ns; 
  float                   PE_500ns;
  float                   PE_1000ns;
  float                   PE_Total;
  float                   Pf;
  
  // Storing track infornatuib
  int                     NumTracks;
  std::vector<float>      vTrackVertex_x;
  std::vector<float>      vTrackVertex_y;
  std::vector<float>      vTrackVertex_z;
  std::vector<float>      vTrackEnd_x;
  std::vector<float>      vTrackEnd_y;
  std::vector<float>      vTrackEnd_z;
  std::vector<bool>       vIsTrackStopping;
  std::vector<bool>       vIsTrackPassing;
  std::vector<bool>       vIsTrackContained;
  std::vector<int>        vTrackPID;
  std::vector<float>      vTrackPIDA;
  std::vector<float>      vTrackEnergy;
  std::vector<float>      vTrackLength;
  std::vector< size_t >   vTrack_NumberdEdx;
  std::vector< float >    Mu_ResR;
  std::vector< float >    Michel_ResR;
  std::vector< float >    Mu_dEdx;
  std::vector< float >    Michel_dEdx;

  bool                    IsSinglePassingTrack;
  bool                   IsSingleStoppingTrack;
  float                   StoppingTrackZenithAngle;
  float                   PassingTrackZenithAngle;
  float                   MuTrackVertex_x;
  float                   MuTrackVertex_y;
  float                   MuTrackVertex_z;
  float                   MuTrackEnd_x;
  float                   MuTrackEnd_y;
  float                   MuTrackEnd_z;
  float                   MuTrackLength;
  float                   MuTrackEnergy;
  int                     MuAmplitude;
  float                   MuADC_100ns;
  float                   MuTrackEnd_DistToCenter;
  float                   SecondTrackProximity;
  float                   SecondTrackLength;
  float                   SecondTrackEnergy;
  int                     IsSecondTrackContained;
  

};



MichelWfmReco::MichelWfmReco(fhicl::ParameterSet const & pset)
: fOpHitBuilderAlg(pset), 
fOpHitBuilderAlg_aveMichel(pset), 
fOpHitBuilderAlg_aveBG(pset),
fOpHitBuilderAlg_aveBG_lowPromptPE(pset), 
fOpHitBuilderAlg_aveMIP(pset), 
fTrigFiltAlg(pset)
{

  // Configures the ROOT histograms
  this->reconfigure(pset);
  
  N_Events = 0;
  N_MichelCandidates = 0;
  N_MichelNonBG = 0;
  N_PEs = 0;
  T_PEs = 0;

  // Resize the hit_info vector to accomodate the user-specified
  // number of different integration window lengths (+ amplitude)
  hit_info.resize(fIntegrationWindows.size()+1);
  
  resR_histRange = 30.;

  if(!bUseTrackInformation) fSaveAllTrackInfoToTree = false;

  // Produces the LArSoft object to be outputted
  // (none for now!) 
 
  // TO DO: make this a fcl parameter 
  region_centerpoint.SetXYZ(23.5,0.,45.);
  region_radius = 15.;

  // Some instances of OpHitBuilder were created solely 
  // to save summed/average waveforms:
  fOpHitBuilderAlg_aveMichel.fAddHitsToAverageWaveform        = true;  
  fOpHitBuilderAlg_aveBG.fAddHitsToAverageWaveform       = true;  
  fOpHitBuilderAlg_aveBG_lowPromptPE.fAddHitsToAverageWaveform  = true;  
  fOpHitBuilderAlg_aveMIP.fAddHitsToAverageWaveform     = true;  
 
  // Switch to apply baseline correction (prepulse
  // expeonential fit method) to averaged waveforms:
  if(fCorrectAveWfms){ 
    fOpHitBuilderAlg_aveMichel.fUsePrepulseFit       = true;  
    fOpHitBuilderAlg_aveBG.fUsePrepulseFit       = true;  
    fOpHitBuilderAlg_aveBG_lowPromptPE.fUsePrepulseFit       = true;  
    fOpHitBuilderAlg_aveMIP.fUsePrepulseFit     = true;  
  } else {
    fOpHitBuilderAlg_aveMichel.fUsePrepulseFit       = false;  
    fOpHitBuilderAlg_aveBG.fUsePrepulseFit       = false;  
    fOpHitBuilderAlg_aveBG_lowPromptPE.fUsePrepulseFit       = false;  
    fOpHitBuilderAlg_aveMIP.fUsePrepulseFit     = false;  
  }
  

  HitWaveformBins = (int)fPrePulseDisplay+(int)fFullWindowLength;
  HitWaveform.reserve(HitWaveformBins);

}


void MichelWfmReco::produce(art::Event & e)
{
  iEvent++;

  // Initialize variables to be saved into tree
  TVector3                    vInit(-99.,-99.,-99.);
  NumHits                     = -9;
  RunNumber                   = -9;
  SubRunNumber                = -9;
  EventNumber                 = -9;
  Timestamp                   = -9.; 
  IsCleanBeamWaveform         = false;
  IsBeamEvent                 = -9;
  NumTracks                   = -9;
  MuTrackEnd_DistToCenter     = -9;
  IsSingleStoppingTrack       = false;
  IsSinglePassingTrack        = false;
  StoppingTrackZenithAngle    = -1;
  PassingTrackZenithAngle     = -1;
  MuTrackVertex               = vInit;
  MuTrackEnd                  = vInit;
  MuTrackVertex_x             = -99.;
  MuTrackVertex_y             = -99.;
  MuTrackVertex_z             = -99.;
  MuTrackEnd_x                = -99.;
  MuTrackEnd_y                = -99.;
  MuTrackEnd_z                = -99.;
  MuTrackLength               = -99.;
  MuTrackEnergy               = -99.;
  MuAmplitude                 = -99;
  MuADC_100ns              = -999.;
  dT                          = -99.;
  Amplitude                   = -99.;
  ADC_100ns                   = -9999.;
  ADC_250ns                   = -9999.;
  ADC_500ns                   = -9999.;
  ADC_1000ns                  = -9999.;
  ADC_Total                   = -99999.;
  PE_100ns                    = -9999.;
  PE_250ns                    = -9999.;
  PE_500ns                    = -9999.;
  PE_1000ns                   = -9999.;
  PE_Total                    = -99999.;
  Pf                          = -999.;
  WaveformBaseline            = -99.;
  WaveformBaselineRMS         = 999.;
  SecondTrackLength           = -9.;
  SecondTrackEnergy           = -9.;
  SecondTrackProximity        = -9.;
  IsSecondTrackContained      = -9;
  vHitTimes.clear();
  vHitAmplitude.clear();
  vHitADC_100ns.clear();
  vHitADC_250ns.clear();
  vHitADC_500ns.clear();
  vHitADC_1000ns.clear();
  vHitADC_Total.clear();
  vHitPE_100ns.clear();
  vHitPE_250ns.clear();
  vHitPE_500ns.clear();
  vHitPE_1000ns.clear();
  vHitPE_Total.clear();
  vHitPf.clear();
  vIsInSignalPopulation.clear();
  vIsInBGPopulation.clear();
  vPrepulseBaseline.clear();
  vPrepulseRMS.clear();
  vPrepulseSlowNorm.clear();
  vPrepulseSlowTau.clear();
  vPrepulseReducedChi2.clear();
  vHitIsAtTrigger.clear();
  vTrackVertex.clear();
  vTrackEnd.clear();
  vTrackVertex_x.clear();
  vTrackVertex_y.clear();
  vTrackVertex_z.clear();
  vTrackEnd_x.clear();
  vTrackEnd_y.clear();
  vTrackEnd_z.clear();
  vTrackEnergy.clear();
  vTrackLength.clear();
  vTrackPID.clear();
  vTrackPIDA.clear();
  Mu_dEdx.clear();
  Mu_ResR.clear();
  Michel_dEdx.clear();
  Michel_ResR.clear();
  vIsTrackStopping.clear();
  vIsTrackPassing.clear();
  vIsTrackContained.clear();
  closest_track_i = -9;

  if(fSaveHitWfmsToTree){
    for(unsigned int i=0; i<HitWaveform.size(); i++) HitWaveform[i] = 0;
    HitWaveformIndex = -9;
  }

  // Get run and event number
  RunNumber     = (int)e.run();
  SubRunNumber  = (int)e.subRun();
  EventNumber   = (int)e.event();
 

  // Filter for the MICHEL trigger pattern (note that for some runs, particularly for 
  // those with the optimized Michel trigger setup, unfortunately the trigger inputs 
  // were not being saved and thus the filter won't work).
  /*
  bool isMichel = 1; 
  if (bUseTriggerFilter){
    std::string myFilter = "+MICHEL";
    isMichel = fTrigFiltAlg.doesTriggerPassFilter( thisTrigger, myFilter ); 
  } else {
    isMichel = 1;
  }
  if ( !isMichel ) return;
  */

  // Get the OpDetPulses; skip event if empty
  art::Handle< std::vector< raw::OpDetPulse >> WaveformHandle;
  e.getByLabel(fDAQModule,fInstanceName,WaveformHandle);
  if( (int)WaveformHandle->size() == 0 ) {
    LOG_VERBATIM("MichelWfmReco") << "No optical detector data found, skipping the event.";
    return;
  } else {
    // If not empty, store ETL waveform
    GotETL = false;
    for( int ipulse = 0; ipulse < (int)WaveformHandle->size(); ipulse++){
      art::Ptr< raw::OpDetPulse > ThePulsePtr(WaveformHandle,ipulse);
      raw::OpDetPulse ThePulse = *ThePulsePtr;
      if( ThePulse.OpChannel() == 1) {
        ETL_opdetpulse  = ThePulse; 
        PMT_wfm    = ThePulse.Waveform();
        NSamples = PMT_wfm.size();
        Timestamp = (float(ThePulse.PMTFrame())*8.)/1.0e09;
        PostPercentMark = short(ThePulse.FirstSample()); 
        GotETL = true;
    
        LOG_VERBATIM("MichelWfmReco")
        << "PMT pulse recorded (" << NSamples << " samples, trigger at " << PostPercentMark << ")\n"
        << "Timestamp " << Timestamp << " sec";

        // Is clean beam waveform? (for testing out function)
        //IsCleanBeamWaveform = fOpHitBuilderAlg.IsCleanBeamWaveform(ThePulse);
      }
    }
  }
  // If we somehow didn't get the ETL, skip the event
  if( !GotETL ) return;
  
  N_Events++;

  // Classify as beam or non-beam event
  if ( (Timestamp >= 0)&&(Timestamp < fTimestampCut-0.1)){ IsBeamEvent = 1; h_EventTypeCount->Fill(0);}
  else if (Timestamp >= fTimestampCut+0.2) { IsBeamEvent = 0;}

  h_TimeStructure->Fill(Timestamp);

  //  Get waveform baseline/RMS
  std::vector<float> tmp = fOpHitBuilderAlg.GetBaselineAndRMS(PMT_wfm,0,fBaselineWindowLength);
  WaveformBaseline    = tmp[0];
  WaveformBaselineRMS = tmp[1];

  // Perform hit-finding/filtering, and store hit times into
  // a temporary vector (which will be replaced later after 
  // some filtering is done).
  std::vector<short> vHitTimesTmp = fOpHitBuilderAlg.GetHits(ETL_opdetpulse);
  NumHits = vHitTimesTmp.size();
 
  // For each hit, do all the needed reconstruction in single function call
  for (int i=0; i<NumHits; i++){
    if( i==0 ) hit_info = fOpHitBuilderAlg.GetHitInfo(PMT_wfm, vHitTimesTmp[i], 0, fIntegrationWindows);
    if( i >0 ) hit_info = fOpHitBuilderAlg.GetHitInfo(PMT_wfm, vHitTimesTmp[i], vHitTimesTmp[i-1], fIntegrationWindows);
   
    // Skip if prompt PE doesn't pass threshold
    if( hit_info[1]/fSinglePE < fHitPromptPEThreshLow ) {
      LOG_VERBATIM("MichelWfmReco") << "!! Hit doesn't pass promptPE cut, skipping.";
      continue;
    }

    vHitTimes       .push_back(vHitTimesTmp[i]);
    hit_i           = vHitTimes.size() - 1;       // iterator for easier tracking
    h_HitTime       ->Fill(vHitTimes[hit_i]);
    if(IsBeamEvent) h_HitTime_beam->Fill(vHitTimes[hit_i]);
    vHitAmplitude   .push_back(hit_info[0]);
    vHitADC_100ns   .push_back(hit_info[1]);
    vHitADC_250ns   .push_back(hit_info[2]);
    vHitADC_500ns   .push_back(hit_info[3]);
    vHitADC_1000ns  .push_back(hit_info[4]);
    vHitADC_Total   .push_back(hit_info[5]);
    vHitPE_100ns    .push_back(hit_info[1]/fSinglePE);
    vHitPE_250ns    .push_back(hit_info[2]/fSinglePE);
    vHitPE_500ns    .push_back(hit_info[3]/fSinglePE);
    vHitPE_1000ns   .push_back(hit_info[4]/fSinglePE);
    vHitPE_Total    .push_back(hit_info[5]/fSinglePE);
    vHitPf          .push_back(vHitADC_100ns[hit_i]/vHitADC_Total[hit_i]);
    vHitIsAtTrigger .push_back(IsHitAtTrigger(vHitTimes[hit_i],PostPercentMark,NSamples,fTriggerTolerancePercent));
    
    vPrepulseBaseline.push_back(fOpHitBuilderAlg.prepulse_baseline);
    vPrepulseRMS.push_back(fOpHitBuilderAlg.prepulse_rms);
    vPrepulseSlowNorm.push_back(fOpHitBuilderAlg.fit_SlowNorm);
    vPrepulseSlowTau.push_back(fOpHitBuilderAlg.fit_SlowTau); 
    vPrepulseReducedChi2.push_back(fOpHitBuilderAlg.fit_ReducedChi2);
    
    // Fill some histograms
    h_HitAmplitude  ->Fill(vHitAmplitude[hit_i]);
    h_HitPE_100ns   ->Fill(vHitPE_100ns[hit_i]);
    if(IsBeamEvent && vHitTimes[hit_i] < PostPercentMark - 500) {
      h_Pf_100_500_vs_PE_500ns_BeamPreTrig->Fill(vHitADC_100ns[hit_i]/vHitADC_500ns[hit_i],vHitPE_500ns[hit_i]);
      h_PE100ns_vs_Amplitude_BeamPreTrig  ->Fill(vHitPE_100ns[hit_i], vHitAmplitude[hit_i]);
    }

    float Pf_100_500 = vHitADC_100ns[hit_i]/vHitADC_500ns[hit_i];

    // If this is the trigger-associated hit outside beamwindow, add to PSD plots
    if( vHitIsAtTrigger[hit_i] && !IsBeamEvent ){
      h_Pf_100_500_vs_PE_500ns  ->Fill(Pf_100_500,vHitPE_500ns[hit_i]);
      h_Pf_100_500_vs_PE_Total  ->Fill(Pf_100_500,vHitPE_Total[hit_i]);
      h_Pf_100_500_vs_Energy    ->Fill(Pf_100_500,vHitPE_Total[hit_i]/fLY);
      h_Pf_100_1000_vs_PE_Total  ->Fill(vHitADC_100ns[hit_i]/vHitADC_1000ns[hit_i],vHitPE_Total[hit_i]);
      h_Pf_100_1000_vs_Energy   ->Fill(vHitADC_100ns[hit_i]/vHitADC_1000ns[hit_i],vHitPE_Total[hit_i]/fLY);
      h_Pf_vs_PE_Total           ->Fill(vHitPf[hit_i],vHitPE_Total[hit_i]);
      h_Pf_vs_Energy            ->Fill(vHitPf[hit_i],vHitPE_Total[hit_i]/fLY);
      h_Pf_vs_Energy_LowE       ->Fill(vHitPf[hit_i],vHitPE_Total[hit_i]/fLY);
    }
    
    // Separate into high-purity signal and BG ("Rn") groups
    // Line in "Pf_100_500 vs. PE_500" phase space
    TF1 f_SigLine("f_SigLine","-30.0*x + 55",0.,1.);
    TF1 f_BGLine("f_BGLine","-27.92*x + 42.62",0.,1.);
    if( vHitPE_100ns[hit_i] > 0 && vHitPf[hit_i] > 0 && vHitPf[hit_i] < 1. ) {
      if( vHitPE_500ns[hit_i] > f_SigLine.Eval(Pf_100_500) ) {
        vIsInSignalPopulation .push_back(true);
        vIsInBGPopulation     .push_back(false);
      } else if ( vHitPE_500ns[hit_i] < f_BGLine.Eval(Pf_100_500) ){
        vIsInSignalPopulation .push_back(false);
        vIsInBGPopulation     .push_back(true);
      } else {
        vIsInSignalPopulation .push_back(false);
        vIsInBGPopulation     .push_back(false);
      }
    }
    
    /* 
    // Line in PE (#,x) vs. amplitude (mV,y) space to cut out background. 
    TF1 f_PopulationCut("f_PopulationCut","1.714*x - 14.57",0.,10000.);
    if( vHitPE_Prompt[i] > 0.){
      if( vHitAmplitude[i] > f_PopulationCut.Eval(vHitPE_Prompt[i])){ 
        vIsInBGPopulation.push_back(1);
      } else {
        vIsInBGPopulation.push_back(0); 
      }
    }
    */
  
  } 

  // Redefine NumHits
  NumHits = vHitTimes.size();
  
  // If exactly 2 hits, measure their time difference
  if(NumHits == 2){
    dT = float(vHitTimes[1] - vHitTimes[0]);
    LOG_VERBATIM("MichelWfmReco") << "Exactly 2 hits.  dT = " << dT << " ns.";
    if( !IsBeamEvent ) {
      h_dT_vs_MuPE_100ns->Fill(dT,vHitPE_100ns[0]);
      if( dT > 500. ) h_Pf_100_500_vs_PE_500ns_Mu->Fill(vHitADC_100ns[0]/vHitADC_500ns[0],vHitPE_500ns[0]);
    }
  }

 
  // Is clean beam waveform?
  if( (IsBeamEvent)&&(NumHits == 1)&& vHitIsAtTrigger[0] ){
    IsCleanBeamWaveform = true;
  } else {
    IsCleanBeamWaveform = false;
  }
 

  if(bUseTrackInformation){ 
    
    // Get the tracks and their associated energy
    art::Handle< std::vector< recob::Track >> TrackHandle;
    e.getByLabel(fTrackModule,TrackHandle);
  
    // Fill tracklist... (not used right now)
    //std::vector< art::Ptr< recob::Track >> tracklist; 
    //if (e.getByLabel(fTrackModule,TrackHandle))
    //   {art::fill_ptr_vector(tracklist, trackListHandle);}

    NumTracks = (int)TrackHandle->size();

    LOG_VERBATIM("MichelWfmReco") << "Number of tracks: "<<NumTracks;
  
    // === Association between Calorimetry objects and Tracks ===
    art::FindManyP<anab::Calorimetry> fmcal(TrackHandle, e, fTrackCalModule);
    // === Association between PID objects and Tracks ===
    art::FindManyP<anab::ParticleID>  fmpid(TrackHandle, e, fParticleIDModule);
    
    // Loop through the track list and store their properties
    for( int track_index = 0; track_index < NumTracks; track_index++){
  
      // Get the recob::Track object and record its endpoint/vertex
      art::Ptr< recob::Track > TheTrackPtr(TrackHandle,track_index);
      recob::Track TheTrack = *TheTrackPtr;
      vTrackEnd       .push_back(TheTrack.End<TVector3>());
      vTrackVertex    .push_back(TheTrack.Vertex<TVector3>());
      vTrackLength    .push_back(TheTrack.Length());
      vTrackVertex_x  .push_back(TheTrack.Vertex().X());
      vTrackVertex_y  .push_back(TheTrack.Vertex().Y());
      vTrackVertex_z  .push_back(TheTrack.Vertex().Z());
      vTrackEnd_x     .push_back(TheTrack.End().X()); 
      vTrackEnd_y     .push_back(TheTrack.End().Y()); 
      vTrackEnd_z     .push_back(TheTrack.End().Z()); 

      // Is track stopping, passing, or contained?
      bool endIsInFid     = IsPointInFiducialVolume(TheTrack.End<TVector3>());
      bool vertexIsInFid  = IsPointInFiducialVolume(TheTrack.Vertex<TVector3>());
      bool temp_flag      = ((!endIsInFid && vertexIsInFid)||(endIsInFid && !vertexIsInFid));
      vIsTrackStopping    .push_back( temp_flag );
      vIsTrackPassing     .push_back( !endIsInFid && !vertexIsInFid);
      vIsTrackContained   .push_back( endIsInFid && vertexIsInFid );
      
      LOG_VERBATIM("MichelWfmReco")
        <<"  track "<<track_index<<", length "<<TheTrack.Length()<<"  vertex("
        << TheTrack.Vertex().X() <<"," 
        << TheTrack.Vertex().Y() << "," 
        << TheTrack.Vertex().Z() << ")->InFiducial()="
        << vertexIsInFid 
        << "   end("
        << TheTrack.End().X() <<"," 
        << TheTrack.End().Y() << "," 
        << TheTrack.End().Z() << ")->InFiducial()="
        << endIsInFid;
      
      
      h_InFiducialVolume->Fill(vertexIsInFid,endIsInFid);
      h_TrackNode_zx->Fill(TheTrack.Vertex().Z(),TheTrack.Vertex().X());
      h_TrackNode_zx->Fill((float)TheTrack.End().Z(),(float)TheTrack.End().X());
      h_TrackNode_zy->Fill((float)TheTrack.Vertex().Z(),(float)TheTrack.Vertex().Y());
      h_TrackNode_zy->Fill((float)TheTrack.End().Z(),(float)TheTrack.End().Y());
      

      // ################################################### 
      // ### Looping over calorimetry info for the track ###
      // ###   ([0] = induction, [1] = collection)
      if( fmcal.isValid() ){
        std::vector<art::Ptr<anab::Calorimetry> > calos = fmcal.at(track_index);
        vTrackEnergy.push_back(calos[1]->KineticEnergy());
        LOG_VERBATIM("MichelWfmReco") << "  KE = " << calos[1] -> KineticEnergy();
      } else {
        LOG_VERBATIM("MichelWfmReco") << "  KE = undefined";
        vTrackEnergy          .push_back(-99.);
      }
   
      // ################################################## 
      // ### Looping over PID information for the track ###
      // ###   ([0] = induction, [1] = collection)
      if (fmpid.isValid()){
        std::vector<art::Ptr<anab::ParticleID> > pids = fmpid.at(track_index);
        if (!pids[1]->PlaneID().isValid) {
          LOG_VERBATIM("MichelWfmReco") << "  pid["<<track_index<<"]: undefined";
          vTrackPID.push_back(-99); 
          vTrackPIDA.push_back(-99);
          continue;
        }
        vTrackPID.push_back(pids[1]->Pdg());
        vTrackPIDA.push_back(pids[1]->PIDA());
        LOG_VERBATIM("MichelWfmReco") << "  pid["<<track_index<<"]: "<<pids[1]->Pdg();
      } else {
        LOG_VERBATIM("MichelWfmReco") << "  pid["<<track_index<<"]: undefined";
        vTrackPID.push_back(-99);
        vTrackPIDA.push_back(-99);
      }

    } // End loop over tracks  


    // --------------------------------------
    // Higher-level track filtering:
    
    // Limit number of total tracks:
    if( NumTracks <= 4 ) {
      
      flag = false;
  
      // Cycle through tracks
      for( int i=0; i<NumTracks; i++){
          
        // Since we don't want to blindly trust that the endpoint and 
        // vertex have been assigned correctly, let's say whichever 
        // has a higher Y-value is the vertex (pretty reasonable 
        // assumption for cosmic muons).
        TVector3 vertex;
        TVector3 end;
        if( !IsBeamEvent ){
          if( vTrackVertex[i].Y() > vTrackEnd[i].Y()  ) { 
            vertex  = vTrackVertex[i]; 
            end     = vTrackEnd[i];
          } else {
            vertex  = vTrackEnd[i];
            end     = vTrackVertex[i];
          }
        // For BEAM events, whichever has lower Z value is vertex.
        } else {
          if( vTrackVertex[i].Z() < vTrackEnd[i].Z()  ) { 
            vertex  = vTrackVertex[i]; 
            end     = vTrackEnd[i];
          } else {
            vertex  = vTrackEnd[i];
            end     = vTrackVertex[i];
          }
          
        }
      
        // Fill histograms
        h_TrackEnd_x->Fill(end.X());
        h_TrackEnd_y->Fill(end.Y());
        h_TrackEnd_z->Fill(end.Z());
        h_TrackVertex_x->Fill(vertex.X());
        h_TrackVertex_y->Fill(vertex.Y());
        h_TrackVertex_z->Fill(vertex.Z());

        
        // If there's a single stopping track, fill Mu variables

        if( !flag && vIsTrackStopping[i] ) {      
          // If there was already a stopping track, this disqualifies 
          // the event.
          if( IsSingleStoppingTrack ){
            IsSingleStoppingTrack = 0;
            flag = true;
            MuTrackVertex     = vInit;
            MuTrackEnd        = vInit; 
            MuTrackVertex_x   = -99.;
            MuTrackVertex_y   = -99.;
            MuTrackVertex_z   = -99.;
            MuTrackEnd_x      = -99.;
            MuTrackEnd_y      = -99.;
            MuTrackEnd_z      = -99.;
            MuTrackLength     = -9.;
            MuTrackEnergy     = -9.;
            StoppingTrackZenithAngle = -9.;
          } else { 
            MuTrackIndex = i;
            IsSingleStoppingTrack = 1;
            MuTrackVertex     = vertex;
            MuTrackEnd        = end;
            MuTrackVertex_x   = MuTrackVertex.X();
            MuTrackVertex_y   = MuTrackVertex.Y();
            MuTrackVertex_z   = MuTrackVertex.Z();
            MuTrackEnd_x      = MuTrackEnd.X();
            MuTrackEnd_y      = MuTrackEnd.Y();
            MuTrackEnd_z      = MuTrackEnd.Z();
            MuTrackLength     = vTrackLength[i];
            MuTrackEnergy     = vTrackEnergy[i];
            TVector3 vert(0.,1.,0.);
            TVector3 tmp = (vertex-end);
            StoppingTrackZenithAngle = tmp.Angle(vert);
          }
        
        }
      }// <-- end loop over tracks 
    }// <-- endif(NumTracks = X)
 
    // Look for single passing tracks
    if( (NumTracks == 1)&&( vIsTrackPassing[0])) {
      IsSinglePassingTrack = 1;
      MuTrackIndex = 0;
      MuTrackVertex   = vTrackVertex[0];
      MuTrackEnd      = vTrackEnd[0];
      MuTrackVertex_x   = MuTrackVertex.X();
      MuTrackVertex_y   = MuTrackVertex.Y();
      MuTrackVertex_z   = MuTrackVertex.Z();
      MuTrackEnd_x      = MuTrackEnd.X();
      MuTrackEnd_y      = MuTrackEnd.Y();
      MuTrackEnd_z      = MuTrackEnd.Z();
      MuTrackLength   = vTrackLength[0];
      MuTrackEnergy   = vTrackEnergy[0];

      TVector3 vert(0.,1.,0.);
      TVector3 tmp = (MuTrackVertex-MuTrackEnd);
      PassingTrackZenithAngle = tmp.Angle(vert);  
    }
  
    // If there was a stopping "muon" and any other tracks check
    // to see if either of their endpoints are close to muon endpoint.
    if( IsSingleStoppingTrack && NumTracks > 1) {
      closestSoFar = 999;
      for( int i=0; i<NumTracks; i++){
        if( i != MuTrackIndex ){
          SecondTrackProximity = std::min( 
            (vTrackVertex[i] - MuTrackEnd).Mag(),
            (vTrackEnd[i]   - MuTrackEnd).Mag());
          if( SecondTrackProximity < closestSoFar ) {
            closestSoFar    = SecondTrackProximity;
            closest_track_i = i;
            IsSecondTrackContained = vIsTrackContained[i];
            SecondTrackLength = vTrackLength[i];
            SecondTrackEnergy = vTrackEnergy[i];
          }
          h_SecondTrackOffset->Fill(SecondTrackProximity);
        }
      }  
    }

    // If there was 1 stopping or 1 passing track, get light info for the "muon"
    if( (IsSingleStoppingTrack||IsSinglePassingTrack) && (NumHits > 0)&&(NumHits <= 2) ) {
      MuAmplitude = vHitAmplitude[0];
      MuADC_100ns = vHitADC_100ns[0];
    }


    // -------------------------------------------------
    // dE/dx
    //
    if( !IsBeamEvent && IsSingleStoppingTrack && fmcal.isValid() ){
        
        std::vector<art::Ptr<anab::Calorimetry> > calos_Mu = fmcal.at(MuTrackIndex);
        size_t              N_dEdx = calos_Mu[1]->dEdx().size();
        LOG_VERBATIM("MichelWfmReco") 
        <<"Beginning dE/dx scan of the mu-candidate track, dEdx().size() = "<<N_dEdx;
       
        // If we correctly assigned vertex/endpoint above,
        // go ahead and fill the dEdx and Residual Range containers
        if( vTrackVertex_y[MuTrackIndex] > vTrackEnd_y[MuTrackIndex] ){
          for(size_t i=0; i < N_dEdx; i++){
            Mu_ResR  .push_back(calos_Mu[1]->ResidualRange()[i]);
            Mu_dEdx  .push_back(calos_Mu[1]->dEdx()[i]);
            if(vTrackLength[MuTrackIndex] >= resR_histRange) h_ResRange_dEdx_mu ->Fill(Mu_ResR[i],Mu_dEdx[i]);
          }
        }

        // If a second track was found within 2cm of muon endpoint
        // also look at its dEdx
        if( closest_track_i >= 0 && SecondTrackProximity <= 2.)
        {
          std::vector<art::Ptr<anab::Calorimetry> > calos_Michel = fmcal.at(closest_track_i);
          size_t            N_dEdx = calos_Michel[1]->dEdx().size();
          LOG_VERBATIM("MichelWfmReco") 
          << "Beginning dE/dx scan of the secondary track, dEdx().size() = "<<N_dEdx;
          
          // In this case, we need to call the "vertex" whichever endpoint is
          // closest to the muon's endpoint
          float dv = (vTrackVertex[closest_track_i] -MuTrackEnd).Mag();
          float de = (vTrackEnd[closest_track_i]    -MuTrackEnd).Mag();
          // If larsoft got it right, great, things are normal
          if( dv < de ){
            for(size_t i=0; i < N_dEdx; i++){
              Michel_ResR .push_back(calos_Michel[1]->ResidualRange()[i]);
              Michel_dEdx .push_back(calos_Michel[1]->dEdx()[i]);
              if(vTrackLength[closest_track_i] >= resR_histRange) h_ResRange_dEdx_michel ->Fill(Michel_ResR[i],Michel_dEdx[i]);
            }  
          }
          // If larsoft says the vertex is actually the endpoint further away from 
          // the muon endpoint, then we need to account for this 
          /*
          else {
            for(size_t i=0; i < N_dEdx; i++){
              Michel_ResR .push_back(calos_Michel[1]->ResidualRange()[N_dEdx-1]-calos_Michel[1]->ResidualRange()[N_dEdx-1-i]+calos_Michel[1]->ResidualRange()[0]);
              Michel_dEdx .push_back(calos_Michel[1]->dEdx()[N_dEdx-1-i]);
              if(vTrackLength[closest_track_i] >= resR_histRange) h_ResRange_dEdx_michel ->Fill(Michel_ResR[i],Michel_dEdx[i]);
            }
          }
          */
        }    
    }// <-- endif single stopping track


  } //endif bUseTrackInformation



  if( (IsBeamEvent)&&(NumTracks==1)&&(NumHits==1)&&(vTrackEnergy[0]>0.)&&(vHitAmplitude[0]<190.)&&(vIsTrackPassing[0])){
    h_TrackEnergy_vs_PE_Total  ->  Fill(vTrackEnergy[0],vHitPE_Total[0]);
  }

  // Fill NumOpHits histo (beam vs. offbeam)
  h_NumOpHits ->Fill(NumHits);
  h_NumOpHits_vs_NumTracks->Fill(NumHits,NumTracks);
  if(IsBeamEvent)   h_NumOpHits_beam    ->Fill(NumHits);
  if(!IsBeamEvent)  h_NumOpHits_offbeam ->Fill(NumHits);
  
        
  if(NumHits==2){      
    // Integral/amplitude of Michel pulse
    Amplitude     = vHitAmplitude[1];
    ADC_100ns     = vHitADC_100ns[1];
    ADC_250ns     = vHitADC_250ns[1];
    ADC_500ns     = vHitADC_500ns[1];
    ADC_1000ns    = vHitADC_1000ns[1];
    ADC_Total     = vHitADC_Total[1];
    PE_100ns      = vHitPE_100ns[1];
    PE_250ns      = vHitPE_250ns[1];
    PE_500ns      = vHitPE_500ns[1];
    PE_1000ns     = vHitPE_1000ns[1];
    PE_Total      = vHitPE_Total[1];
    Pf            = vHitPf[1];
  
  }
  
  if( (fSaveHitWfmsToTree)&&(NumHits>0)&&(NumHits<=2) ){
    // Save the waveform
    HitWaveformIndex = NumHits-1;
    for(int i=0; i<HitWaveformBins; i++){
      HitWaveform[i] = PMT_wfm[vHitTimes[HitWaveformIndex]-fPrePulseDisplay+i]; 
    }
  }
  
  
  // Michel event quality control:
  // Require 2 hits (one before PostPercent, one within 1% of PostPercent) 
  if( (dT > 0.)  && (vHitTimes[0] < vHitTimes[1]-fGateDelay) && (vHitIsAtTrigger[1]) && (!IsBeamEvent)){
    
    LOG_VERBATIM("MichelWfmReco") << "--> passes Michel trigger cut (off-beam)";
    N_MichelCandidates++;
    h_EventTypeCount->Fill(1);
    h_Michel_IsInSignal->Fill((int)vIsInSignalPopulation[1]);
   
    // Fill histograms for possible PSD of initial muon 
    h_MuPf_100_250_vs_MuPE250ns ->Fill(vHitADC_100ns[0]/vHitADC_250ns[0],vHitPE_250ns[0]);
    h_dT_vs_MuPf_100_250        ->Fill(dT,              vHitADC_100ns[0]/vHitADC_250ns[0]);
    h_PE100ns_vs_MuPf_100_250   ->Fill(vHitPE_100ns[1], vHitADC_100ns[0]/vHitADC_250ns[0]);
    
    // Fill histograms of Michel pulse properties
    h_Amplitude                     ->Fill(Amplitude);
    h_PE_100ns                      ->Fill(PE_100ns);
    h_PE_Total                      ->Fill(PE_Total);
    h_PE_100ns_vs_Amplitude         ->Fill(PE_100ns,Amplitude);
    h_Pf_100_500_vs_PE_500ns_Michel ->Fill(vHitADC_100ns[1]/vHitADC_500ns[1],vHitPE_500ns[1]);
    h_Pf_100_500_vs_PE_Total_Michel ->Fill(vHitADC_100ns[1]/vHitADC_500ns[1],vHitPE_Total[1]);
    h_Pf_100_500_vs_Energy_Michel   ->Fill(vHitADC_100ns[1]/vHitADC_500ns[1],vHitPE_Total[1]/fLY);
    h_Pf_vs_PE_Total_Michel         ->Fill(vHitPf[1],vHitPE_Total[1]);
    h_Pf_vs_Energy_Michel           ->Fill(vHitPf[1],vHitPE_Total[1]/fLY);
    h_dT_vs_Energy                  ->Fill(dT,vHitPE_Total[1]/fLY);
    h_dT                            ->Fill(dT);
    
    if( PE_100ns >= fPromptLightDtCut ) {
      h_dT_PEcut     ->Fill(dT);
      if( vHitPE_100ns[0] < 100. ) h_dT_PEcut_MuPEcut->Fill(dT);
    }
    if( (PE_100ns > 0.)&&(PE_100ns < fPromptLightDtCut)&&(vHitPE_100ns[0]<100.))  h_dT_PEcutLow  ->Fill(dT);
    if( (PE_100ns > 0.)&&(PE_100ns < 20)&&(vHitPE_100ns[0]<100.)) {            
      h_dT_PEcutBelow20pe->Fill(dT);
      if( IsSingleStoppingTrack ) h_dT_PEcutBelow20pe_stopTrk->Fill(dT);
      if( IsSinglePassingTrack  ) h_dT_PEcutBelow20pe_thruTrk->Fill(dT);
    }

    if( vIsInSignalPopulation[1] ) {
      N_MichelNonBG++;
      h_PE_100ns_popCut->Fill(PE_100ns);
      h_PE_Total_popCut->Fill(PE_Total);
      h_dT_BkgCut->Fill(dT);
      
      if( dT > 3000. ){
        h_PE_100ns_popCut_DtCut->Fill(PE_100ns);
        h_PE_Total_popCut_DtCut->Fill(PE_Total);
      } 
    }
  
    if( IsSingleStoppingTrack ) {
      h_dT_vs_Energy_stopTrk->Fill(dT,PE_Total/fLY);
      h_PE_100ns_stoppingMu->Fill(PE_100ns);
      h_dT_stoppingMu->Fill(dT);
      MuTrackEnd_DistToCenter = (MuTrackEnd-region_centerpoint).Mag();
      if( MuTrackEnd_DistToCenter <= region_radius) {
        h_PE_100ns_region->Fill(PE_100ns);
        h_PE_Total_region->Fill(PE_Total);
        h_Energy_region->Fill(PE_Total/fLY);
        if( dT >= 3000. ){
          h_PE_Total_region_dTcut->Fill(PE_Total);
          h_Energy_region_dTcut->Fill(PE_Total/fLY);
        }
      
      }
    }
    
     
    // Make average waveform of the "good" Michel events
    if( (dT > fAveWfmCut_Dt)&&(vIsInSignalPopulation[1])&&(vPrepulseRMS[1] <= 2.0) ) fOpHitBuilderAlg_aveMichel.GetHitInfo(PMT_wfm,vHitTimes[1],vHitTimes[0],fIntegrationWindows);
    
    // Make average waveform of the BG events
    if( (dT > fAveWfmCut_Dt)&&(vIsInBGPopulation[1])&&(vPrepulseRMS[1] <= 2.0) ) fOpHitBuilderAlg_aveBG.GetHitInfo(PMT_wfm,vHitTimes[1],vHitTimes[0],fIntegrationWindows);
    
    // Make average waveform of the BG events in the lower peak in PromptPE
    if( (dT > fAveWfmCut_Dt)&&(vHitPE_100ns[1]<14)&&(vPrepulseRMS[1] <= 2.0) ) fOpHitBuilderAlg_aveBG_lowPromptPE.GetHitInfo(PMT_wfm,vHitTimes[1],vHitTimes[0],fIntegrationWindows);

  } // end quality cut condition (off-beam)


  // Make average waveform of muons
  if( (IsCleanBeamWaveform) && (NumTracks==1) && (abs(vTrackPID[0])==13) ) {
    fOpHitBuilderAlg_aveMIP.GetHitInfo(PMT_wfm,vHitTimes[0],0,fIntegrationWindows);
  }
  
  
  // Done with this event so fill the tree
  MichelDataTree->Fill();
  
  // Add space in printout to separate events (for easier debugging)
  LOG_VERBATIM("MichelWfmReco") << "\n";

}


void MichelWfmReco::beginJob()
{
  // Opens up the file service to read information from the ROOT file input
  art::ServiceHandle<art::TFileService> tfs;

  MichelDataTree  = tfs->make<TTree>("MichelDataTree","MichelDataTree");
 
  // Event identifying information 
  MichelDataTree  ->Branch("RunNumber",&RunNumber,"RunNumber/I");
  MichelDataTree  ->Branch("SubRunNumber",&SubRunNumber,"SubRunNumber/I");
  MichelDataTree  ->Branch("EventNumber",&EventNumber,"EventNumber/I");
  MichelDataTree  ->Branch("Timestamp",&Timestamp,"Timestamp/F");
  MichelDataTree  ->Branch("IsBeamEvent",&IsBeamEvent,"IsBeamEvent/I");

  // Waveform hit information
  if(fSaveHitWfmsToTree){
    MichelDataTree ->Branch("HitWaveform",&HitWaveform);
    MichelDataTree ->Branch("HitWaveformIndex",&HitWaveformIndex,"HitWaveformIndex/I");
  }
  MichelDataTree ->Branch("WaveformBaseline",&WaveformBaseline,"WaveformBaseline/F");
  MichelDataTree ->Branch("WaveformBaselineRMS",&WaveformBaselineRMS,"WaveformBaselineRMS/F");
  MichelDataTree ->Branch("NumHits",&NumHits,"NumHits/I");
  MichelDataTree ->Branch("HitTimes",&vHitTimes);
  MichelDataTree ->Branch("HitIsAtTrigger",&vHitIsAtTrigger);
  MichelDataTree ->Branch("HitAmplitude",&vHitAmplitude);
  MichelDataTree ->Branch("HitADC_100ns",&vHitADC_100ns);
  MichelDataTree ->Branch("HitADC_250ns",&vHitADC_250ns);
  MichelDataTree ->Branch("HitADC_500ns",&vHitADC_500ns);
  MichelDataTree ->Branch("HitADC_1000ns",&vHitADC_1000ns);
  MichelDataTree ->Branch("HitADC_Total",&vHitADC_Total); 
  MichelDataTree ->Branch("HitPE_100ns",&vHitPE_100ns);
  MichelDataTree ->Branch("HitPE_250ns",&vHitPE_250ns);
  MichelDataTree ->Branch("HitPE_500ns",&vHitPE_500ns);
  MichelDataTree ->Branch("HitPE_1000ns",&vHitPE_1000ns);
  MichelDataTree ->Branch("HitPE_Total",&vHitPE_Total); 
  MichelDataTree ->Branch("PrepulseBaseline",&vPrepulseBaseline);
  MichelDataTree ->Branch("PrepulseRMS",&vPrepulseRMS);
  MichelDataTree ->Branch("PrepulseSlowNorm",&vPrepulseSlowNorm);
  MichelDataTree ->Branch("PrepulseSlowTau",&vPrepulseSlowTau);
  MichelDataTree ->Branch("PrepulseReducedChi2",&vPrepulseReducedChi2);
  MichelDataTree ->Branch("IsInSignalPopulation",&vIsInSignalPopulation);
  MichelDataTree ->Branch("IsInBGPopulation",&vIsInBGPopulation);
  MichelDataTree ->Branch("IsCleanBeamWaveform",&IsCleanBeamWaveform,"IsCleanBeamWaveform/O");
  MichelDataTree ->Branch("dT",&dT,"dT/F");
  MichelDataTree ->Branch("Amplitude",&Amplitude,"Amplitude/F");
  MichelDataTree ->Branch("ADC_100ns",&ADC_100ns,"ADC_100ns/F");
  MichelDataTree ->Branch("ADC_Total",&ADC_Total,"ADC_Total/F");
  MichelDataTree ->Branch("PE_100ns",&PE_100ns,"PE_100ns/F");
  MichelDataTree ->Branch("PE_250ns",&PE_100ns,"PE_250ns/F");
  MichelDataTree ->Branch("PE_500ns",&PE_100ns,"PE_500ns/F");
  MichelDataTree ->Branch("PE_1000ns",&PE_100ns,"PE_1000ns/F");
  MichelDataTree ->Branch("PE_Total",&PE_Total,"PE_Total/F");
  MichelDataTree ->Branch("Pf",&Pf,"Pf/F");
  
  // Track information
  if(bUseTrackInformation){
    MichelDataTree ->Branch("NumTracks",&NumTracks,"NumTracks/I");
    if(fSaveAllTrackInfoToTree){
      MichelDataTree ->Branch("TrackVertex_x",&vTrackVertex_x);
      MichelDataTree ->Branch("TrackVertex_y",&vTrackVertex_y);
      MichelDataTree ->Branch("TrackVertex_z",&vTrackVertex_z);
      MichelDataTree ->Branch("TrackEnd_x",&vTrackEnd_x);
      MichelDataTree ->Branch("TrackEnd_y",&vTrackEnd_y);
      MichelDataTree ->Branch("TrackEnd_z",&vTrackEnd_z);
      MichelDataTree ->Branch("IsTrackStopping",&vIsTrackStopping);
      MichelDataTree ->Branch("IsTrackPassing",&vIsTrackPassing);
      MichelDataTree ->Branch("IsTrackContained",&vIsTrackContained);
      MichelDataTree ->Branch("TrackPID",&vTrackPID);
      MichelDataTree ->Branch("TrackPIDA",&vTrackPIDA);
      MichelDataTree ->Branch("TrackLength",&vTrackLength);
      MichelDataTree ->Branch("TrackEnergy",&vTrackEnergy);
      
      MichelDataTree ->Branch("Mu_dEdx",&Mu_dEdx);
      MichelDataTree ->Branch("Mu_ResRange",&Mu_ResR);
      MichelDataTree ->Branch("Michel_dEdx",&Michel_dEdx);
      MichelDataTree ->Branch("Michel_ResRange",&Michel_ResR);
    }
    MichelDataTree ->Branch("IsSinglePassingTrack",&IsSinglePassingTrack,"IsSinglePassingTrack/I");
    MichelDataTree ->Branch("IsSingleStoppingTrack",&IsSingleStoppingTrack,"IsStoppingTrack/I");
    MichelDataTree ->Branch("StoppingTrackZenithAngle",&StoppingTrackZenithAngle,"StoppingTrackZenithAngle/F");
    MichelDataTree ->Branch("PassingTrackZenithAngle",&PassingTrackZenithAngle,"PassingTrackZenithAngle/F");
    MichelDataTree ->Branch("MuTrackVertex_x",&MuTrackVertex_x,"MuTrackVertex_x/F");
    MichelDataTree ->Branch("MuTrackVertex_y",&MuTrackVertex_y,"MuTrackVertex_y/F");
    MichelDataTree ->Branch("MuTrackVertex_z",&MuTrackVertex_z,"MuTrackVertex_z/F");
    MichelDataTree ->Branch("MuTrackEnd_x",&MuTrackEnd_x,"MuTrackEnd_x/F");
    MichelDataTree ->Branch("MuTrackEnd_y",&MuTrackEnd_y,"MuTrackEnd_y/F");
    MichelDataTree ->Branch("MuTrackEnd_z",&MuTrackEnd_z,"MuTrackEnd_z/F");
    MichelDataTree ->Branch("MuTrackLength",&MuTrackLength,"MuTrackLength/F");
    MichelDataTree ->Branch("MuTrackEnergy",&MuTrackEnergy,"MuTrackEnergy/F");
    MichelDataTree ->Branch("MuTrackEnd_DistToCenter",&MuTrackEnd_DistToCenter,"MuTrackEnd_DistToCenter/F");
    MichelDataTree ->Branch("SecondTrackProximity",&SecondTrackProximity,"SecondTrackProximity/F"); 
    MichelDataTree ->Branch("SecondTrackLength",&SecondTrackLength,"SecondTrackLength/F"); 
    MichelDataTree ->Branch("SecondTrackEnergy",&SecondTrackEnergy,"SecondTrackEnergy/F"); 
    MichelDataTree ->Branch("IsSecondTrackContained",&IsSecondTrackContained,"IsSecondTrackContained/I"); 
  }
  // Histograms 
  int tot_pe_max = 800;
  h_EventTypeCount           = tfs->make<TH1F>("BeamEventCount","Beam events (0), MICHEL-like events (1)",2,0,2);
  h_Michel_IsInSignal        = tfs->make<TH1F>("Michel_IsInSignal","Signal events (1), BG events (0) defined by PSD cut",2,0,2);
  h_TimeStructure           = tfs->make<TH1F>("TimeStructure", "Event timestamp (per spill);s",200,3.2,3.3);
  h_NumOpHits               = tfs->make<TH1I>("OpHitsPerEvent", "Optical hits per event", 10, 0, 10);
  h_NumOpHits               ->GetXaxis()->SetTitle("Num hits");
  h_NumOpHits               ->GetYaxis()->SetTitle("Counts");
  h_NumOpHits_beam          = tfs->make<TH1I>("OpHitsPerEvent_beam", "Optical hits per event (beam)",  10, 0, 10);
  h_NumOpHits_beam          ->GetXaxis()->SetTitle("Num hits");
  h_NumOpHits_beam          ->GetYaxis()->SetTitle("Counts");
  h_NumOpHits_offbeam       = tfs->make<TH1I>("OpHitsPerEvent_offbeam", "Optical hits per event (off-beam)", 10, 0, 10);
  h_NumOpHits_offbeam       ->GetXaxis()->SetTitle("Num hits");
  h_NumOpHits_offbeam       ->GetYaxis()->SetTitle("Counts");
  h_NumOpHits_vs_NumTracks  = tfs->make<TH2I>("NumOpHits_vs_NumTracks", "Optical hits vs. number of tracks in event", 10, 0,10, 50,0,50);
  h_NumOpHits_vs_NumTracks  ->GetXaxis()->SetTitle("Num optical hits");
  h_NumOpHits_vs_NumTracks  ->GetYaxis()->SetTitle("Num tracks");
  h_NumOpHits_vs_NumTracks  ->SetOption("colz");

  h_HitTime                 = tfs->make<TH1F>("HitTime", "Hit times (all events)",1000,0.,30000.);
  h_HitTime_beam            = tfs->make<TH1F>("HitTime_beam", "Hit times (beam events)",1000,0.,30000.);
  h_HitAmplitude            = tfs->make<TH1F>("HitAmplitude", "Amplitude of found hit in single-hit events", 300,   0., 300.);
  h_HitAmplitude            ->GetXaxis()->SetTitle("Optical hit amplitude [mV]");
  h_HitAmplitude            ->GetYaxis()->SetTitle("Counts");
  h_HitPE_100ns             = tfs->make<TH1F>("HitPE_100ns","Prompt photoelectrons per hit",800,0.,800.);
  h_HitPE_100ns             ->GetXaxis()->SetTitle("Prompt photoelectrons per hit");
  h_HitPE_100ns             ->GetYaxis()->SetTitle("Counts");
 
  h_dT_vs_MuPE_100ns        = tfs->make<TH2F>("dT_vs_MuPE_100ns","#Deltat vs. #mu prompt PE (100ns);#Deltat [ns];Prompt light from muon [pe]",75,0,7500,120,0,1200);
  h_dT_vs_MuPE_100ns        ->SetOption("colz");
  
  h_MuPf_100_250_vs_MuPE250ns  = tfs->make<TH2F>("MuPf_100_250_vs_MuPE250ns","Prompt fraction (100ns/250ns) for #mu-candidate pulses in Michel-like events;#mu f_{P};#mu light in 250ns [pe]",
    200,0.,1.2,
    200,0.,300);
  h_MuPf_100_250_vs_MuPE250ns  ->SetOption("colz");
  
  h_dT_vs_MuPf_100_250  = tfs->make<TH2F>("dT_vs_MuPf_100_250","#Deltat vs. f(100/250) for #mu-candidate pulses in Michel-like events;#Deltat;#mu f_{P}",
    150, 0.,7500, 
    200,0.,1.2);
  h_dT_vs_MuPf_100_250  ->SetOption("colz");

  h_PE100ns_vs_MuPf_100_250 = tfs->make<TH2F>("PE100ns_vs_MuPf_100_250","Michel prompt light (100ns) vs. #mu f(100/250);Michel prompt light [pe];#mu f_{P}",
    200,0.,140.,
    200,0.,1.2);
  h_PE100ns_vs_MuPf_100_250 ->SetOption("colz");

  h_dT     = tfs->make<TH1F>("dT","#Deltat", 750,0., 7500.);
  h_dT     ->GetXaxis()->SetTitle("ns");
  h_dT     ->GetYaxis()->SetTitle("Counts");
  
  sprintf(buffer,"#Delta t (prompt light > %d pe)",fPromptLightDtCut); 
  h_dT_PEcut     = tfs->make<TH1F>("dT_PEcut",buffer, 750,0., 7500.);
  h_dT_PEcut     ->GetXaxis()->SetTitle("ns");
  h_dT_PEcut     ->GetYaxis()->SetTitle("Counts");
  
  sprintf(buffer,"#Delta t (prompt light > %d pe, #mu prompt light < 100 pe)",fPromptLightDtCut); 
  h_dT_PEcut_MuPEcut     = tfs->make<TH1F>("dT_PEcut_MuPEcut",buffer, 750,0., 7500.);
  h_dT_PEcut_MuPEcut     ->GetXaxis()->SetTitle("ns");
  h_dT_PEcut_MuPEcut     ->GetYaxis()->SetTitle("Counts");
 
  sprintf(buffer,"#Delta t (prompt light < %d pe)",fPromptLightDtCut); 
  h_dT_PEcutLow     = tfs->make<TH1F>("dT_PEcutLow",buffer, 750,0., 7500.);
  h_dT_PEcutLow     ->GetXaxis()->SetTitle("ns");
  h_dT_PEcutLow     ->GetYaxis()->SetTitle("Counts");
  
  h_dT_PEcutBelow20pe     = tfs->make<TH1F>("dT_PEcutBelow20pe","#Delta t (prompt light < 20 pe)", 750,0., 7500.);
  h_dT_PEcutBelow20pe     ->GetXaxis()->SetTitle("ns");
  h_dT_PEcutBelow20pe     ->GetYaxis()->SetTitle("Counts");
  
  h_dT_PEcutBelow20pe_stopTrk     = tfs->make<TH1F>("dT_PEcutBelow20pe_stopTrk","#Delta t (prompt light < 20 pe), single stopping track", 750,0., 7500.);
  h_dT_PEcutBelow20pe_stopTrk     ->GetXaxis()->SetTitle("ns");
  h_dT_PEcutBelow20pe_stopTrk     ->GetYaxis()->SetTitle("Counts");
  
  h_dT_PEcutBelow20pe_thruTrk     = tfs->make<TH1F>("dT_PEcutBelow20pe_thruTrk","#Delta t (prompt light < 20 pe), single through-going track", 750,0., 7500.);
  h_dT_PEcutBelow20pe_thruTrk     ->GetXaxis()->SetTitle("ns");
  h_dT_PEcutBelow20pe_thruTrk     ->GetYaxis()->SetTitle("Counts");
  
  h_dT_BkgCut     = tfs->make<TH1F>("dT_BkgCut","#Deltat, PSD-based selection", 750,0., 7500.);
  h_dT_BkgCut     ->GetXaxis()->SetTitle("ns");
  h_dT_BkgCut     ->GetYaxis()->SetTitle("Counts");
  
  sprintf(buffer,"#Delta t (1 stopping track)"); 
  h_dT_stoppingMu    = tfs->make<TH1F>("dT_stoppingMu", buffer, 750,0., 7500.);
  h_dT_stoppingMu    ->GetXaxis()->SetTitle("ns");
  h_dT_stoppingMu    ->GetYaxis()->SetTitle("Counts");

  sprintf(buffer,"#Deltat vs. estimated energy (%3.1f pe/MeV) for Michel-like events;#Deltat [ns];Energy [MeV]",fLY); 
  h_dT_vs_Energy    = tfs->make<TH2F>("dT_vs_Energy",buffer,75,0.,7500., 100.,0.,80.);
  h_dT_vs_Energy    ->SetOption("colz");
  
  sprintf(buffer,"#Deltat vs. estimated energy (%3.1f pe/MeV) for Michel-like events with stopping #mu;#Deltat [ns];Energy [MeV]",fLY); 
  h_dT_vs_Energy_stopTrk    = tfs->make<TH2F>("dT_vs_Energy_stopTrk",buffer,75,0.,7500., 100,0.,80.);
  h_dT_vs_Energy_stopTrk    ->SetOption("colz");
  
  h_Amplitude               = tfs->make<TH1F>("Amplitude", "Amplitude", 500,   0., 100.);
  h_Amplitude               ->GetXaxis()->SetTitle("Amplitude of Michel-candidate PMT pulse [mV]");
  h_Amplitude               ->GetYaxis()->SetTitle("Counts");
  
  h_PE_100ns                = tfs->make<TH1F>("PE_100ns", "Prompt light (100ns) in Michel-candidate pulses",  280,  0., 140.);
  h_PE_100ns             ->GetXaxis()->SetTitle("Prompt Photoelectrons");
  h_PE_100ns             ->GetYaxis()->SetTitle("Counts");
  
  h_PE_Total                = tfs->make<TH1F>("PE_Total", "Total light in Michel-candidate pulses",  250,  0., 500.);
  h_PE_Total                ->GetXaxis()->SetTitle("Total light [pe]");
  h_PE_Total                ->GetYaxis()->SetTitle("Counts");
  
  h_PE_100ns_popCut = tfs->make<TH1F>("PE_100ns_popCut", "Prompt light integral (100ns), BG population cut",  280,  0., 140.);
  h_PE_100ns_popCut ->GetXaxis()->SetTitle("Integrated prompt light, 100ns [pe]");
  h_PE_100ns_popCut ->GetYaxis()->SetTitle("Counts");
 
  h_PE_100ns_popCut_DtCut = tfs->make<TH1F>("PE_100ns_popCut_DtCut", "Prompt light integral (100ns), BG population cut, #Delta t > 3us",  280,  0., 140.);
  h_PE_100ns_popCut_DtCut ->GetXaxis()->SetTitle("Integrated prompt light, 100ns [pe]");
  h_PE_100ns_popCut_DtCut ->GetYaxis()->SetTitle("Counts");
  
  h_PE_100ns_stoppingMu = tfs->make<TH1F>("PE_100ns_stoppingMu","Prompt light integral (100ns) in events with 1 stopping track",280,0.,140.);
  h_PE_100ns_stoppingMu ->GetXaxis()->SetTitle("Integrated prompt light, 100ns [pe]");
  h_PE_100ns_stoppingMu ->GetYaxis()->SetTitle("Counts");
  
  h_PE_Total_popCut          = tfs->make<TH1F>("PE_Total_popCut", "Total light integral (7us), BG population cut",  250,  0., 500.);
  h_PE_Total_popCut          ->GetXaxis()->SetTitle("Integrated light, 7us [pe]");
  h_PE_Total_popCut          ->GetYaxis()->SetTitle("Counts");
  
  h_PE_Total_popCut_DtCut    = tfs->make<TH1F>("PE_Total_popCut_DtCut", "Total light integral (7us), BG population cut, #Delta t > 3us",  250,  0., 500.);
  h_PE_Total_popCut_DtCut    ->GetXaxis()->SetTitle("Integrated light, 7us [pe]");
  h_PE_Total_popCut_DtCut    ->GetYaxis()->SetTitle("Counts");
  
  h_PE_100ns_region    = tfs->make<TH1F>("PE_100ns_region","Prompt photoelectrons, limited region",280,0.,140.);
  h_PE_100ns_region    ->GetXaxis()->SetTitle("Prompt photoelectrons");
  h_PE_100ns_region    ->GetYaxis()->SetTitle("Counts");
  
  h_PE_Total_region    = tfs->make<TH1F>("PE_Total_region","Total photoelectrons (7us), limited region",250,0.,500.);
  h_PE_Total_region    ->GetXaxis()->SetTitle("Photoelectrons");
  h_PE_Total_region    ->GetYaxis()->SetTitle("Counts");
  
  h_Energy_region    = tfs->make<TH1F>("Energy_region","Estimated energy, Michel e's in limited region",240,0.,120.);
  h_Energy_region    ->GetXaxis()->SetTitle("Energy [MeV]");
  h_Energy_region    ->GetYaxis()->SetTitle("Counts");
  
  h_PE_Total_region_dTcut    = tfs->make<TH1F>("PE_Total_region_dTcut","Total photoelectrons (7us), limited region, dT > 2#mus",200,0.,500.);
  h_PE_Total_region_dTcut    ->GetXaxis()->SetTitle("Photoelectrons");
  h_PE_Total_region_dTcut    ->GetYaxis()->SetTitle("Counts");
  
  h_Energy_region_dTcut    = tfs->make<TH1F>("Energy_region_dTcut","Estimated energy, Michel e's in limited region, dT > 2#mus",240,0.,120.);
  h_Energy_region_dTcut    ->GetXaxis()->SetTitle("Energy [MeV]");
  h_Energy_region_dTcut    ->GetYaxis()->SetTitle("Counts");


  h_Pf_vs_PE_Total = tfs->make<TH2F>("Pf_vs_PE_Total",
    "Prompt fraction (100ns/7#mus) vs. total light;Prompt fraction (f_{P});Total light in 7#mus [pe]",200,0,1.2,200,0,tot_pe_max);
  h_Pf_vs_PE_Total->SetOption("colz");
  
  h_Pf_100_1000_vs_PE_Total = tfs->make<TH2F>("Pf_100_1000_vs_PE_Total",
    "Prompt fraction (100ns/1#mus) vs. total light;Prompt fraction (f_{P});Total light in 7#mus [pe]",200,0,1.2,200,0,tot_pe_max);
  h_Pf_100_1000_vs_PE_Total ->SetOption("colz");
  
  h_Pf_100_500_vs_PE_Total = tfs->make<TH2F>("Pf_100_500_vs_PE_Total",
    "Prompt fraction (100ns/500ns) vs. total light;Prompt fraction (f_{P});Total light in 7#mus [pe]",200,0,1.2,200,0,tot_pe_max);
  h_Pf_100_500_vs_PE_Total ->SetOption("colz");
  
  h_Pf_100_500_vs_PE_500ns = tfs->make<TH2F>("Pf_100_500_vs_PE_500ns",
    "Prompt fraction (100ns/500ns) vs. total light in 500ns;Prompt fraction (f_{P});Total light in 500ns [pe]",200,0,1.2,200,0,tot_pe_max/2.);
  h_Pf_100_500_vs_PE_500ns ->SetOption("colz");
  
  h_Pf_100_500_vs_PE_500ns_BeamPreTrig = tfs->make<TH2F>("Pf_100_500_vs_PE_500ns_BeamPreTrig",
    "Prompt fraction (100ns/500ns) vs. light in 500ns for beam pre-trigger windows;Prompt fraction (f_{P});Total light in 500ns [pe]",200,0,1.2,200,0,tot_pe_max/2.);
  h_Pf_100_500_vs_PE_500ns_BeamPreTrig ->SetOption("colz");
  
  h_Pf_100_500_vs_PE_500ns_Michel = tfs->make<TH2F>("Pf_100_500_vs_PE_500ns_Michel",
    "Prompt fraction (100ns/500ns) vs. total light in 500ns for Michel-candidate pulses;Prompt fraction (f_{P});Total light in 500ns [pe]",200,0,1.2,200,0,tot_pe_max/2.);
  h_Pf_100_500_vs_PE_500ns_Michel ->SetOption("colz");
  
  h_Pf_100_500_vs_PE_500ns_Mu = tfs->make<TH2F>("Pf_100_500_vs_PE_500ns_Mu",
    "Prompt fraction (100ns/500ns) vs. total light in 500ns for initial muon;Prompt fraction (f_{P});Total light in 500ns [pe]",200,0,1.2,200,0,tot_pe_max/2.);
  h_Pf_100_500_vs_PE_500ns_Mu ->SetOption("colz");
  
  h_PE100ns_vs_Amplitude_BeamPreTrig = tfs->make<TH2F>("h_PE100ns_vs_Amplitude_BeamPreTrig","Hits within pre-trigger window of beam events;Prompt light in 100ns [pe];Amplitude [mV]",
    200,0.,140,
    200,0.,100);
  h_PE100ns_vs_Amplitude_BeamPreTrig->SetOption("colz");

  
  sprintf(buffer,"Prompt fraction (100ns/7#mus) vs. estimated energy (%3.1f pe/MeV);Prompt fraction (f_{P});Energy [MeV]",fLY); 
  h_Pf_vs_Energy = tfs->make<TH2F>("Pf_vs_Energy",buffer,200,0,1.2,200,0,tot_pe_max/fLY);
  h_Pf_vs_Energy ->SetOption("colz");
  h_Pf_vs_Energy_LowE = tfs->make<TH2F>("Pf_vs_Energy_LowE",buffer,200,0,1.2,200,0,80);
  h_Pf_vs_Energy_LowE ->SetOption("colz");
  
  sprintf(buffer,"Prompt fraction (100ns/1#mus) vs. estimated energy (%3.1f pe/MeV);Prompt fraction (f_{P});Energy [MeV]",fLY); 
  h_Pf_100_1000_vs_Energy = tfs->make<TH2F>("Pf_100_1000_vs_Energy",buffer,200,0,1.2,200,0,tot_pe_max/fLY);
  h_Pf_100_1000_vs_Energy ->SetOption("colz");
  
  sprintf(buffer,"Prompt fraction (100ns/500ns) vs. estimated energy (%3.1f pe/MeV);Prompt fraction (f_{P});Energy [MeV]",fLY); 
  h_Pf_100_500_vs_Energy = tfs->make<TH2F>("Pf_100_500_vs_Energy",buffer,200,0,1.2,200,0,tot_pe_max/fLY);
  h_Pf_100_500_vs_Energy ->SetOption("colz");




  h_Pf_vs_PE_Total_Michel = tfs->make<TH2F>("Pf_vs_PE_Total_Michel",
    "Prompt fraction (100ns/7#mus) vs. total light for Michel-like events;Prompt fraction (f_{P});Total light in 7#mus [pe]",200,0,1.2,200,0,tot_pe_max);
  h_Pf_vs_PE_Total_Michel->SetOption("colz");
  
  h_Pf_100_500_vs_PE_Total_Michel = tfs->make<TH2F>("Pf_100_500_vs_PE_Total_Michel",
    "Prompt fraction (100ns/500ns) vs. total light in Michel-like events;Prompt fraction (f_{P});Total light in 7#mus [pe]",200,0,1.2,200,0,tot_pe_max);
  h_Pf_100_500_vs_PE_Total_Michel ->SetOption("colz");
  
  sprintf(buffer,"Prompt fraction (100ns/7#mus) vs. estimated energy (%3.1f pe/MeV) for Michel-like events;Prompt fraction (f_{P});Energy [MeV]",fLY); 
  h_Pf_vs_Energy_Michel = tfs->make<TH2F>("Pf_vs_Energy_Michel",buffer,200,0,1.2,200,0,tot_pe_max/fLY);
  h_Pf_vs_Energy_Michel ->SetOption("colz");
  
  sprintf(buffer,"Prompt fraction (100ns/500ns) vs. estimated energy (%3.1f pe/MeV) for Michel-like events;Prompt fraction (f_{P});Energy [MeV]",fLY); 
  h_Pf_100_500_vs_Energy_Michel = tfs->make<TH2F>("Pf_100_500_vs_Energy_Michel",buffer,200,0,1.2,200,0,tot_pe_max/fLY);
  h_Pf_100_500_vs_Energy_Michel ->SetOption("colz");
 

  h_PE_100ns_vs_Amplitude     = tfs->make<TH2F>("PE_100ns_vs_Amplitude","Prompt PEs (100ns) vs. amplitude",200,0.,140.,200,0.,100.);
  h_PE_100ns_vs_Amplitude     ->GetXaxis()->SetTitle("Prompt photoelectrons");
  h_PE_100ns_vs_Amplitude     ->GetYaxis()->SetTitle("Amplitude [mV]");
  h_PE_100ns_vs_Amplitude     ->SetOption("colz");
  
  h_TrackEnergy_vs_PE_Total   = tfs->make<TH2F>("TrackEnergy_vs_PE_Total",";Reconstructed track energy [MeV];Total photoelectrons",100,0.,250.,120,0.,1200.);
  h_TrackEnergy_vs_PE_Total   ->SetOption("colz");

  h_TrackNode_zx          = tfs->make<TH2F>("TrackNode_zx","TrackNode_zx",180,0.,90.,94,0.,47.);
  h_TrackNode_zx          ->GetXaxis()->SetTitle("z [cm]");
  h_TrackNode_zx          ->GetYaxis()->SetTitle("x [cm]");
  h_TrackNode_zx          ->SetMarkerStyle(7);
  h_TrackNode_zx          ->SetOption("colz");

  h_TrackNode_zy          = tfs->make<TH2F>("TrackNode_zy","TrackNode_zy",180,0.,90.,80,-20.,20.);
  h_TrackNode_zy          ->GetXaxis()->SetTitle("z [cm]");
  h_TrackNode_zy          ->GetYaxis()->SetTitle("y [cm]");
  h_TrackNode_zy          ->SetMarkerStyle(7);
  h_TrackNode_zy          ->SetOption("colz");

  h_TrackEnd_x            = tfs->make<TH1F>("TrackEnd_x","TrackEnd_x",100,-10.,60.);
  h_TrackEnd_y            = tfs->make<TH1F>("TrackEnd_y","TrackEnd_y",100,-25.,25.);
  h_TrackEnd_z            = tfs->make<TH1F>("TrackEnd_z","TrackEnd_z",100,-10.,100.);
  h_TrackVertex_x         = tfs->make<TH1F>("TrackVertex_x","TrackVertex_x",100,-10.,60.);
  h_TrackVertex_y         = tfs->make<TH1F>("TrackVertex_y","TrackVertex_y",100,-25.,25.);
  h_TrackVertex_z         = tfs->make<TH1F>("TrackVertex_z","TrackVertex_z",100,-10.,100.);
  
  h_InFiducialVolume      = tfs->make<TH2I>("InFiducialVolume",";Vertex in fiducial volume;End in fiducial volume",2,0.,2.,2,0.,2.);
  h_InFiducialVolume      ->SetOption("colz");
  
  h_SecondTrackOffset     = tfs->make<TH1F>("SecondTrackOffset","Primary / secondary track endpoint offset;cm",100,0.,30.);

  h_ResRange_dEdx_mu      = tfs->make<TH2F>("ResRange_dEdx_mu","Stopping cosmic #mu-candidate tracks;Residual range [cm]; dE/dX [MeV/cm]",
    100,0,resR_histRange,
    100,0,30);
  h_ResRange_dEdx_mu      ->SetOption("colz");
  h_ResRange_dEdx_michel  = tfs->make<TH2F>("ResRange_dEdx_michel","Michel candidate tracks;Residual range [cm]; dEdx [MeV/cm]",
    100,0,resR_histRange,
    100,0,30);
  h_ResRange_dEdx_michel  ->SetOption("colz");


  h_AverageWaveform_Michel= tfs->make<TH1F>("AverageWaveform_Michel","Average waveform of Michel pulse",
                            HitWaveformBins,0.,(float)HitWaveformBins);
  h_AverageWaveform_Michel      ->GetXaxis()->SetTitle("ns");
  h_AverageWaveform_Michel      ->GetYaxis()->SetTitle("mV");
  
  h_AverageWaveform_BG      = tfs->make<TH1F>("AverageWaveform_BG","Average waveform of background pulse (low population in 100/500 PSD)",
                            HitWaveformBins,0.,(float)HitWaveformBins);
  h_AverageWaveform_BG      ->GetXaxis()->SetTitle("ns");
  h_AverageWaveform_BG      ->GetYaxis()->SetTitle("mV");
  
  h_AverageWaveform_BG_lowPromptPE      = tfs->make<TH1F>("AverageWaveform_BG_lowPromptPE","Average waveform of background pulse (Prompt PE < 14)",
                            HitWaveformBins,0.,(float)HitWaveformBins);
  h_AverageWaveform_BG_lowPromptPE      ->GetXaxis()->SetTitle("ns");
  h_AverageWaveform_BG_lowPromptPE      ->GetYaxis()->SetTitle("mV");
  
  h_AverageWaveformMIP    = tfs->make<TH1F>("AverageWaveformMIP","Average waveform of thru-going muons",
                            HitWaveformBins,0.,(float)HitWaveformBins);
  h_AverageWaveformMIP    ->GetXaxis()->SetTitle("ns");
  h_AverageWaveformMIP    ->GetYaxis()->SetTitle("mV");
 
}

void MichelWfmReco::beginRun(art::Run & r)
{
  fTrigFiltAlg.loadXMLDatabaseTable( r.run() );
  iEvent = 0; 
}

void MichelWfmReco::beginSubRun(art::SubRun & sr)
{
}

void MichelWfmReco::endJob()
{

  TF1 ones("ones","1.",0.,1000000.);

  // Add function to correct BG baseline (to do)

  // Make the average waveforms 
  // Waveform 1 (Michel pulses)
  int N_entries = fOpHitBuilderAlg_aveMichel.AverageWaveform_count;
  float integral_prompt = 0.;
  float integral_total = 0.;
  float ave_baseline = 0.;
  if( N_entries > 0 ){
    for( int i = 1; i <= (int)fOpHitBuilderAlg_aveMichel.AverageWaveform.size(); i++) {
      float w = fOpHitBuilderAlg_aveMichel.AverageWaveform.at(i) / float(N_entries); 
      h_AverageWaveform_Michel->Fill(i-1,w);
      if( (i-1<fPrePulseDisplay-10)) ave_baseline += w/(float(fPrePulseDisplay)-10.);
      if( (i-1>fPrePulseDisplay-10)&&(i-1<fPrePulseDisplay+fPromptWindowLength) ) integral_prompt += w;// - ave_baseline;
      if( (i-1>fPrePulseDisplay-10) ) integral_total += w;//- ave_baseline; 
    }
  }
  
  //float min = h_AverageWaveform1->GetMinimum() - 0.001;
  h_AverageWaveform_Michel->Add(&ones,-1.*ave_baseline+0.1);
  
  LOG_VERBATIM("MichelWfmReco") 
  <<"=================================\n"
  <<"Michel hits (1)\n"
  <<"Average of "<<N_entries<<" waveforms.\n"
  <<"   prompt ("<<fPromptWindowLength<<" ns): "<<integral_prompt<<std::endl
  <<"   total ("<<fFullWindowLength<<" ns): "<<integral_total<<std::endl
  <<"   ratio: "<< integral_prompt / integral_total <<std::endl
  <<"================================\n";
  
  
  // Waveform 2 (BG pulses)
  N_entries = fOpHitBuilderAlg_aveBG.AverageWaveform_count;
  integral_prompt = 0.;
  integral_total = 0.;
  ave_baseline = 0.;
  if( N_entries > 0 ){
    for( int i = 1; i <= (int)fOpHitBuilderAlg_aveBG.AverageWaveform.size(); i++) {
      float w = fOpHitBuilderAlg_aveBG.AverageWaveform.at(i) / float(N_entries); 
      h_AverageWaveform_BG->Fill(i-1,w);
      if( (i-1<fPrePulseDisplay-10)) ave_baseline += w/(float(fPrePulseDisplay)-10.);
      if( (i-1>fPrePulseDisplay-10)&&(i-1<fPrePulseDisplay+fPromptWindowLength) ) integral_prompt += w;// - ave_baseline;
      if( (i-1>fPrePulseDisplay-10) ) integral_total += w;// - ave_baseline; 
    }
  }
  //min = h_AverageWaveform2->GetMinimum() - 0.001;
  h_AverageWaveform_BG->Add(&ones,-1.*ave_baseline+0.1);
  std::cout<<"=================================\n";
  std::cout<<"BG hits (lower blob of 100/500 PSD plot)\n";
  std::cout<<"Average of "<<N_entries<<" waveforms.\n";
  std::cout<<"   prompt ("<<fPromptWindowLength<<" ns): "<<integral_prompt<<std::endl;
  std::cout<<"   total ("<<fFullWindowLength<<" ns): "<<integral_total<<std::endl;
  std::cout<<"   ratio: "<< integral_prompt / integral_total<<std::endl;
  std::cout<<"================================\n";
  
  // BG pulses of low Prompt PE
  N_entries = fOpHitBuilderAlg_aveBG_lowPromptPE.AverageWaveform_count;
  integral_prompt = 0.;
  integral_total = 0.;
  ave_baseline = 0.;
  if( N_entries > 0 ){
    for( int i = 1; i <= (int)fOpHitBuilderAlg_aveBG_lowPromptPE.AverageWaveform.size(); i++) {
      float w = fOpHitBuilderAlg_aveBG_lowPromptPE.AverageWaveform.at(i) / float(N_entries); 
      h_AverageWaveform_BG_lowPromptPE->Fill(i-1,w);
      if( (i-1<fPrePulseDisplay-10)) ave_baseline += w/(float(fPrePulseDisplay)-10.);
      if( (i-1>fPrePulseDisplay-10)&&(i-1<fPrePulseDisplay+fPromptWindowLength) ) integral_prompt += w;// - ave_baseline;
      if( (i-1>fPrePulseDisplay-10) ) integral_total += w;// - ave_baseline; 
    }
  }
  //min = h_AverageWaveform2->GetMinimum() - 0.001;
  h_AverageWaveform_BG_lowPromptPE->Add(&ones,-1.*ave_baseline+0.1);
  std::cout<<"=================================\n";
  std::cout<<"BG hits (PromptPE < 14)\n";
  std::cout<<"Average of "<<N_entries<<" waveforms.\n";
  std::cout<<"   prompt ("<<fPromptWindowLength<<" ns): "<<integral_prompt<<std::endl;
  std::cout<<"   total ("<<fFullWindowLength<<" ns): "<<integral_total<<std::endl;
  std::cout<<"   ratio: "<< integral_prompt / integral_total<<std::endl;
  std::cout<<"================================\n";
  


  // MIP average waveform
  N_entries = fOpHitBuilderAlg_aveMIP.AverageWaveform_count;
  integral_prompt = 0.;
  integral_total = 0.;
  if( N_entries > 0 ){
    for( int i = 1; i <= (int)fOpHitBuilderAlg_aveMIP.AverageWaveform.size(); i++) {
      float w = fOpHitBuilderAlg_aveMIP.AverageWaveform.at(i) / float(N_entries); 
      h_AverageWaveformMIP->Fill(i-1,w);
      if( (i-1>fPrePulseDisplay-10)&&(i-1<fPrePulseDisplay+fPromptWindowLength) ) integral_prompt += w;
      if( (i-1>fPrePulseDisplay-10) ) integral_total += w; 
    }
  }
  //min = h_AverageWaveformMIP->GetMinimum() - 0.001;
  //h_AverageWaveformMIP->Add(&ones,-1.*min);
  std::cout<<"=================================\n";
  std::cout<<"MIPs:\n";
  std::cout<<"Average of "<<N_entries<<" waveforms.\n";
  std::cout<<"   prompt ("<<fPromptWindowLength<<" ns): "<<integral_prompt<<std::endl;
  std::cout<<"   total ("<<fFullWindowLength<<" ns): "<<integral_total<<std::endl;
  std::cout<<"   ratio: "<< integral_prompt / integral_total<<std::endl;
  std::cout<<"================================\n";

  std::cout<<"================================\n";
  std::cout<<"SUMMARY:\n\n";
  std::cout<<"  total events     "<<iEvent<<std::endl;
  std::cout<<"  -- w/ETL         "<<N_Events<<std::endl;
  std::cout<<"  ---- Michel cand "<<N_MichelCandidates<<std::endl;
  std::cout<<"  ------ NonBG     "<<N_MichelNonBG<<std::endl<<std::endl;
  std::cout<<"  total PEs        "<<N_PEs<<std::endl;
  std::cout<<"  PE rate          "<<(float)N_PEs/(T_PEs*1e-09)<<" Hz"<<std::endl;
  std::cout<<"================================\n";

  
}


void MichelWfmReco::endRun(art::Run & r)
{
}

void MichelWfmReco::endSubRun(art::SubRun & sr)
{
}

void MichelWfmReco::reconfigure(fhicl::ParameterSet const & pset)
{
  fTriggerUtility         = pset.get< std::string >("TriggerUtility","FragmentToDigit");
  bUseTriggerFilter       = pset.get< bool >("UseTriggerFilter","false");
  bUseTrackInformation    = pset.get< bool >("UseTrackInformation","true");
  fDAQModule              = pset.get< std::string >("DAQModule","daq");
  fTrackModule            = pset.get< std::string >("TrackModule","pmtrack");
  fTrackCalModule         = pset.get< std::string >("TrackCalModule","calo");
  fParticleIDModule       = pset.get< std::string >("ParticleIDModule","pid");
  fInstanceName           = pset.get< std::string >("InstanceName","");
  fBaselineWindowLength   = pset.get< short >("BaselineWindowLength",1000);
  fPromptWindowLength     = pset.get< short >("PromptWindowLength",100);
  fFullWindowLength       = pset.get< short >("FullWindowLength",7000);
  fIntegrationWindows     = pset.get< std::vector<short> >("IntegrationWindows");
  fPrePulseBaselineFit    = pset.get< short >("PrePulseBaselineFit",1000);
  fPrePulseDisplay        = pset.get< short >("PrePulseDisplay",500);
  fFiducialMargin_X       = pset.get< float>("FiducialMargin_X",5.);
  fFiducialMargin_Y       = pset.get< float>("FiducialMargin_Y",4.);
  fFiducialMargin_Z       = pset.get< float>("FiducialMargin_Z",5.);
  fTimestampCut           = pset.get< float>("TimestampCut",5.4);
  fGateDelay              = pset.get< short >("GateDelay",300);
  fSinglePE               = pset.get< float>("SinglePE",90.);
  fAveWfmCut_Dt           = pset.get< float>("AveWfmCut_Dt",300.);
  fCorrectAveWfms         = pset.get< bool>("CorrectAveWfms","true");
  fSaveHitWfmsToTree      = pset.get< bool>("SaveHitWfmsToTree","false");
  fSaveAllTrackInfoToTree = pset.get< bool>("SaveAllTrackInfoToTree","false");
  fUsePrepulseFit         = pset.get< bool>("UsePrepulseFit","true");
  fHitTimeCutoffLow       = pset.get< int>("HitTimeCutoffLow",-100000);
  fHitTimeCutoffHigh      = pset.get< int>("HitTimeCutoffHigh",100000);
  fPrePulseDisplay        = pset.get< short>("PrePulseDisplay",500);
  fPromptLightDtCut       = pset.get< short>("PromptLightDtCut",25);
  fLY                     = pset.get< float>("LightYield",2.3);
  fMvPerADC               = pset.get< float >("MvPerADC",0.2);
  fHitPromptPEThreshLow   = pset.get< float >("HitPromptPEThreshLow",0);
  fTriggerTolerancePercent= pset.get< float >("TriggerTolerancePercent",1.5);
}

void MichelWfmReco::respondToCloseInputFile(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToCloseOutputFiles(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToOpenInputFile(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToOpenOutputFiles(art::FileBlock const & fb)
{
}

// Function for determining if a point is inside or outside
// predefined fiducial volume
bool MichelWfmReco::IsPointInFiducialVolume(TVector3 p)
{
  float Lx = 47.;
  float Ly = 40.;
  float Lz = 90.;
  if( (fabs(p.Y()       ) > Ly/2. - fFiducialMargin_Y) ||
      (fabs(p.X()-Lx/2. ) > Lx/2. - fFiducialMargin_X) ||
      (fabs(p.Z()-Lz/2. ) > Lz/2. - fFiducialMargin_Z) )
  {
    return false;
  } else {
    return true;
  }
}

// Function for determining if hit is associated with trigger
bool MichelWfmReco::IsHitAtTrigger(short hit, short trigger_sample, int n, float tol)
{
  return fabs(hit - trigger_sample) <= (float)n*tol*0.01;
}

DEFINE_ART_MODULE(MichelWfmReco)
