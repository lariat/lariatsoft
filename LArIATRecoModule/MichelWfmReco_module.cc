////////////////////////////////////////////////////////////////////////
// Class:       MichelWfmReco
// Module Type: producer
// File:        MichelWfmReco_module.cc
//
// This module is used to perform some ID and reconstruction of PMT
// waveforms from stopping/decaying muons (primarily in the Michel 
// trigger sample).
//
// Eventually it may be used to create a new data product related to 
// Michel events, but for now, it does not add to the data file.
//
// Output histograms include:
//  - # hits found in each waveform
//  - amplitude of Michel-candidate pulses
//  - integrated charge of Michel candidates (100ns window)
//  - time difference between 1st and 2nd pulse
//    when exactly two pulses are found
//
// Authors: William Foreman, wforeman@uchicago.edu
//
// Generated at Wed Jul 15 13:09:43 2015 by William Foreman using artmod
// from cetpkgsupport v1_08_06.
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

//C++ Includes
#include <iostream>
#include <fstream>
#include <vector>
#include <memory>
#include <utility>

//ROOT Includes
#include <TH1F.h>

// LArSoft Includes
#include "Utilities/AssociationUtil.h"
#include "RawData/TriggerData.h"

//LAriatSoft Includes
#include "RawDataUtilities/TriggerDigitUtility.h"
#include "LArIATRecoAlg/OpHitBuilderAlg.h"
#include "LArIATRecoAlg/TriggerFilterAlg.h"
#include "Utilities/DatabaseUtilityT1034.h"


class MichelWfmReco;

class MichelWfmReco : public art::EDProducer {
public:
  explicit MichelWfmReco(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MichelWfmReco(MichelWfmReco const &) = delete;
  MichelWfmReco(MichelWfmReco &&) = delete;
  MichelWfmReco & operator = (MichelWfmReco const &) = delete;
  MichelWfmReco & operator = (MichelWfmReco &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Name of the module producing the triggers
  std::string fTriggerUtility;

  // Switch to use the trigger filter or not
  bool      bUseTriggerFilter;
  Double_t  fGradientHitThreshold;
  
  // Alg objects
  OpHitBuilderAlg   fOpHitBuilderAlg; 
  TriggerFilterAlg  fTrigFiltAlg;
};



MichelWfmReco::MichelWfmReco(fhicl::ParameterSet const & p)
: fOpHitBuilderAlg(p), fTrigFiltAlg(p)
{

  // Configures the ROOT histograms
  this->reconfigure(p);
  
  // Produces the LArSoft object to be outputted
  // (none for now!) 
  
}


void MichelWfmReco::produce(art::Event & e)
{

  std::cout << "Here we are... in MichelWfmReco::produce\n";

  // Set up loop over triggers in the inputted ROOT file
  rdu::TriggerDigitUtility tdu(e, fTriggerUtility);

  // Defint the vector of associations to be saved
  // (none yet!)

  // Loop over the triggers
  for(size_t trig = 0 ; trig < tdu.NTriggers(); ++trig){
    
    std::cout<<"Trigger "<<trig<<"\n";

    // Global trigger that will be used to make associations
    art::Ptr<raw::Trigger> theTrigger = tdu.EventTriggersPtr()[trig];
    raw::Trigger thisTrigger = *theTrigger;
    
    bool isMichel; 
    // filter for MICHEL trigger
    if (bUseTriggerFilter){
      std::string myFilter = "+MICHEL";
      isMichel = fTrigFiltAlg.doesTriggerPassFilter( thisTrigger, myFilter ); 
    } else {
      isMichel = 1;
    }

    if ( isMichel ){
      
      std::cout<<"We're about to try getting the waveform....\n";

      // get the OpDetPulses; skip if empty
      art::PtrVector<raw::OpDetPulse> OpPulses = tdu.TriggerOpDetPulsesPtr(trig);

      std::cout<<"We got it..  size = "<<OpPulses.size()<<"\n";
      if ( OpPulses.size() == 0 ) continue;
      
      // loop through the pulses
      for (unsigned int i=0; i < OpPulses.size(); ++i){

        std::cout<<"   ... pulse \n";

        // get the OpDetPulses
        raw::OpDetPulse ThePulse = *OpPulses[i];
        std::cout<<"   waveform length: "<<ThePulse.Waveform().size()<<std::endl;

        std::cout<<"   opchannel      : "<<ThePulse.OpChannel()<<std::endl;
        // if this is the ETL, continue onward
        if (ThePulse.OpChannel() == 1){

          std::cout << "Huzzah! it's the ETL!\n";
          // save the ETL waveform into a new vector of shorts
          std::vector<short> ETL_waveform = ThePulse.Waveform();
             
          // perform hit-finding/filtering
          std::vector<short> hit_times = fOpHitBuilderAlg.GetHits(ETL_waveform, fGradientHitThreshold);

          std::cout << "We found "<<hit_times.size()<<" hits\n";
          for (unsigned int i=0; i<hit_times.size(); i++){
            std::cout<<"   "<<i<<"    t = "<<hit_times[i]<<"\n";
          }


          //printf("Size of ETL waveform is %lu",n);
        } // <-- endif PMT is ETL (OpChannel == 1)
      
      
      }

    } // <-- endif isMichel
    
  
  } //<-- End loop over triggers

  

}

void MichelWfmReco::beginJob()
{
}

void MichelWfmReco::beginRun(art::Run & r)
{
  fTrigFiltAlg.loadXMLDatabaseTable( r.run() ); 
}

void MichelWfmReco::beginSubRun(art::SubRun & sr)
{
}

void MichelWfmReco::endJob()
{
}

void MichelWfmReco::endRun(art::Run & r)
{
}

void MichelWfmReco::endSubRun(art::SubRun & sr)
{
}

void MichelWfmReco::reconfigure(fhicl::ParameterSet const & p)
{
  // Pass name of TriggerUtility
  fTriggerUtility       = p.get< std::string >("TriggerUtility","FragmentToDigit");
  bUseTriggerFilter      = p.get< bool >("UseTriggerFilter","false");
  fGradientHitThreshold  = p.get< Double_t >("GradientHitThreshold",-10);
  
}

void MichelWfmReco::respondToCloseInputFile(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToCloseOutputFiles(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToOpenInputFile(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToOpenOutputFiles(art::FileBlock const & fb)
{
}

DEFINE_ART_MODULE(MichelWfmReco)
