////////////////////////////////////////////////////////////////////////
// Class:       MichelWfmReco
// Module Type: producer
// File:        MichelWfmReco_module.cc
//
// This module is used to perform some ID and reconstruction of PMT
// waveforms from stopping/decaying muons (primarily in the Michel 
// trigger sample).
//
// Eventually it may be used to create a new data product related to 
// Michel events, but for now, it does not add to the data file (despite
// being a producer).
//
// Authors: William Foreman, wforeman@uchicago.edu
//
// Generated at Wed Jul 15 13:09:43 2015 by William Foreman using artmod
// from cetpkgsupport v1_08_06.
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"

//C++ Includes
#include <iostream>
#include <fstream>
#include <vector>
#include <memory>
#include <utility>

//ROOT Includes
#include <TF1.h>
#include <TH1F.h>
#include <TH1I.h>
#include <TH2F.h>
#include <TH3F.h>
#include <TTree.h>

// LArSoft Includes
#include "Utilities/AssociationUtil.h"
#include "RawData/TriggerData.h"
#include "RecoBase/Track.h"
#include "AnalysisBase/Calorimetry.h"
#include "AnalysisBase/ParticleID.h"

//LAriatSoft Includes
#include "RawDataUtilities/TriggerDigitUtility.h"
#include "LArIATRecoAlg/OpHitBuilderAlg.h"
#include "LArIATRecoAlg/TriggerFilterAlg.h"
#include "Utilities/DatabaseUtilityT1034.h"


class MichelWfmReco;

class MichelWfmReco : public art::EDProducer {
public:
  explicit MichelWfmReco(fhicl::ParameterSet const & pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MichelWfmReco(MichelWfmReco const &) = delete;
  MichelWfmReco(MichelWfmReco &&) = delete;
  MichelWfmReco & operator = (MichelWfmReco const &) = delete;
  MichelWfmReco & operator = (MichelWfmReco &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & pset) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;
  
  // Custom functions
  bool IsPointInFiducialVolume(TVector3);

private:

  // Name of the module producing the triggers
  std::string fTriggerUtility;

  // Tunable parameters from fcl
  bool            bUseTriggerFilter;
  bool            bUseTrackInformation;
  bool            bVerbose;
  std::string     fDAQModule;
  std::string     fTrackModule;
  std::string     fParticleIDModule;
  std::string     fTrackCalModule;
  std::string     fInstanceName;
  float          fTimestampCut;
  short           fGateDelay;
  short           fBaselineWindowLength;
  short           fPromptWindowLength;
  short           fFullWindowLength;
  short           fPrePulseBaselineFit;
  float          fFiducialMargin_X;
  float          fFiducialMargin_Y;
  float          fFiducialMargin_Z; 
  float          fSinglePE;
  float          fAveWfmCut_Dt;
  bool            fCorrectAveWfms;
  bool            fSaveHitWfmsToTree;
  bool            fSaveAllTrackInfoToTree;
  float           fHitTimeCutoffLow;
  float           fHitTimeCutoffHigh;

  // Alg objects
  OpHitBuilderAlg   fOpHitBuilderAlg; 
  OpHitBuilderAlg   fOpHitBuilderAlg_ave1;
  OpHitBuilderAlg   fOpHitBuilderAlg_ave2;
  OpHitBuilderAlg   fOpHitBuilderAlg_aveMIP;
  OpHitBuilderAlg   fOpHitBuilderAlg_aveProton;
  TriggerFilterAlg  fTrigFiltAlg;

  // Variables/vectors
  int                   iEvent;
  bool                  GotETL;
  bool                  flag;
  std::vector<short>    ETL_waveform;
  short                 PostPercentMark;
  int                   NSamples;
  int                   MuTrackIndex;
  TVector3              region_centerpoint;
  float                region_radius;
  std::vector<float>   hit_info;
  std::vector<TVector3> vTrackVertex;
  std::vector<TVector3> vTrackEnd;
  TVector3              MuTrackVertex;
  TVector3              MuTrackEnd;
  int                   HitWaveformBins;

  // Histograms
  TH1I* h_NumOpHits;
  TH2I* h_NumOpHits_vs_NumTracks;
  TH1I* h_NumOpHits_beam;
  TH1I* h_NumOpHits_offbeam;
  TH1F* h_DeltaTime_chargeCut;
  TH1F* h_DeltaTime_stoppingMu;
  TH1F* h_DeltaTime_chargeCut_beam;

  TH1F* h_Amplitude;
  TH1F* h_HitTime;
  TH1F* h_HitAmplitude;
  TH1F* h_HitPromptPE;
  TH1F* h_Charge100ns;
  TH1F* h_Charge100ns_populationCut;
  TH1F* h_Charge100ns_populationCut_DtCut;
  TH1F* h_Charge100ns_stoppingMu;
  TH1F* h_Charge100ns_region;
  TH1F* h_ChargeFull_populationCut;
  TH1F* h_ChargeFull_populationCut_DtCut;
  TH1F* h_ChargeFull_region;
  TH1F* h_PromptPE;
  TH1F* h_PromptPE_region;
  TH1F* h_FullPE_region;
  TH2F* h_PromptFraction_vs_Amplitude;
  TH2F* h_PromptPE_vs_Amplitude;
  TH1F* h_TrackVertex_x;
  TH1F* h_TrackVertex_y;
  TH1F* h_TrackVertex_z;
  TH1F* h_TrackEnd_x;
  TH1F* h_TrackEnd_y;
  TH1F* h_TrackEnd_z;
  TH2F* h_TrackNode_zx;
  TH2F* h_TrackNode_zy;
  TH2F* h_TrackEnergy_vs_PromptLight;
  TH2I* h_InFiducialVolume;
  TH1F* h_SecondTrackOffset;
  TH1F* h_AverageWaveform1;
  TH1F* h_AverageWaveform2;
  TH1F* h_AverageWaveformMIP;
  TH1F* h_AverageWaveformProton;

  // Storing run information
  int                     RunNumber;
  int                     SubRunNumber;
  int                     EventNumber;
  float                  Timestamp;

  // Storing optical hit information
  int                     NumHits;
  std::vector<short>      vHitTimes;
  std::vector<float>     vHitAmplitude;
  std::vector<float>     vHitPromptLight;
  std::vector<float>     vHitFullLight;
  std::vector<float>     vHitPE_Prompt;
  std::vector<float>     vHitPE_Full;
  std::vector<float>     vPrepulseBaseline;
  std::vector<float>     vPrepulseRMS;
  std::vector<float>     vPrepulseFastNorm;
  std::vector<float>     vPrepulseFastTau;
  std::vector<float>     vPrepulseSlowNorm;
  std::vector<float>     vPrepulseSlowTau;
  std::vector<float>     vPrepulseReducedChi2;
  std::vector<float>     vHitPromptFraction;
  std::vector<int>        vIsInBGPopulation; 
  std::vector<short>      HitWaveform; 
  int                     HitWaveformIndex;
  float                  WaveformBaseline;
  float                  WaveformBaselineRMS;
  int                     IsBeamEvent;
  int                     IsCleanBeamWaveform;
  float                  DeltaTime;
  float                  Amplitude;
  float                  Charge_100ns; 
  float                  Charge_Full;
  float                  PE_Prompt; 
  float                  PE_Full;
  float                  PromptFraction;
  
  // Storing track infornatuib
  int                     NumTracks;
  std::vector<float>     vTrackVertex_x;
  std::vector<float>     vTrackVertex_y;
  std::vector<float>     vTrackVertex_z;
  std::vector<float>     vTrackEnd_x;
  std::vector<float>     vTrackEnd_y;
  std::vector<float>     vTrackEnd_z;
  std::vector<int>        vIsTrackStopping;
  std::vector<int>        vIsTrackPassing;
  std::vector<int>        vIsTrackContained;
  std::vector<int>        vTrackPID;
  std::vector<float>     vTrackPIDA;
  std::vector<float>     vTrackEnergy;
  std::vector<float>     vTrackLength;
  int                     IsSinglePassingTrack;
  int                     IsSingleStoppingTrack;
  float                  StoppingTrackZenithAngle;
  float                  PassingTrackZenithAngle;
  float                  MuTrackVertex_x;
  float                  MuTrackVertex_y;
  float                  MuTrackVertex_z;
  float                  MuTrackEnd_x;
  float                  MuTrackEnd_y;
  float                  MuTrackEnd_z;
  float                  MuTrackLength;
  float                  MuTrackEnergy;
  int                     MuAmplitude;
  float                  MuCharge_100ns;
  float                  SecondTrackProximity;
  float                  SecondTrackLength;
  float                  SecondTrackEnergy;
  int                     IsSecondTrackContained;
  
  // TTree info
  TTree* MichelDataTree;

};



MichelWfmReco::MichelWfmReco(fhicl::ParameterSet const & pset)
: fOpHitBuilderAlg(pset), fOpHitBuilderAlg_ave1(pset), fOpHitBuilderAlg_ave2(pset), fOpHitBuilderAlg_aveMIP(pset), fOpHitBuilderAlg_aveProton(pset), fTrigFiltAlg(pset)
{

  // Configures the ROOT histograms
  this->reconfigure(pset);
  
  // Produces the LArSoft object to be outputted
  // (none for now!) 
 
  // TO DO: make this a fcl parameter 
  region_centerpoint.SetXYZ(23.5,0.,45.);
  region_radius = 10.;

  // Some instances of OpHitBuilder were created solely 
  // to save summed/average waveforms:
  fOpHitBuilderAlg_ave1.AddHitToAverageWaveform = 1;  
  fOpHitBuilderAlg_ave2.AddHitToAverageWaveform = 1;  
  fOpHitBuilderAlg_aveMIP.AddHitToAverageWaveform = 1;  
  fOpHitBuilderAlg_aveProton.AddHitToAverageWaveform = 1;  
 
  // Switch to apply baseline correction (prepulse
  // expeonential fit method) to averaged waveforms:
  if(fCorrectAveWfms){ 
    fOpHitBuilderAlg_ave1.fUsePrepulseFit = true;  
    fOpHitBuilderAlg_ave2.fUsePrepulseFit = true;  
    fOpHitBuilderAlg_aveMIP.fUsePrepulseFit = true;  
    fOpHitBuilderAlg_aveProton.fUsePrepulseFit = true; 
  } else {
    fOpHitBuilderAlg_ave1.fUsePrepulseFit = false;  
    fOpHitBuilderAlg_ave2.fUsePrepulseFit = false;  
    fOpHitBuilderAlg_aveMIP.fUsePrepulseFit = false;  
    fOpHitBuilderAlg_aveProton.fUsePrepulseFit = false; 
  }

  HitWaveformBins = (int)fPrePulseBaselineFit+(int)fFullWindowLength;
  HitWaveform.reserve(HitWaveformBins);

}


void MichelWfmReco::produce(art::Event & e)
{
  iEvent++;

  // Initialize variables to be saved into tree
  NumHits = -9;
  RunNumber         = -9;
  SubRunNumber      = -9;
  EventNumber       = -9;
  Timestamp         = -9.; 
  IsCleanBeamWaveform = -9;
  IsBeamEvent       = -9;
  NumTracks         = -9;
  IsSingleStoppingTrack   = 0;
  IsSinglePassingTrack    = 0;
  StoppingTrackZenithAngle = -1;
  PassingTrackZenithAngle   = -1;
  vTrackVertex_x.clear();
  vTrackVertex_y.clear();
  vTrackVertex_z.clear();
  vTrackEnd_x.clear();
  vTrackEnd_y.clear();
  vTrackEnd_z.clear();
  vTrackEnergy.clear();
  vTrackLength.clear();
  vTrackPID.clear();
  vTrackPIDA.clear();
  vIsTrackStopping.clear();
  vIsTrackPassing.clear();
  vIsTrackContained.clear();
  MuTrackVertex_x   = -99.;
  MuTrackVertex_y  = -99.;
  MuTrackVertex_z   = -99.;
  MuTrackEnd_x      = -99.;
  MuTrackEnd_y      = -99.;
  MuTrackEnd_z      = -99.;
  MuTrackLength     = -99.;
  MuTrackEnergy     = -99.;
  MuAmplitude       = -99;
  MuCharge_100ns    = -999.;
  DeltaTime         = -99.;
  Amplitude         = -99.;
  Charge_100ns      = -9999.;
  Charge_Full       = -99999.;
  PE_Prompt         = -9.;
  PE_Full           = -99.;
  PromptFraction    = -9.;
  WaveformBaseline  = -99.;
  WaveformBaselineRMS = -9.;
  SecondTrackLength = -9.;
  SecondTrackEnergy = -9.;
  SecondTrackProximity = -9.;
  IsSecondTrackContained = -9;
  vHitTimes.clear();
  vHitAmplitude.clear();
  vHitPromptLight.clear();
  vHitFullLight.clear();
  vHitPE_Prompt.clear();
  vHitPE_Full.clear();
  vIsInBGPopulation.clear();
  vPrepulseBaseline.clear();
  vPrepulseRMS.clear();
  vPrepulseFastNorm.clear();
  vPrepulseFastTau.clear();
  vPrepulseSlowNorm.clear();
  vPrepulseSlowTau.clear();
  vPrepulseReducedChi2.clear();
  vHitPromptFraction.clear();
  vTrackVertex.clear();
  vTrackEnd.clear();

  if(fSaveHitWfmsToTree){
    for(unsigned int i=0; i<HitWaveform.size(); i++) HitWaveform[i] = 0;
    HitWaveformIndex = -9;
  }

  // Get run and event number
  RunNumber     = (int)e.run();
  SubRunNumber  = (int)e.subRun();
  EventNumber   = (int)e.event();
  
  
  // Filter for the MICHEL trigger pattern (note that for some runs, particularly for 
  // those with the optimized Michel trigger setup, unfortunately the trigger inputs 
  // were not being saved and thus the filter won't work).
  /*
  bool isMichel = 1; 
  if (bUseTriggerFilter){
    std::string myFilter = "+MICHEL";
    isMichel = fTrigFiltAlg.doesTriggerPassFilter( thisTrigger, myFilter ); 
  } else {
    isMichel = 1;
  }
  if ( !isMichel ) return;
  */

  // Get the OpDetPulses; skip event if empty
  art::Handle< std::vector< raw::OpDetPulse >> WaveformHandle;
  e.getByLabel(fDAQModule,fInstanceName,WaveformHandle);
  if( (int)WaveformHandle->size() == 0 ) {
    if(bVerbose) std::cout<<"No optical detector data found -- skipping the event\n";
    return;
  } else {
    // If not empty, store ETL waveform
    GotETL = false;
    for( int ipulse = 0; ipulse < (int)WaveformHandle->size(); ipulse++){
      art::Ptr< raw::OpDetPulse > ThePulsePtr(WaveformHandle,ipulse);
      raw::OpDetPulse ThePulse = *ThePulsePtr;
      if( ThePulse.OpChannel() == 1) {
        ETL_waveform = ThePulse.Waveform();
        NSamples = ETL_waveform.size();
        Timestamp = (float(ThePulse.PMTFrame())*8.)/1.0e09;
        PostPercentMark = short(ThePulse.FirstSample()); 
        GotETL = true;
        
        if(bVerbose){
          std::cout<<"ETL pulse recorded."<<std::endl;
          std::cout<<"  Nsamples = "<<NSamples<<std::endl;
          std::cout<<"  PMTFrame = "<<ThePulse.PMTFrame()<<std::endl;
          std::cout<<"  FirstSample = "<<ThePulse.FirstSample()<<std::endl;
          std::cout<<"  Timestamp = "<<Timestamp<<" sec"<<std::endl;
        }

        // Is clean beam waveform? (for testing out function)
        //IsCleanBeamWaveform = fOpHitBuilderAlg.IsCleanBeamWaveform(ThePulse);
      }
    }
  }
  // If we somehow didn't get the ETL, skip the event
  if( !GotETL ) return;

  // Classify as beam or non-beam event (allow 0.1s buffer around cutoff just to be safe)
  if ( (Timestamp >= 0)&&(Timestamp < fTimestampCut-0.1)){ IsBeamEvent = 1;}
  else if (Timestamp >= fTimestampCut+0.1) { IsBeamEvent = 0;}

  //  Get waveform baseline/RMS
  std::vector<float> tmp = fOpHitBuilderAlg.GetBaselineAndRMS(ETL_waveform,0,fBaselineWindowLength);
  WaveformBaseline = tmp[0];
  WaveformBaselineRMS = tmp[1];
  if(bVerbose) std::cout<<"Baseline: "<<WaveformBaseline<<"  RMS: "<<WaveformBaselineRMS<<"\n";

  // Perform hit-finding/filtering
  vHitTimes = fOpHitBuilderAlg.GetHits(ETL_waveform);
  NumHits = vHitTimes.size();
  if(bVerbose) {
    std::cout << "Performing optical hitfinding...\n"; 
    std::cout << "We found "<<NumHits<<" hits\n";
  }
  
  // If exactly 2 hits, measure their time difference
  if(NumHits == 2){
    DeltaTime = float(vHitTimes[1] - vHitTimes[0]);
    if(bVerbose) std::cout<<"    DeltaT = "<<DeltaTime<<std::endl;
  }
  
  // For each hit, do all the needed reconstruction in single function call
  for (int i=0; i<NumHits; i++){
    if(bVerbose) std::cout<<"----- Processing hit "<<i<<"    t = "<<vHitTimes[i]<<" ------\n";
    hit_info = fOpHitBuilderAlg.GetHitInfo(ETL_waveform, vHitTimes[i]);
    
    h_HitTime       ->Fill(vHitTimes[i]);
    vHitAmplitude.push_back(hit_info[0]);
    h_HitAmplitude  ->Fill(vHitAmplitude[i]);
    vHitPromptLight.push_back(hit_info[1]);
    vHitFullLight.push_back(hit_info[2]);
    vHitPE_Prompt.push_back(hit_info[1]/fSinglePE);
    vHitPE_Full.push_back(hit_info[2]/fSinglePE); 
    h_HitPromptPE   ->Fill(vHitPE_Prompt[i]);
    vPrepulseBaseline.push_back(fOpHitBuilderAlg.prepulse_baseline);
    vPrepulseRMS.push_back(fOpHitBuilderAlg.prepulse_rms);
    vPrepulseFastNorm.push_back(fOpHitBuilderAlg.fit_FastNorm);
    vPrepulseFastTau.push_back(fOpHitBuilderAlg.fit_FastTau); 
    vPrepulseSlowNorm.push_back(fOpHitBuilderAlg.fit_SlowNorm);
    vPrepulseSlowTau.push_back(fOpHitBuilderAlg.fit_SlowTau); 
    vPrepulseReducedChi2.push_back(fOpHitBuilderAlg.fit_ReducedChi2);
    vHitPromptFraction.push_back(hit_info[1]/hit_info[2]);

    if( fabs(vHitTimes[i]-PostPercentMark) <= 0.015*(float)NSamples ){
      h_PromptFraction_vs_Amplitude->Fill(vHitPromptFraction[i],vHitAmplitude[i]);
    }
    
    // Line in PE (#,x) vs. amplitude (mV,y) space to cut out background. 
    TF1 f_PopulationCut("f_PopulationCut","1.714*x - 35.13",0.,1000.);
    if( vHitPE_Prompt[i] > 0.){
      if( vHitAmplitude[i] > f_PopulationCut.Eval(vHitPE_Prompt[i])){ 
        vIsInBGPopulation.push_back(1);
      } else {
        vIsInBGPopulation.push_back(0); 
      }
    }
  
  }
 
  // Is clean beam waveform?
  if( (IsBeamEvent)&&(NumHits == 1)&&( abs(vHitTimes[0]-PostPercentMark) <= 0.015*(float)NSamples) ){
    IsCleanBeamWaveform = 1;
  } else {
    IsCleanBeamWaveform = 0;
  }
  

  if(bUseTrackInformation){ 
    
    // Get the tracks and their associated energy
    art::Handle< std::vector< recob::Track >> TrackHandle;
    e.getByLabel(fTrackModule,TrackHandle);
  
    // Fill tracklist... (not used right now)
    //std::vector< art::Ptr< recob::Track >> tracklist; 
    //if (e.getByLabel(fTrackModule,TrackHandle))
    //   {art::fill_ptr_vector(tracklist, trackListHandle);}

    NumTracks = (int)TrackHandle->size();

    if(bVerbose) std::cout<<"Number of tracks: "<<NumTracks<<"\n";
  
    // === Association between Calorimetry objects and Tracks ===
    art::FindManyP<anab::Calorimetry> fmcal(TrackHandle, e, fTrackCalModule);
    // === Association between PID objects and Tracks ===
    art::FindManyP<anab::ParticleID>  fmpid(TrackHandle, e, fParticleIDModule);
    
    // Loop through the track list and store their properties
    for( int track_index = 0; track_index < NumTracks; track_index++){
  
      // Get the recob::Track object and record its endpoint/vertex
      art::Ptr< recob::Track > TheTrackPtr(TrackHandle,track_index);
      recob::Track TheTrack = *TheTrackPtr;
      vTrackEnd.push_back(TheTrack.End());
      vTrackVertex.push_back(TheTrack.Vertex());
      vTrackLength.push_back(TheTrack.Length());
    
      vTrackVertex_x.push_back(TheTrack.Vertex().X());
      vTrackVertex_y.push_back(TheTrack.Vertex().Y());
      vTrackVertex_z.push_back(TheTrack.Vertex().Z());
      vTrackEnd_x.push_back(TheTrack.End().X()); 
      vTrackEnd_y.push_back(TheTrack.End().Y()); 
      vTrackEnd_z.push_back(TheTrack.End().Z()); 

      bool endIsInFid = IsPointInFiducialVolume(TheTrack.End());
      bool vertexIsInFid = IsPointInFiducialVolume(TheTrack.Vertex());
      int temp_flag = ((!endIsInFid && vertexIsInFid)||(endIsInFid && !vertexIsInFid));
      
      // Is track stopping, passing, or contained?
      vIsTrackStopping.push_back( temp_flag);
      vIsTrackPassing.push_back(   !endIsInFid && !vertexIsInFid);
      vIsTrackContained.push_back( endIsInFid && vertexIsInFid );
      
      /*
      if(bVerbose){
        std::cout<<"  track "<<track_index<<" vertex("
        << TheTrack.Vertex().X() <<"," 
        << TheTrack.Vertex().Y() << "," 
        << TheTrack.Vertex().Z() << ")->InFiducial()="
        << vertexIsInFid 
        << "   end("
        << TheTrack.End().X() <<"," 
        << TheTrack.End().Y() << "," 
        << TheTrack.End().Z() << ")->InFiducial()="
        << endIsInFid << std::endl;
      }
      */

      h_InFiducialVolume->Fill(vertexIsInFid,endIsInFid);

      h_TrackNode_zx->Fill(TheTrack.Vertex().Z(),TheTrack.Vertex().X());
      h_TrackNode_zx->Fill((float)TheTrack.End().Z(),(float)TheTrack.End().X());
      h_TrackNode_zy->Fill((float)TheTrack.Vertex().Z(),(float)TheTrack.Vertex().Y());
      h_TrackNode_zy->Fill((float)TheTrack.End().Z(),(float)TheTrack.End().Y());
      

      // ################################################### 
      // ### Looping over calorimetry info for the track ###
      // ################################################### 
      if( fmcal.isValid() ){
        std::vector<art::Ptr<anab::Calorimetry> > calos = fmcal.at(track_index);
        // calos[0] is from induction plane
        // calos[1] is from collection plane
        vTrackEnergy.push_back(calos[1]->KineticEnergy());
        //if(bVerbose) std::cout<<"  KE = "<<calos[1]->KineticEnergy()<<std::endl; 
      } else {
        //if(bVerbose) std::cout<<"  KE = undefined"<<std::endl;
        vTrackEnergy.push_back(-99.);
      }
   
      // ################################################## 
      // ### Looping over PID information for the track ###
      // ################################################## 
      if (fmpid.isValid()){
        std::vector<art::Ptr<anab::ParticleID> > pids = fmpid.at(track_index);
        // pids[0] = induction
        // pids[1] = collection
        if (!pids[1]->PlaneID().isValid) {
        //if(bVerbose) std::cout<<"  pid["<<track_index<<"]: undefined\n";
          vTrackPID.push_back(-99); 
          vTrackPIDA.push_back(-99);
          continue;
        }
        vTrackPID.push_back(pids[1]->Pdg());
        vTrackPIDA.push_back(pids[1]->PIDA());
        //if(bVerbose) std::cout<<"  pid["<<track_index<<"]: "<<pids[1]->Pdg()<<"\n";
      } else {
        //if(bVerbose) std::cout<<"  pid["<<track_index<<"]: undefined\n";
        vTrackPID.push_back(-99);
        vTrackPIDA.push_back(-99);
      }

    
    
    } // End loop over tracks  

    // --------------------------------------
    // Higher-level track filtering:
    
    // Require no more than two tracks in the event:
    if( NumTracks <= 2 ) {
      
      flag = false;
  
      // Cycle through tracks
      for( int i=0; i<NumTracks; i++){
          
        // Since we don't want to blindly trust that the endpoint and 
        // vertex have been assigned correctly, let's say whichever 
        // has a higher Y-value is the vertex (pretty reasonable 
        // assumption for cosmic muons).
        TVector3 vertex;
        TVector3 end;
        if( vTrackVertex[i].Y() > vTrackEnd[i].Y()  ) { 
          vertex  = vTrackVertex[i]; 
          end     = vTrackEnd[i];
        } else {
          vertex  = vTrackEnd[i];
          end     = vTrackVertex[i];
        }
      
        // Fill histograms
        h_TrackEnd_x->Fill(end.X());
        h_TrackEnd_y->Fill((float)end.Y());
        h_TrackEnd_z->Fill((float)end.Z());
        h_TrackVertex_x->Fill((float)vertex.X());
        h_TrackVertex_y->Fill((float)vertex.Y());
        h_TrackVertex_z->Fill((float)vertex.Z());

         
        // If there's a single stopping track, fill Mu variables
        if( !flag && vIsTrackStopping[i] ) {
          
          // If there was already a stopping track, this disqualifies 
          // the event.
          if( IsSingleStoppingTrack ){
            IsSingleStoppingTrack = 0;
            flag = true;
            MuTrackVertex_x   = -99.;
            MuTrackVertex_y   = -99.;
            MuTrackVertex_z   = -99.;
            MuTrackEnd_x      = -99.;
            MuTrackEnd_y      = -99.;
            MuTrackEnd_z      = -99.;
            MuTrackLength     = -9.;
            MuTrackEnergy     = -9.;
            StoppingTrackZenithAngle = -9.;
          } else { 
            MuTrackIndex = i;
            IsSingleStoppingTrack = 1;
            MuTrackVertex   = vertex;
            MuTrackEnd      = end;
            MuTrackVertex_x   = MuTrackVertex.X();
            MuTrackVertex_y   = MuTrackVertex.Y();
            MuTrackVertex_z   = MuTrackVertex.Z();
            MuTrackEnd_x      = MuTrackEnd.X();
            MuTrackEnd_y      = MuTrackEnd.Y();
            MuTrackEnd_z      = MuTrackEnd.Z();
            MuTrackLength   = vTrackLength[i];
            MuTrackEnergy   = vTrackEnergy[i];
            TVector3 vert(0.,1.,0.);
            TVector3 tmp = (vertex-end);
            StoppingTrackZenithAngle = tmp.Angle(vert);
          }
        
        }
      } 
    }
 
    // Look for single passing tracks
    if( (NumTracks == 1)&&( vIsTrackPassing[0])) {
      IsSinglePassingTrack = 1;
      MuTrackIndex = 0;
      MuTrackVertex   = vTrackVertex[0];
      MuTrackEnd      = vTrackEnd[0];
      MuTrackVertex_x   = MuTrackVertex.X();
      MuTrackVertex_y   = MuTrackVertex.Y();
      MuTrackVertex_z   = MuTrackVertex.Z();
      MuTrackEnd_x      = MuTrackEnd.X();
      MuTrackEnd_y      = MuTrackEnd.Y();
      MuTrackEnd_z      = MuTrackEnd.Z();
      MuTrackLength   = vTrackLength[0];
      MuTrackEnergy   = vTrackEnergy[0];

      TVector3 vert(0.,1.,0.);
      TVector3 tmp = (MuTrackVertex-MuTrackEnd);
      PassingTrackZenithAngle = tmp.Angle(vert);  
    }
  
    // If there was a stopping "muon" and a second track, check
    // to see if either of its endpoints is close to muon endpoint.
    if( IsSingleStoppingTrack && NumTracks == 2 ) {
      for( int i=0; i<NumTracks; i++){
        if( i != MuTrackIndex ){
          SecondTrackProximity = std::min( 
            (vTrackVertex[i] - MuTrackEnd).Mag(),
            (vTrackEnd[i]   - MuTrackEnd).Mag());
          h_SecondTrackOffset->Fill(SecondTrackProximity);
          SecondTrackLength = vTrackLength[i];
          SecondTrackEnergy = vTrackEnergy[i];
          IsSecondTrackContained = vIsTrackContained[i];
        }
      }  
    }

    // If there was 1 stopping or 1 passing track, get light info for the "muon"
    if( (IsSingleStoppingTrack||IsSinglePassingTrack) && (NumHits > 0)&&(NumHits <= 2) ) {
      MuAmplitude = vHitAmplitude[0];
      MuCharge_100ns = vHitPromptLight[0];
    }

  } //endif bUseTrackInformation

  if( (NumTracks==1)&&(NumHits==1)&&(vTrackEnergy[0]>0.)&&(vHitAmplitude[0]<190.)&&(vIsTrackPassing[0])){
    h_TrackEnergy_vs_PromptLight->Fill(vTrackEnergy[0],vHitPE_Prompt[0]);
  }
    

  // Fill NumOpHits histo (beam vs. offbeam)
  h_NumOpHits ->Fill(NumHits);
  h_NumOpHits_vs_NumTracks->Fill(NumHits,NumTracks);
  if(IsBeamEvent)   h_NumOpHits_beam    ->Fill(NumHits);
  if(!IsBeamEvent)  h_NumOpHits_offbeam ->Fill(NumHits);
  
        
  if(NumHits==2){      
    // Integral/amplitude of Michel pulse
    Amplitude     = vHitAmplitude[1];
    Charge_100ns  = vHitPromptLight[1];
    Charge_Full   = vHitFullLight[1];
    PE_Prompt     = Charge_100ns/fSinglePE;
    PE_Full       = Charge_Full/fSinglePE;
    PromptFraction= vHitPromptFraction[1];
    
    if(bVerbose) std::cout<<"    Amplitude     = "<<Amplitude<<std::endl;
    if(bVerbose) std::cout<<"    Charge prompt = "<<Charge_100ns<<" ("<<PE_Prompt<<" PEs)"<<std::endl;
    if(bVerbose) std::cout<<"    Charge full   = "<<Charge_Full<< " ("<<PE_Full<<" PEs)"<<std::endl;
  
  }
  
  if( (fSaveHitWfmsToTree)&&(NumHits>0)&&(NumHits<=2) ){
    // Save the waveform
    HitWaveformIndex = NumHits-1;
    for(int i=0; i<HitWaveformBins; i++){
      HitWaveform[i] = ETL_waveform[vHitTimes[HitWaveformIndex]-fPrePulseBaselineFit+i]; 
    }
  }
  
  
  // Michel event quality control:
  // Require 2 hits (one before PostPercent, one within 1% of PostPercent) 
  if( (NumHits == 2) && (vHitTimes[0] < vHitTimes[1]-fGateDelay) && ( abs(vHitTimes[1]-PostPercentMark) <= 0.01*NSamples) && (!IsBeamEvent)){
    
    if(bVerbose) std::cout << "--> passes Michel trigger cut (off-beam) \n";

    h_Amplitude               ->Fill(Amplitude);
    h_Charge100ns             ->Fill(Charge_100ns); 
    h_PromptPE                ->Fill(PE_Prompt);
    h_PromptPE_vs_Amplitude   ->Fill(PE_Prompt,Amplitude);
    
    if( Charge_100ns > 1800. ) {
      h_DeltaTime_chargeCut   ->Fill(DeltaTime);
    }

    if( !vIsInBGPopulation[1] ) {
      h_Charge100ns_populationCut->Fill(Charge_100ns);
      h_ChargeFull_populationCut->Fill(Charge_Full);
      
      if( DeltaTime > 3000. ){
        h_Charge100ns_populationCut_DtCut->Fill(Charge_100ns);
        h_ChargeFull_populationCut_DtCut->Fill(Charge_Full);
      } 
    }
  
    if( IsSingleStoppingTrack ) {
      h_Charge100ns_stoppingMu->Fill(Charge_100ns);
      h_DeltaTime_stoppingMu->Fill(DeltaTime);
      if( (MuTrackEnd-region_centerpoint).Mag() <= region_radius) {
        h_Charge100ns_region->Fill(Charge_100ns);
        h_ChargeFull_region->Fill(Charge_Full);
        h_PromptPE_region->Fill(PE_Prompt);
        h_FullPE_region->Fill(PE_Full);
      }
    }
     
    // Make average waveform of the "good" Michel events
    if( (DeltaTime > fAveWfmCut_Dt)&&(!vIsInBGPopulation[1])) fOpHitBuilderAlg_ave1.GetHitInfo(ETL_waveform,vHitTimes[1]);
    
    // Make average waveform of the BG events
    if( (DeltaTime > fAveWfmCut_Dt)&&(vIsInBGPopulation[1])) fOpHitBuilderAlg_ave2.GetHitInfo(ETL_waveform,vHitTimes[1]);

  } // end quality cut condition (off-beam)


  // Also look at DeltaTime of beam events where there was a delayed optical hit
  if( (NumHits == 2) && ( abs(vHitTimes[0]-PostPercentMark) <= 0.01*NSamples) && (IsBeamEvent) ){
    if( Charge_100ns > 1800 ) h_DeltaTime_chargeCut_beam->Fill(DeltaTime);
  }

  // Make average waveform of muons
  if( (NumHits==1)&&(NumTracks==1)&&( abs(vTrackPID[0])==13)
    &&( abs(vHitTimes[0]-PostPercentMark) <= 0.02*NSamples)) {
    fOpHitBuilderAlg_aveMIP.GetHitInfo(ETL_waveform,vHitTimes[0]);
  }
  
  // Make average waveform of beam protons
  if( (NumHits==2)&&(NumTracks==1)&&(abs(vTrackPID[0])==2212)&&(IsBeamEvent)
    &&( abs(vHitTimes[0]-PostPercentMark) <= 0.02*NSamples)) {
    fOpHitBuilderAlg_aveProton.GetHitInfo(ETL_waveform,vHitTimes[0]);
  }
  
  // Done with this event so fill the tree
  MichelDataTree->Fill();
  
  // Add space in printout to separate events (for easier debugging)
  if(bVerbose) std::cout<<std::endl;
}


void MichelWfmReco::beginJob()
{
  // Opens up the file service to read information from the ROOT file input
  art::ServiceHandle<art::TFileService> tfs;

  MichelDataTree  = tfs->make<TTree>("MichelDataTree","MichelDataTree");
 
  // Event identifying information 
  MichelDataTree  ->Branch("RunNumber",&RunNumber,"RunNumber/I");
  MichelDataTree  ->Branch("SubRunNumber",&SubRunNumber,"SubRunNumber/I");
  MichelDataTree  ->Branch("EventNumber",&EventNumber,"EventNumber/I");
  MichelDataTree  ->Branch("Timestamp",&Timestamp,"Timestamp/F");
  MichelDataTree  ->Branch("IsBeamEvent",&IsBeamEvent,"IsBeamEvent/I");

  // Waveform hit information
  if(fSaveHitWfmsToTree){
    MichelDataTree ->Branch("HitWaveform",&HitWaveform);
    MichelDataTree ->Branch("HitWaveformIndex",&HitWaveformIndex,"HitWaveformIndex/I");
  }
  MichelDataTree ->Branch("WaveformBaseline",&WaveformBaseline,"WaveformBaseline/F");
  MichelDataTree ->Branch("WaveformBaselineRMS",&WaveformBaselineRMS,"WaveformBaselineRMS/F");
  MichelDataTree ->Branch("NumHits",&NumHits,"NumHits/I");
  MichelDataTree ->Branch("HitTimes",&vHitTimes);
  MichelDataTree ->Branch("HitAmplitude",&vHitAmplitude);
  MichelDataTree ->Branch("HitPromptLight",&vHitPromptLight);
  MichelDataTree ->Branch("HitFullLight",&vHitFullLight); 
  MichelDataTree ->Branch("HitPE_Prompt",&vHitPE_Prompt);
  MichelDataTree ->Branch("HitPE_Full",&vHitPE_Full);
  MichelDataTree ->Branch("PrepulseBaseline",&vPrepulseBaseline);
  MichelDataTree ->Branch("PrepulseRMS",&vPrepulseRMS);
  MichelDataTree ->Branch("PrepulseFastNorm",&vPrepulseFastNorm);
  MichelDataTree ->Branch("PrepulseFastTau",&vPrepulseFastTau);
  MichelDataTree ->Branch("PrepulseSlowNorm",&vPrepulseSlowNorm);
  MichelDataTree ->Branch("PrepulseSlowTau",&vPrepulseSlowTau);
  MichelDataTree ->Branch("PrepulseReducedChi2",&vPrepulseReducedChi2);
  MichelDataTree ->Branch("IsInBGPopulation",&vIsInBGPopulation);
  MichelDataTree ->Branch("IsCleanBeamWaveform",&IsCleanBeamWaveform,"IsCleanBeamWaveform/I");
  MichelDataTree ->Branch("DeltaTime",&DeltaTime,"DeltaTime/F");
  MichelDataTree ->Branch("Amplitude",&Amplitude,"Amplitude/F");
  MichelDataTree ->Branch("Charge_100ns",&Charge_100ns,"Charge_100ns/F");
  MichelDataTree ->Branch("Charge_Full",&Charge_Full,"Charge_Full/F");
  MichelDataTree ->Branch("PE_Prompt",&PE_Prompt,"PE_Prompt/F");
  MichelDataTree ->Branch("PE_Full",&PE_Full,"PE_Full/F");
  
  // Track information
  MichelDataTree ->Branch("NumTracks",&NumTracks,"NumTracks/I");
  if(fSaveAllTrackInfoToTree){
    MichelDataTree ->Branch("TrackVertex_x",&vTrackVertex_x);
    MichelDataTree ->Branch("TrackVertex_y",&vTrackVertex_y);
    MichelDataTree ->Branch("TrackVertex_z",&vTrackVertex_z);
    MichelDataTree ->Branch("TrackEnd_x",&vTrackEnd_x);
    MichelDataTree ->Branch("TrackEnd_y",&vTrackEnd_y);
    MichelDataTree ->Branch("TrackEnd_z",&vTrackEnd_z);
    MichelDataTree ->Branch("IsTrackStopping",&vIsTrackStopping);
    MichelDataTree ->Branch("IsTrackPassing",&vIsTrackPassing);
    MichelDataTree ->Branch("IsTrackContained",&vIsTrackContained);
    MichelDataTree ->Branch("TrackPID",&vTrackPID);
    MichelDataTree ->Branch("TrackPIDA",&vTrackPIDA);
    MichelDataTree ->Branch("TrackLength",&vTrackLength);
    MichelDataTree ->Branch("TrackEnergy",&vTrackEnergy);
  }
  MichelDataTree ->Branch("IsSinglePassingTrack",&IsSinglePassingTrack,"IsSinglePassingTrack/I");
  MichelDataTree ->Branch("IsSingleStoppingTrack",&IsSingleStoppingTrack,"IsStoppingTrack/I");
  MichelDataTree ->Branch("StoppingTrackZenithAngle",&StoppingTrackZenithAngle,"StoppingTrackZenithAngle/F");
  MichelDataTree ->Branch("PassingTrackZenithAngle",&PassingTrackZenithAngle,"PassingTrackZenithAngle/F");
  MichelDataTree ->Branch("MuTrackVertex_x",&MuTrackVertex_x,"MuTrackVertex_x/F");
  MichelDataTree ->Branch("MuTrackVertex_y",&MuTrackVertex_y,"MuTrackVertex_y/F");
  MichelDataTree ->Branch("MuTrackVertex_z",&MuTrackVertex_z,"MuTrackVertex_z/F");
  MichelDataTree ->Branch("MuTrackEnd_x",&MuTrackEnd_x,"MuTrackEnd_x/F");
  MichelDataTree ->Branch("MuTrackEnd_y",&MuTrackEnd_y,"MuTrackEnd_y/F");
  MichelDataTree ->Branch("MuTrackEnd_z",&MuTrackEnd_z,"MuTrackEnd_z/F");
  MichelDataTree ->Branch("MuTrackLength",&MuTrackLength,"MuTrackLength/F");
  MichelDataTree ->Branch("MuTrackEnergy",&MuTrackEnergy,"MuTrackEnergy/F");
  MichelDataTree ->Branch("SecondTrackProximity",&SecondTrackProximity,"SecondTrackProximity/F"); 
  MichelDataTree ->Branch("SecondTrackLength",&SecondTrackLength,"SecondTrackLength/F"); 
  MichelDataTree ->Branch("SecondTrackEnergy",&SecondTrackEnergy,"SecondTrackEnergy/F"); 
  MichelDataTree ->Branch("IsSecondTrackContained",&IsSecondTrackContained,"IsSecondTrackContained/I"); 
 
  // Histograms 
  h_NumOpHits               = tfs->make<TH1I>("OpHitsPerEvent", "Optical hits per event", 10, 0, 10);
  h_NumOpHits               ->GetXaxis()->SetTitle("Num hits");
  h_NumOpHits               ->GetYaxis()->SetTitle("Counts");
  h_NumOpHits_beam          = tfs->make<TH1I>("OpHitsPerEvent_beam", "Optical hits per event (beam)",  10, 0, 10);
  h_NumOpHits_beam          ->GetXaxis()->SetTitle("Num hits");
  h_NumOpHits_beam          ->GetYaxis()->SetTitle("Counts");
  h_NumOpHits_offbeam       = tfs->make<TH1I>("OpHitsPerEvent_offbeam", "Optical hits per event (off-beam)", 10, 0, 10);
  h_NumOpHits_offbeam       ->GetXaxis()->SetTitle("Num hits");
  h_NumOpHits_offbeam       ->GetYaxis()->SetTitle("Counts");
  h_NumOpHits_vs_NumTracks  = tfs->make<TH2I>("NumOpHits_vs_NumTracks", "Optical hits vs. number of tracks in event", 10, 0,10, 50,0,50);
  h_NumOpHits_vs_NumTracks  ->GetXaxis()->SetTitle("Num optical hits");
  h_NumOpHits_vs_NumTracks  ->GetYaxis()->SetTitle("Num tracks");
  h_NumOpHits_vs_NumTracks  ->SetOption("colz");

  h_DeltaTime_chargeCut     = tfs->make<TH1F>("DeltaTime_chargeCut", "#Delta t (prompt integral > 1800ADC)", 700,0., 7000.);
  h_DeltaTime_chargeCut     ->GetXaxis()->SetTitle("ns");
  h_DeltaTime_chargeCut     ->GetYaxis()->SetTitle("Counts");
  
  h_DeltaTime_stoppingMu    = tfs->make<TH1F>("DeltaTime_stoppingMu", "#Delta t (1 stopping track, prompt integral > 1800ADC)", 700,0., 7000.);
  h_DeltaTime_stoppingMu    ->GetXaxis()->SetTitle("ns");
  h_DeltaTime_stoppingMu    ->GetYaxis()->SetTitle("Counts");

  h_DeltaTime_chargeCut_beam = tfs->make<TH1F>("DeltaTime_chargeCut_beam","#Delta t (prompt integral > 1800ADC) for Michel-like beam event",700,0.,7000.);
  h_DeltaTime_chargeCut_beam ->GetXaxis()->SetTitle("ns");
  h_DeltaTime_chargeCut_beam ->GetYaxis()->SetTitle("Counts");

  h_HitTime                 = tfs->make<TH1F>("HitTime", "Hit time in single-hit events",1000,0.,30000.);
  h_HitAmplitude            = tfs->make<TH1F>("HitAmplitude", "Amplitude of found hit in single-hit events", 300,   0., 300.);
  h_HitAmplitude            ->GetXaxis()->SetTitle("Optical hit amplitude [mV]");
  h_HitAmplitude            ->GetYaxis()->SetTitle("Counts");
  h_HitPromptPE             = tfs->make<TH1F>("HitPromptPE","Prompt photoelectrons per hit",500,0.,500.);
  h_HitPromptPE             ->GetXaxis()->SetTitle("Prompt photoelectrons per hit");
  h_HitPromptPE             ->GetYaxis()->SetTitle("Counts");
  
  h_Amplitude               = tfs->make<TH1F>("Amplitude", "Amplitude", 500,   0., 100.);
  h_Amplitude               ->GetXaxis()->SetTitle("Amplitude of Michel-candidate PMT pulse [mV]");
  h_Amplitude               ->GetYaxis()->SetTitle("Counts");

  h_Charge100ns             = tfs->make<TH1F>("Charge100ns", "Prompt light integral (100ns) in Michel-candidate pulses",  480,  0., 12000.);
  h_Charge100ns             ->GetXaxis()->SetTitle("Integrated prompt light, 100ns [ADC]");
  h_Charge100ns             ->GetYaxis()->SetTitle("Counts");

  h_PromptPE                = tfs->make<TH1F>("PromptPE", "Prompt photoelectrons (100ns) in Michel-candidate pulses",  400,  0., 200.);
  h_PromptPE             ->GetXaxis()->SetTitle("Prompt Photoelectrons");
  h_PromptPE             ->GetYaxis()->SetTitle("Counts");

  h_Charge100ns_populationCut = tfs->make<TH1F>("Charge100ns_populationCut", "Prompt light integral (100ns), BG population cut",  480,  0., 12000.);
  h_Charge100ns_populationCut ->GetXaxis()->SetTitle("Integrated prompt light, 100ns [ADC]");
  h_Charge100ns_populationCut ->GetYaxis()->SetTitle("Counts");
 
  h_Charge100ns_populationCut_DtCut = tfs->make<TH1F>("Charge100ns_populationCut_DtCut", "Prompt light integral (100ns), BG population cut, #Delta t > 3us",  480,  0., 12000.);
  h_Charge100ns_populationCut_DtCut ->GetXaxis()->SetTitle("Integrated prompt light, 100ns [ADC]");
  h_Charge100ns_populationCut_DtCut ->GetYaxis()->SetTitle("Counts");
  
  h_Charge100ns_stoppingMu = tfs->make<TH1F>("Charge100ns_stoppingMu","Prompt light integral (100ns) in events with 1 stopping track",480,0.,12000.);
  h_Charge100ns_stoppingMu ->GetXaxis()->SetTitle("Integrated prompt light, 100ns [ADC]");
  h_Charge100ns_stoppingMu ->GetYaxis()->SetTitle("Counts");

  h_Charge100ns_region    = tfs->make<TH1F>("Charge100ns_region","Prompt light integral (100ns), limited region",480,0.,12000.);
  h_Charge100ns_region    ->GetXaxis()->SetTitle("Integrated prompt light, 100ns [ADC]");
  h_Charge100ns_region    ->GetYaxis()->SetTitle("Counts");
  
  
  h_ChargeFull_populationCut          = tfs->make<TH1F>("ChargeFull_populationCut", "Full light integral (7us), BG population cut",  600,  0., 30000.);
  h_ChargeFull_populationCut          ->GetXaxis()->SetTitle("Integrated light, 7us [ADC]");
  h_ChargeFull_populationCut          ->GetYaxis()->SetTitle("Counts");
  
  h_ChargeFull_populationCut_DtCut    = tfs->make<TH1F>("ChargeFull_populationCut_DtCut", "Full light integral (7us), BG population cut, #Delta t > 3us",  600,  0., 30000.);
  h_ChargeFull_populationCut_DtCut    ->GetXaxis()->SetTitle("Integrated light, 7us [ADC]");
  h_ChargeFull_populationCut_DtCut    ->GetYaxis()->SetTitle("Counts");
  
  h_ChargeFull_region    = tfs->make<TH1F>("ChargeFull_region","Full light integral (7us), limited region",600,0.,30000.);
  h_ChargeFull_region    ->GetXaxis()->SetTitle("Integrated light, 7us [ADC]");
  h_ChargeFull_region    ->GetYaxis()->SetTitle("Counts");

  h_PromptPE_region    = tfs->make<TH1F>("PromptPE_region","Prompt photoelectrons, limited region",200,0.,200.);
  h_PromptPE_region    ->GetXaxis()->SetTitle("Prompt photoelectrons");
  h_PromptPE_region    ->GetYaxis()->SetTitle("Counts");
  
  h_FullPE_region    = tfs->make<TH1F>("FullPE_region","Total photoelectrons (7us), limited region",200,0.,1000.);
  h_FullPE_region    ->GetXaxis()->SetTitle("Photoelectrons");
  h_FullPE_region    ->GetYaxis()->SetTitle("Counts");


  h_PromptPE_vs_Amplitude     = tfs->make<TH2F>("PromptPE_vs_Amplitude","Prompt PEs (100ns) vs. amplitude",200,0.,200.,200,0.,100.);
  h_PromptPE_vs_Amplitude     ->GetXaxis()->SetTitle("Prompt photoelectrons");
  h_PromptPE_vs_Amplitude     ->GetYaxis()->SetTitle("Amplitude [mV]");
  h_PromptPE_vs_Amplitude     ->SetOption("colz");
  
  h_PromoptFraction_vs_Amplitude  = tfs->make<TH1F>("PromptFraction_vs_Amplitude","Prompt light fraction vs. pulse amplitude;Prompt fraction;Amplitude [mV]",
                                  200,0.,1., 200,0.,200);
  
  h_TrackEnergy_vs_PromptLight   = tfs->make<TH2F>("TrackEnergy_vs_PromptLight",";Reconstructed track energy [MeV];Prompt photoelectrons",100,0.,250.,100,0.,500.);
  h_TrackEnergy_vs_PromptLight   ->SetOption("colz");

  h_TrackNode_zx          = tfs->make<TH2F>("TrackNode_zx","TrackNode_zx",180,0.,90.,94,0.,47.);
  h_TrackNode_zx          ->GetXaxis()->SetTitle("z [cm]");
  h_TrackNode_zx          ->GetYaxis()->SetTitle("x [cm]");
  h_TrackNode_zx          ->SetMarkerStyle(7);
  h_TrackNode_zx          ->SetOption("colz");

  h_TrackNode_zy          = tfs->make<TH2F>("TrackNode_zy","TrackNode_zy",180,0.,90.,80,-20.,20.);
  h_TrackNode_zy          ->GetXaxis()->SetTitle("z [cm]");
  h_TrackNode_zy          ->GetYaxis()->SetTitle("y [cm]");
  h_TrackNode_zy          ->SetMarkerStyle(7);
  h_TrackNode_zy          ->SetOption("colz");

  h_TrackEnd_x            = tfs->make<TH1F>("TrackEnd_x","TrackEnd_x",100,-10.,60.);
  h_TrackEnd_y            = tfs->make<TH1F>("TrackEnd_y","TrackEnd_y",100,-25.,25.);
  h_TrackEnd_z            = tfs->make<TH1F>("TrackEnd_z","TrackEnd_z",100,-10.,100.);
  h_TrackVertex_x         = tfs->make<TH1F>("TrackVertex_x","TrackVertex_x",100,-10.,60.);
  h_TrackVertex_y         = tfs->make<TH1F>("TrackVertex_y","TrackVertex_y",100,-25.,25.);
  h_TrackVertex_z         = tfs->make<TH1F>("TrackVertex_z","TrackVertex_z",100,-10.,100.);
  
  h_InFiducialVolume      = tfs->make<TH2I>("InFiducialVolume",";Vertex in fiducial volume;End in fiducial volume",2,0.,2.,2,0.,2.);
  h_InFiducialVolume      ->SetOption("colz");
  
  h_SecondTrackOffset     = tfs->make<TH1F>("SecondTrackOffset","Primary / secondary track endpoint offset;cm",100,0.,30.);


  h_AverageWaveform1      = tfs->make<TH1F>("AverageWaveform1","Average waveform of Michel pulse",
                            HitWaveformBins,0.,(float)HitWaveformBins);
  h_AverageWaveform1      ->GetXaxis()->SetTitle("ns");
  h_AverageWaveform1      ->GetYaxis()->SetTitle("mV");
  
  h_AverageWaveform2      = tfs->make<TH1F>("AverageWaveform2","Average waveform of background pulse",
                            HitWaveformBins,0.,(float)HitWaveformBins);
  h_AverageWaveform2      ->GetXaxis()->SetTitle("ns");
  h_AverageWaveform2      ->GetYaxis()->SetTitle("mV");
  
  h_AverageWaveformMIP    = tfs->make<TH1F>("AverageWaveformMIP","Average waveform of thru-going muons",
                            HitWaveformBins,0.,(float)HitWaveformBins);
  h_AverageWaveformMIP    ->GetXaxis()->SetTitle("ns");
  h_AverageWaveformMIP    ->GetYaxis()->SetTitle("mV");
 
  h_AverageWaveformProton = tfs->make<TH1F>("AverageWaveformProton","Average waveform of protons",
                            HitWaveformBins,0.,(float)HitWaveformBins);
  h_AverageWaveformProton ->GetXaxis()->SetTitle("ns");
  h_AverageWaveformProton ->GetYaxis()->SetTitle("mV");
}

void MichelWfmReco::beginRun(art::Run & r)
{
  fTrigFiltAlg.loadXMLDatabaseTable( r.run() );
  iEvent = 0; 
}

void MichelWfmReco::beginSubRun(art::SubRun & sr)
{
}

void MichelWfmReco::endJob()
{

  // Make the average waveforms
  
  // Waveform 1 (Michel pulses)
  int N_entries = fOpHitBuilderAlg_ave1.AverageWaveform_count;
  float integral_prompt = 0.;
  float integral_total = 0.;
  if( N_entries > 0 ){
    for( int i = 0; i < (int)fOpHitBuilderAlg_ave1.AverageWaveform.size(); i++) {
      float w = fOpHitBuilderAlg_ave1.AverageWaveform.at(i) / float(N_entries); 
      h_AverageWaveform1->Fill(i,w);
      if( (i>fPrePulseBaselineFit-10)&&(i<fPrePulseBaselineFit+fPromptWindowLength) ) integral_prompt += w;
      if( (i>fPrePulseBaselineFit-10) ) integral_total += w; 
    }
  }
  
  std::cout<<"=================================\n";
  std::cout<<"Michel hits (1)\n";
  std::cout<<"Average of "<<N_entries<<" waveforms.\n";
  std::cout<<"   prompt ("<<fPromptWindowLength<<" ns): "<<integral_prompt<<std::endl;
  std::cout<<"   total ("<<fFullWindowLength<<" ns): "<<integral_total<<std::endl;
  std::cout<<"   ratio: "<< integral_prompt / integral_total <<std::endl;
  std::cout<<"================================\n";
  
  
  // Waveform 2 (BG pulses)
  N_entries = fOpHitBuilderAlg_ave2.AverageWaveform_count;
  integral_prompt = 0.;
  integral_total = 0.;
  if( N_entries > 0 ){
    for( int i = 0; i < (int)fOpHitBuilderAlg_ave2.AverageWaveform.size(); i++) {
      float w = fOpHitBuilderAlg_ave2.AverageWaveform.at(i) / float(N_entries); 
      h_AverageWaveform2->Fill(i,w);
      if( (i>fPrePulseBaselineFit-10)&&(i<fPrePulseBaselineFit+fPromptWindowLength) ) integral_prompt += w;
      if( (i>fPrePulseBaselineFit-10) ) integral_total += w; 
    }
  }
  std::cout<<"=================================\n";
  std::cout<<"BG hits (2)\n";
  std::cout<<"Average of "<<N_entries<<" waveforms.\n";
  std::cout<<"   prompt ("<<fPromptWindowLength<<" ns): "<<integral_prompt<<std::endl;
  std::cout<<"   total ("<<fFullWindowLength<<" ns): "<<integral_total<<std::endl;
  std::cout<<"   ratio: "<< integral_prompt / integral_total<<std::endl;
  std::cout<<"================================\n";
  
  
  // MIP average waveform
  N_entries = fOpHitBuilderAlg_aveMIP.AverageWaveform_count;
  integral_prompt = 0.;
  integral_total = 0.;
  if( N_entries > 0 ){
    for( int i = 0; i < (int)fOpHitBuilderAlg_aveMIP.AverageWaveform.size(); i++) {
      float w = fOpHitBuilderAlg_aveMIP.AverageWaveform.at(i) / float(N_entries); 
      h_AverageWaveformMIP->Fill(i,w);
      if( (i>fPrePulseBaselineFit-10)&&(i<fPrePulseBaselineFit+fPromptWindowLength) ) integral_prompt += w;
      if( (i>fPrePulseBaselineFit-10) ) integral_total += w; 
    }
  }
  std::cout<<"=================================\n";
  std::cout<<"MIPs:\n";
  std::cout<<"Average of "<<N_entries<<" waveforms.\n";
  std::cout<<"   prompt ("<<fPromptWindowLength<<" ns): "<<integral_prompt<<std::endl;
  std::cout<<"   total ("<<fFullWindowLength<<" ns): "<<integral_total<<std::endl;
  std::cout<<"   ratio: "<< integral_prompt / integral_total<<std::endl;
  std::cout<<"================================\n";


  // Proton average waveform
  N_entries = fOpHitBuilderAlg_aveProton.AverageWaveform_count;
  integral_prompt = 0.;
  integral_total = 0.;
  if( N_entries > 0 ){
    for( int i = 0; i < (int)fOpHitBuilderAlg_aveProton.AverageWaveform.size(); i++) {
      float w = fOpHitBuilderAlg_aveProton.AverageWaveform.at(i) / float(N_entries); 
      h_AverageWaveformProton->Fill(i,w);
      if( (i>fPrePulseBaselineFit-10)&&(i<fPrePulseBaselineFit+fPromptWindowLength) ) integral_prompt += w;
      if( (i>fPrePulseBaselineFit-10) ) integral_total += w; 
    }
  }
  std::cout<<"=================================\n";
  std::cout<<"Protons:\n";
  std::cout<<"Average of "<<N_entries<<" waveforms.\n";
  std::cout<<"   prompt ("<<fPromptWindowLength<<" ns): "<<integral_prompt<<std::endl;
  std::cout<<"   total ("<<fFullWindowLength<<" ns): "<<integral_total<<std::endl;
  std::cout<<"   ratio: "<< integral_prompt / integral_total<<std::endl;
  std::cout<<"================================\n";

}

void MichelWfmReco::endRun(art::Run & r)
{
}

void MichelWfmReco::endSubRun(art::SubRun & sr)
{
}

void MichelWfmReco::reconfigure(fhicl::ParameterSet const & pset)
{
  fTriggerUtility         = pset.get< std::string >("TriggerUtility","FragmentToDigit");
  bUseTriggerFilter       = pset.get< bool >("UseTriggerFilter","false");
  bUseTrackInformation    = pset.get< bool >("UseTrackInformation","true");
  bVerbose                = pset.get< bool >("Verbosity","true");
  fDAQModule              = pset.get< std::string >("DAQModule","daq");
  fTrackModule            = pset.get< std::string >("TrackModule","pmtrack");
  fTrackCalModule         = pset.get< std::string >("TrackCalModule","calo");
  fParticleIDModule       = pset.get< std::string >("ParticleIDModule","pid");
  fInstanceName           = pset.get< std::string >("InstanceName","");
  fBaselineWindowLength   = pset.get< short >("BaselineWindowLength",1000);
  fPromptWindowLength     = pset.get< short >("PromptWindowLength",100);
  fFullWindowLength       = pset.get< short >("FullWindowLength",7000);
  fPrePulseBaselineFit    = pset.get< short >("PrePulseBaselineFit",250);
  fFiducialMargin_X       = pset.get< float>("FiducialMargin_X",5.);
  fFiducialMargin_Y       = pset.get< float>("FiducialMargin_Y",4.);
  fFiducialMargin_Z       = pset.get< float>("FiducialMargin_Z",5.);
  fTimestampCut           = pset.get< float>("TimestampCut",5.3);
  fGateDelay              = pset.get< short >("GateDelay",300);
  fSinglePE               = pset.get< float>("SinglePE",51.);
  fAveWfmCut_Dt           = pset.get< float>("AveWfmCut_Dt",300.);
  fCorrectAveWfms         = pset.get< bool>("CorrectAveWfms","true");
  fSaveHitWfmsToTree      = pset.get< bool>("SaveHitWfmsToTree","false");
  fSaveAllTrackInfoToTree = pset.get< bool>("SaveAllTrackInfoToTree","false");
  fUsePrepulseFit         = pset.get< bool>("UsePrepulseFit","true");
  fHitTimeCutoffLow       = pset.get< short>("HitTimeCutoffLow",-100000);
  fHitTimeCutoffHigh      = pset.get< short>("HitTimeCutoffHigh",100000);
}

void MichelWfmReco::respondToCloseInputFile(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToCloseOutputFiles(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToOpenInputFile(art::FileBlock const & fb)
{
}

void MichelWfmReco::respondToOpenOutputFiles(art::FileBlock const & fb)
{
}

// Function for determining if a point is inside or outside
// predefined fiducial volume
bool MichelWfmReco::IsPointInFiducialVolume(TVector3 p)
{
  float Lx = 47.;
  float Ly = 40.;
  float Lz = 90.;
  if( (fabs(p.Y()       ) > Ly/2. - fFiducialMargin_Y) ||
      (fabs(p.X()-Lx/2. ) > Lx/2. - fFiducialMargin_X) ||
      (fabs(p.Z()-Lz/2. ) > Lz/2. - fFiducialMargin_Z) )
  {
    return false;
  } else {
    return true;
  }
}

DEFINE_ART_MODULE(MichelWfmReco)
