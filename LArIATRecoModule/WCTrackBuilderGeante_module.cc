////////////////////////////////////////////////////////////////////////
// Class:       WCTrackBuilderGeante
// Module Type: producer
// File:        WCTrackBuilderGeante_module.cc
//
// An code introduction to Geane tracking, lots left to be done
//
//  Daniel Smith dansmith@bu.edu
//  Rob Carey carey@bu.edu
// 
////////////////////////////////////////////////////////////////////////

#ifndef WCTRACKBUILDERGEANTE_H
#define WCTRACKBUILDERGEANTE_H


#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include <iostream>
#include <vector>
#include <wordexp.h>

#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "art_root_io/TFileService.h"


//ROOT Things
#include <TH1F.h>
#include <TH2F.h>
#include <TTree.h>

// Larsoft things
#include "larcore/Geometry/Geometry.h"
#include "nutools/G4Base/DetectorConstruction.h"

// Geant4 Things
#include "Geant4/G4SteppingVerbose.hh"
#include "Geant4/G4ErrorPropagatorManager.hh"
#include "Geant4/G4FieldManager.hh"
#include "Geant4/G4EqMagElectricField.hh"
#include "Geant4/G4MagIntegratorStepper.hh"
#include "Geant4/G4ChordFinder.hh"
#include "Geant4/globals.hh"
#include "Geant4/G4SystemOfUnits.hh"
#include "Geant4/G4ClassicalRK4.hh"
#include "Geant4/G4Vector3D.hh"
#include "Geant4/G4TransportationManager.hh"
#include "Geant4/G4ErrorPlaneSurfaceTarget.hh"
#include "Geant4/G4Vector3D.hh"
#include "Geant4/G4ErrorFreeTrajState.hh"
#include "Geant4/G4UImanager.hh"

//LArIAT Things
#include "RawDataUtilities/TriggerDigitUtility.h"
#include "LArIATRecoAlg/WCTrackBuilderAlg.h"
#include "LArIATRecoAlg/WCHitFinderAlg.h"
#include "LArIATRecoAlg/LArIATFieldMap.hh"
#include "LArIATDataProducts/WCTrack.h"
#include "Utilities/DatabaseUtilityT1034.h"

#include <memory>
#include <utility>
#include <string>
#include <fstream>

namespace wct{
class WCTrackBuilderGeante;

class WCTrackBuilderGeante : public art::EDProducer {
public:
  explicit WCTrackBuilderGeante(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  WCTrackBuilderGeante(WCTrackBuilderGeante const &) = delete;
  WCTrackBuilderGeante(WCTrackBuilderGeante &&) = delete;
  WCTrackBuilderGeante & operator = (WCTrackBuilderGeante const &) = delete;
  WCTrackBuilderGeante & operator = (WCTrackBuilderGeante &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void reconfigure(fhicl::ParameterSet const & p);// override;

  // Program specific functions
  std::vector<double> geanePropagator(double momo, std::vector<double> wc1, std::vector<double> wc2, std::vector<double> wc3, std::vector<double> wc4);

  void convertDigitsToVectors( std::vector<raw::AuxDetDigit> the_digits_1,
			       std::vector<raw::AuxDetDigit> the_digits_2,
			       std::vector<raw::AuxDetDigit> the_digits_3,
			       std::vector<raw::AuxDetDigit> the_digits_4,
			       std::vector<int> & tdc_number_vect,
			       std::vector<float> & hit_channel_vect,
			       std::vector<float> & hit_time_bin_vect );

  void createAuxDetStyleVectorsFromHitLists(WCHitList final_track,
					    std::vector<int> & WC_vect,
					    std::vector<float> & hit_wire_vect);
					    
					    
  void plotTheTrackInformation( std::vector<double> reco_pz_list,
				std::vector<double> x_face_list,
				std::vector<double> y_face_list,
				std::vector<double> theta_list,
				std::vector<double> phi_list,
				std::vector<double> y_kink_list,
				std::vector<double> x_dist_list,
				std::vector<double> y_dist_list,
				std::vector<double> z_dist_list);
  void ResetTree();
				
				
  void MakeSomePlotsFromHits(std::vector<std::vector<WCHitList> > good_hits);
private:

  // Declare member data here.

  //Offset ont he B field
  float offset;

  std::string fBFieldMap;
  std::string fLArIATGeo;


  //Algorithm object for track building
  WCTrackBuilderAlg fWCTrackBuilderAlg;
  std::string       fSlicerSourceLabel;
  WCHitFinderAlg    fWCHitFinderAlg;

  //Hardware constants
  int fNumber_wire_chambers;
  int fNumber_wires_per_tdc;
    
  //int evtcounter = 0;
  //Histograms for plotting
  TH1F* fReco_Pz;
  TH1F* fY_Kink;
  TH1F* fX_Dist;
  TH1F* fY_Dist;
  TH1F* fZ_Dist;
  TH1F* fX_Face_Dist;
  TH1F* fY_Face_Dist;
  TH1F* fTheta_Dist;
  TH1F* fPhi_Dist;
  TH1F* fTrack_Type;
  std::vector<TH2F*> fRecodiff;
  TH1F* fWCDist;
  TTree* fTree;      

  //Misc
  bool bVerbose;
  bool bPickyTracks;
  bool bCheckTracks;
  bool bThreePointReco;

  double fStraightCut;
  double fResWC3Cut;
  double fResWC4Cut;

  TH2F* hWC3projvsData;
  TH2F* hWC4projvsData;

  TH1F* hRes;
  TH1F *hStraightness;

  TH1F* hWC3Res;
  TH1F* hWC4Res;

  TH1F* hWC1delT;
  TH1F* hWC2delT;
  TH1F* hWC3delT;
  TH1F* hWC4delT;

  int WCx1[100],WCx2[100],WCx3[100],WCx4[100],WCy1[100],WCy2[100],WCy3[100],WCy4[100]; //Arrays for the wires hit in each WC

  // geant4 stuff
  G4ErrorPropagatorManager* g4emgr;
  LArIATFieldMap* FieldMapObject;
  double temp_B_field;
  //int   fWCMissed;

    
};


WCTrackBuilderGeante::WCTrackBuilderGeante(fhicl::ParameterSet const & p)
 : EDProducer(p)
 , fWCTrackBuilderAlg(p.get< fhicl::ParameterSet > ("WCTrackBuilderAlg")) // these should be initialized
 , fWCHitFinderAlg(p.get< fhicl::ParameterSet >("WCHitFinderAlg"))            // here instead of reconfigure()
{

  this->reconfigure(p);
  produces<std::vector<ldp::WCTrack> >();

  // Here starts GeanE configuration

  // Set verbosity
  G4VSteppingVerbose::SetInstance(new G4SteppingVerbose);

  // Start G4Error
  g4emgr = G4ErrorPropagatorManager::GetErrorPropagatorManager(); 

  // Load the detector
  g4b::DetectorConstruction* gUni;
  if(fLArIATGeo == "default") { 
    wordexp_t p_temp;
    wordexp( "$MRB_SOURCE/lariatsoft/Geo/gdml/lariat.gdml", &p_temp, 0 );
    std::string const& w = std::string(p_temp.we_wordv[0]);
    gUni = new g4b::DetectorConstruction(w, false, true);
  } else {
    gUni = new g4b::DetectorConstruction(fLArIATGeo, false, true);
  }

  // Get the magnetic field manager and load the field map
  G4FieldManager* fieldMgr = G4TransportationManager::GetTransportationManager()->GetFieldManager();
        
  if(fBFieldMap == "default") { FieldMapObject = new LArIATFieldMap("/pnfs/lariat/persistent/users/dsmith/field_file.list"); }    
  else { FieldMapObject = new LArIATFieldMap(fBFieldMap); }
  FieldMapObject->bVerbose = bVerbose;

  // Custom field map requires custom equation of states
  G4EqMagElectricField* fEquation = new G4EqMagElectricField(FieldMapObject);

  G4int nvar = 8;
  G4MagIntegratorStepper* fStepper = new G4ClassicalRK4( fEquation, nvar );  

  G4double fMinStep = 0.010*mm ; // minimal step of 10 microns
  G4MagInt_Driver* fIntgrDriver = new G4MagInt_Driver(fMinStep, fStepper, fStepper->GetNumberOfVariables() ); 
  fieldMgr->SetDetectorField(FieldMapObject);

  G4ChordFinder* fChordFinder = new G4ChordFinder(fIntgrDriver);
  fieldMgr->SetChordFinder( fChordFinder );

  // Set up the world
  G4VPhysicalVolume* gWorld = gUni->GetWorld();

  // Initialize everything
  gUni->Construct();
  g4emgr->SetUserInitialization(gWorld);
  g4emgr->InitGeant4e();

  // Call appropriate produces<>() functions here.  

}

void WCTrackBuilderGeante::produce(art::Event & e)
{ 

  ResetTree();
  //Creating the WCTrack Collection
  std::unique_ptr<std::vector<ldp::WCTrack> > WCTrackCol(new std::vector<ldp::WCTrack> );  

  //Retrieving the digits from the sliced event
  art::Handle< std::vector<raw::AuxDetDigit> > AuxDetDigitHandle;
  e.getByLabel(fSlicerSourceLabel,AuxDetDigitHandle);
    
  //Loop through the auxdetdigits and collect those that are from the WCs
  std::vector<raw::AuxDetDigit> WC1Digits;
  std::vector<raw::AuxDetDigit> WC2Digits;
  std::vector<raw::AuxDetDigit> WC3Digits;
  std::vector<raw::AuxDetDigit> WC4Digits;

  for( size_t iDig = 0; iDig < AuxDetDigitHandle->size(); ++iDig ){
    if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC1" ) WC1Digits.push_back(AuxDetDigitHandle->at(iDig));	
    if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC2" ) WC2Digits.push_back(AuxDetDigitHandle->at(iDig));	
    if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC3" ) WC3Digits.push_back(AuxDetDigitHandle->at(iDig));	
    if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC4" ) WC4Digits.push_back(AuxDetDigitHandle->at(iDig));	
  }  

  std::vector<int> tdc_number_vect;
  std::vector<float> hit_channel_vect;
  std::vector<float> hit_time_bin_vect;

  convertDigitsToVectors(WC1Digits, WC2Digits, WC3Digits, WC4Digits, 
			 tdc_number_vect, hit_channel_vect, hit_time_bin_vect ); 			   
			      
   		    		    
  std::vector<double> reco_pz_list;     //Final reco pz result for full_track_info = true, not indexed by trigger
  std::vector<double> reco_pz2M_list;
  std::vector<double> x_face_list;
  std::vector<double> y_face_list;
  std::vector<double> theta_list;
  std::vector<double> phi_list;
  std::vector<double> y_kink_list;
  std::vector<double> x_dist_list;
  std::vector<double> y_dist_list;
  std::vector<double> z_dist_list;
  std::vector<WCHitList> final_tracks;
  std::vector< std::vector< std::vector<double> > > hit_position_vect;
  std::vector<WCHitList> event_final_tracks;

  std::vector<std::vector<WCHitList> > good_hits; //Two vectors: WC#, axis. - Will be cleared for each trigger 

  //Initializing the good hit arrays to a default state - these clear for every trigger
  //Have 2-dimensional array of hitlists:
  //1st Dim: WC
  //2nd Dim: Axis    
  WCHitList hitList;
  std::vector<WCHitList> hitListAxis;
  for( int iAx = 0; iAx < 2; ++iAx ){ hitListAxis.push_back(hitList); }
  for( int iWC = 0; iWC < fNumber_wire_chambers; ++iWC ){ good_hits.push_back(hitListAxis); }
    
  //int good_trigger_counter = 0;
  fWCHitFinderAlg.createHits(tdc_number_vect, hit_channel_vect, hit_time_bin_vect, good_hits, bVerbose);

  MakeSomePlotsFromHits(good_hits);

  // Not going to skip any triggers, but need this here to fill WCMissed and fWCTrackBuilderAlg.fNHits
  int WCMissed=-999;
  fWCTrackBuilderAlg.shouldSkipTrigger(good_hits, WCMissed, fWCDist);

  if(true) { //temp_B_field > 0.10) { // Need this, otherwise geane can fail

    if(fWCTrackBuilderAlg.fNHits == 4) {

      int nHits = 0;
      float x[4]{0,0,0,0}, y[4]{0,0,0,0}, z[4]{0,0,0,0};
      std::vector<std::vector<double>> wc1, wc2, wc3, wc4;
      std::vector<WCHitList> trackers;
      std::vector<double> momos;
      std::vector<std::vector<int>> wc1_hit_cords, wc2_hit_cords, wc3_hit_cords, wc4_hit_cords; 

      // WC1  
      for( size_t iHit0 = 0; iHit0 < good_hits[0][0].hits.size(); ++iHit0 ){
	for( size_t iHit1 = 0; iHit1 < good_hits[0][1].hits.size(); ++iHit1 ){
	  std::vector<int> temp_cords;
	  temp_cords.push_back(iHit0);
	  temp_cords.push_back(iHit1);
	  wc1_hit_cords.push_back(temp_cords);
	}
      }

      // WC2  
      for( size_t iHit0 = 0; iHit0 < good_hits[1][0].hits.size(); ++iHit0 ){
	for( size_t iHit1 = 0; iHit1 < good_hits[1][1].hits.size(); ++iHit1 ){
	  std::vector<int> temp_cords;
	  temp_cords.push_back(iHit0);
	  temp_cords.push_back(iHit1);
	  wc2_hit_cords.push_back(temp_cords);
	}
      }

      // WC3
      for( size_t iHit0 = 0; iHit0 < good_hits[2][0].hits.size(); ++iHit0 ){
	for( size_t iHit1 = 0; iHit1 < good_hits[2][1].hits.size(); ++iHit1 ){
	  std::vector<int> temp_cords;
	  temp_cords.push_back(iHit0);
	  temp_cords.push_back(iHit1);
	  wc3_hit_cords.push_back(temp_cords);
	}
      }

      // WC4
      for( size_t iHit0 = 0; iHit0 < good_hits[3][0].hits.size(); ++iHit0 ){
	for( size_t iHit1 = 0; iHit1 < good_hits[3][1].hits.size(); ++iHit1 ){
	  std::vector<int> temp_cords;
	  temp_cords.push_back(iHit0);
	  temp_cords.push_back(iHit1);
	  wc4_hit_cords.push_back(temp_cords);
	}
      }

      // Create a track for each possible assembly of 4 hits, if they pass the loose straightness cut
      std::vector<double> vec_residuals;
      for(size_t iWC1 = 0; iWC1 < wc1_hit_cords.size(); iWC1++) {
	for(size_t iWC2 = 0; iWC2 < wc2_hit_cords.size(); iWC2++) {
	  for(size_t iWC3 = 0; iWC3 < wc3_hit_cords.size(); iWC3++) {
	    for(size_t iWC4 = 0; iWC4 < wc4_hit_cords.size(); iWC4++) {

	      WCHitList track;
	      track.hits.push_back(good_hits[0][0].hits[wc1_hit_cords[iWC1][0]]);
	      track.hits.push_back(good_hits[0][1].hits[wc1_hit_cords[iWC1][1]]);
	      track.hits.push_back(good_hits[1][0].hits[wc2_hit_cords[iWC2][0]]);
	      track.hits.push_back(good_hits[1][1].hits[wc2_hit_cords[iWC2][1]]);
	      track.hits.push_back(good_hits[2][0].hits[wc3_hit_cords[iWC3][0]]);
	      track.hits.push_back(good_hits[2][1].hits[wc3_hit_cords[iWC3][1]]);
	      track.hits.push_back(good_hits[3][0].hits[wc4_hit_cords[iWC4][0]]);
	      track.hits.push_back(good_hits[3][1].hits[wc4_hit_cords[iWC4][1]]);

	      fWCTrackBuilderAlg.findTheHitPositions(track,x,y,z,WCMissed);

	      // Simple straightness cut so as to not waise time with propagating noise
	      std::vector<float> track_stats = fWCTrackBuilderAlg.Regression(y,z,WCMissed);
	      hStraightness->Fill(track_stats[2]);
	      if(track_stats[2] > fStraightCut) { continue; }
      
	      vec_residuals.push_back(track_stats[2]);

	      nHits++;
	      
	      hWC1delT->Fill(good_hits[0][0].hits[wc1_hit_cords[iWC1][0]].time - 
			     good_hits[0][1].hits[wc1_hit_cords[iWC1][1]].time);
	      hWC2delT->Fill(good_hits[1][0].hits[wc2_hit_cords[iWC2][0]].time - 
			     good_hits[1][1].hits[wc2_hit_cords[iWC2][1]].time);
	      hWC3delT->Fill(good_hits[2][0].hits[wc3_hit_cords[iWC3][0]].time - 
			     good_hits[2][1].hits[wc3_hit_cords[iWC3][1]].time);
	      hWC4delT->Fill(good_hits[3][0].hits[wc4_hit_cords[iWC4][0]].time - 
			     good_hits[3][1].hits[wc4_hit_cords[iWC4][1]].time);


	      if(abs(good_hits[0][0].hits[wc1_hit_cords[iWC1][0]].time - 
		     good_hits[0][1].hits[wc1_hit_cords[iWC1][1]].time) > 20.0) { continue; } 
	      if(abs(good_hits[1][0].hits[wc2_hit_cords[iWC2][0]].time - 
		     good_hits[1][1].hits[wc2_hit_cords[iWC2][1]].time) > 20.0) { continue; } 
	      if(abs(good_hits[2][0].hits[wc3_hit_cords[iWC3][0]].time - 
		     good_hits[2][1].hits[wc3_hit_cords[iWC3][1]].time) > 20.0) { continue; } 
	      if(abs(good_hits[3][0].hits[wc4_hit_cords[iWC4][0]].time - 
		     good_hits[3][1].hits[wc4_hit_cords[iWC4][1]].time) > 20.0) { continue; } 

	      trackers.push_back(track);

	      std::vector<double> wc1_temp{x[0], y[0], z[0], 
		  (good_hits[0][0].hits[wc1_hit_cords[iWC1][0]].time + 
		   good_hits[0][1].hits[wc1_hit_cords[iWC1][1]].time)/2.0};

	      std::vector<double> wc2_temp{x[1], y[1], z[1], 
		  (good_hits[1][0].hits[wc2_hit_cords[iWC2][0]].time + 
		   good_hits[1][1].hits[wc2_hit_cords[iWC2][1]].time)/2.0};

	      std::vector<double> wc3_temp{x[2], y[2], z[2], 
		  (good_hits[2][0].hits[wc3_hit_cords[iWC3][0]].time + 
		   good_hits[2][1].hits[wc3_hit_cords[iWC3][1]].time)/2.0};

	      std::vector<double> wc4_temp{x[3], y[3], z[3], 
		  (good_hits[3][0].hits[wc4_hit_cords[iWC4][0]].time + 
		   good_hits[3][1].hits[wc4_hit_cords[iWC4][1]].time)/2.0};


	      wc1.push_back(wc1_temp);
	      wc2.push_back(wc2_temp);
	      wc3.push_back(wc3_temp);
	      wc4.push_back(wc4_temp);

	      float reco_pz = 0.0, reco_pz2M = 0.0, offset = 0.0;
	      fWCTrackBuilderAlg.calculateTheMomentum(track, x,y,z, reco_pz, reco_pz2M, track_stats, offset);

	      std::vector<std::vector< double > > temp_level1;
	      for(size_t i=0; i<4; ++i){
		std::vector<double> temp_level0 = {x[i], y[i], z[i]};
		temp_level1.push_back(temp_level0);
	      }

	      hit_position_vect.push_back(temp_level1);

	      //momos.push_back(reco_pz);
	      reco_pz_list.push_back(reco_pz);
	      reco_pz2M_list.push_back(reco_pz2M);

	      fWCTrackBuilderAlg.projectToTPC(track,x,y,z,track_stats,x_face_list,
					      y_face_list,theta_list,phi_list);

	      fWCTrackBuilderAlg.calculateTrackKink_Dists(x,y,z,track_stats,y_kink_list,
							  x_dist_list,y_dist_list,z_dist_list);

	      event_final_tracks.push_back(track);

	      if(event_final_tracks.size() > 50) break; 
	    }
	    if(event_final_tracks.size() > 50) break; 
	  }
	  if(event_final_tracks.size() > 50) break; 
	}
	if(event_final_tracks.size() > 50) break; 
      }

    
      // Now, going to only keep eventy that pass some residual cuts in the propagator
      // However, don't want to spend forever here, so limiting the number of tracks to ... 50. 
      if(event_final_tracks.size() <= 50) {

	int nPasser = 0;

	std::vector<double> momers;
	std::vector<double> reses;

	std::vector<bool> decider;

	for(size_t ipot = 0; ipot < wc1.size(); ipot++) {

	  std::vector<double> temp_wc1 = {wc1[ipot][0], wc1[ipot][1], wc1[ipot][2]};
	  std::vector<double> temp_wc2 = {wc2[ipot][0], wc2[ipot][1], wc2[ipot][2]};
	  std::vector<double> temp_wc3 = {wc3[ipot][0], wc3[ipot][1], wc3[ipot][2]};
	  std::vector<double> temp_wc4 = {wc4[ipot][0], wc4[ipot][1], wc4[ipot][2]};
	  
	  std::vector<double> residuals = geanePropagator(reco_pz_list[ipot], temp_wc1, temp_wc2, temp_wc3, temp_wc4);

	  if(residuals.size() < 3) { continue; }

	  if(residuals[1] == 0 and residuals[2] == 0) { break; } // looking for a seg fault, might fix it

	  if(bVerbose) { 
	    std::cout << "\n about to start residuals... " << std::endl;
	    for(size_t i = 0; i < residuals.size(); i++) {
	      std::cout << i << ") " << residuals[i] << std::endl;
	    }
	  }

	  hRes->Fill(residuals[1] + residuals[2]);

	  hWC3Res->Fill(residuals[1]);
	  hWC4Res->Fill(residuals[2]);


	  if(residuals[1] < fResWC3Cut and residuals[2] < fResWC4Cut) {
	    momers.push_back(reco_pz_list[ipot]);
	    reses.push_back(residuals[1] + residuals[2]);

	    nPasser += 1;    
	    decider.push_back(true);
	  } else {
	    decider.push_back(false);
	  }     

	}



	// Now, loop through if it cleared the pervious cuts, save it. 
	for(size_t i = 0; i < reco_pz_list.size(); i++) {
	  if(decider[i]) {

	    float temp_pos[4][3];

	    for(int iPos=0; iPos<4; ++iPos){
	      for(int jPos=0; jPos<3; ++jPos){
		temp_pos[iPos][jPos] = hit_position_vect[i][iPos][jPos] / 10.0; // convert mm to cm 
	      }
	    }

	    std::vector<int> WC_vect;
	    std::vector<float> hit_wire_vect;

	    createAuxDetStyleVectorsFromHitLists(event_final_tracks[i],
						 WC_vect,
						 hit_wire_vect);

	    ldp::WCTrack the_track(reco_pz_list[i], reco_pz2M_list[i],			     
				   y_kink_list[i], x_dist_list[i],			     
				   y_dist_list[i], z_dist_list[i], 
				   x_face_list[i], y_face_list[i],			     
				   theta_list[i], phi_list[i],			     
				   WC_vect,
				   hit_wire_vect,
				   temp_pos,
				   WCMissed,
				   vec_residuals[i]);

	    (*WCTrackCol).push_back( the_track );
	  }
	}

      } // end of 10 track test limit

	// end of nhits == 1
    } else if(fWCTrackBuilderAlg.fNHits == 3 and WCMissed != 4 and bThreePointReco) {
    

      if(bVerbose) { 	std::cout << " 3 pt reco. fNHits = " << fWCTrackBuilderAlg.fNHits << std::endl; }

      float hit_position_array[4][3] = {{0.0}};

      double residual = fWCTrackBuilderAlg.buildThreePointTracks(good_hits,
								 reco_pz_list,
								 x_face_list,
								 y_face_list,
								 theta_list,
								 phi_list,
								 event_final_tracks,
								 y_kink_list,
								 x_dist_list,
								 y_dist_list,
								 z_dist_list,
								 WCMissed,
								 hit_position_array,
								 offset);		

      bool seg_conquest = false;
      if(event_final_tracks.size() <= 10 and reco_pz_list.size() != 0) {
	if(WCMissed == 2) {
	  if(good_hits[2][0].hits.size() != 0 and good_hits[2][1].hits.size() != 0 and	   
	     good_hits[3][0].hits.size() != 0 and good_hits[3][1].hits.size() != 0) seg_conquest = true;
	}
	if(WCMissed == 3) {
	  if(good_hits[1][0].hits.size() != 0 and good_hits[1][1].hits.size() != 0 and
	     good_hits[3][0].hits.size() != 0 and good_hits[3][1].hits.size() != 0) seg_conquest = true;
	}
	if(WCMissed == 4) {
	  if(good_hits[1][0].hits.size() != 0 and good_hits[1][1].hits.size() != 0 and
	     good_hits[2][0].hits.size() != 0 and good_hits[2][1].hits.size() != 0) seg_conquest = true;
	}
      }

      if(seg_conquest) {

	std::vector<double> temp_wc1 = {hit_position_array[0][0], hit_position_array[0][1], hit_position_array[0][2]};
	std::vector<double> temp_wc2 = {hit_position_array[1][0], hit_position_array[1][1], hit_position_array[1][2]};
	std::vector<double> temp_wc3 = {hit_position_array[2][0], hit_position_array[2][1], hit_position_array[2][2]};
	std::vector<double> temp_wc4 = {hit_position_array[3][0], hit_position_array[3][1], hit_position_array[3][2]};

	for (size_t i = 0; i < x_dist_list.size(); i++) x_dist_list[i] *= 10.0;
	for (size_t i = 0; i < y_dist_list.size(); i++) y_dist_list[i] *= 10.0;
	for (size_t i = 0; i < z_dist_list.size(); i++) z_dist_list[i] *= 10.0;

	/*
	  for (size_t i = 0; i < x_face_list.size(); i++) x_face_list[i] *= 0.1;
	  for (size_t i = 0; i < y_face_list.size(); i++) y_face_list[i] *= 0.1;
	*/

	for (size_t i = 0; i < 4; i++) {
	  for (size_t j = 0; j < 3; j++) {
	    hit_position_array[i][j] *= 0.1;
	  }
	}

	std::vector<double> residuals = geanePropagator(reco_pz_list[0], temp_wc1, temp_wc2, temp_wc3, temp_wc4);

	//Pick out the tracks created under this current trigger and fill WCTrack objects with info.
	//(This must be done because the track/etc. lists encompass all triggers
	int tracknumber = event_final_tracks.size();
	for( int iNewTrack = 0; iNewTrack < tracknumber; ++iNewTrack ) {

	  std::vector<int> WC_vect;
	  std::vector<float> hit_wire_vect;
      
	  WCHitList final_track = event_final_tracks[iNewTrack];      
      
	  //Filling as done above, but formats the WC and hit wire vectors in the WCAuxDetDigit style
	  createAuxDetStyleVectorsFromHitLists(final_track, WC_vect, hit_wire_vect);
		           
	  //WCTrack object creation and association with trigger created
	  if(residuals.size() < 3) { continue; }
	    
	  if(bVerbose) { 
	    for(size_t i = 0; i < residuals.size(); i++) {
	      std::cout << i << ") " << residuals[i] << std::endl;
	    }
	  }

	  hWC3Res->Fill(residuals[1]);
	  hWC4Res->Fill(residuals[2]);

	  if(residuals[1] < fResWC3Cut and residuals[2] < fResWC4Cut) {
	    ldp::WCTrack the_track(reco_pz_list[iNewTrack],
				   y_kink_list[iNewTrack],
				   x_dist_list[iNewTrack],
				   y_dist_list[iNewTrack],
				   z_dist_list[iNewTrack],
				   x_face_list[iNewTrack],
				   y_face_list[iNewTrack],
				   theta_list[iNewTrack],
				   phi_list[iNewTrack],
				   WC_vect,
				   hit_wire_vect,
				   hit_position_array,
				   WCMissed,
				   residual);
	    (*WCTrackCol).push_back( the_track );	      
	  } // residuals cut
	} // nTracks loop
     
      } // end of 10 event max


    } // end of fnhits == 3

  } // check the b-field

  plotTheTrackInformation(reco_pz_list,
			  x_face_list,
			  y_face_list,
			  theta_list,
			  phi_list,
			  y_kink_list,
			  x_dist_list,
			  y_dist_list,
			  z_dist_list);


  // Put objects into event (root file)
  e.put(std::move(WCTrackCol)); 

}
//==================================================================================================
void WCTrackBuilderGeante::ResetTree()
{

  for(int i=0; i<100; ++i) {
    WCx1[i]=-99999;
    WCx2[i]=-99999;
    WCx3[i]=-99999;
    WCx4[i]=-99999;
    WCy1[i]=-99999;
    WCy2[i]=-99999;
    WCy3[i]=-99999;
    WCy4[i]=-99999;
  }

}
//==================================================================================================
void WCTrackBuilderGeante::MakeSomePlotsFromHits(std::vector<std::vector<WCHitList> > good_hits)
{  
  for(size_t iHit=0; iHit<good_hits[0][0].hits.size(); ++iHit)
  {
    WCx1[iHit]=good_hits[0][0].hits[iHit].wire;
  }
    for(size_t iHit=0; iHit<good_hits[1][0].hits.size(); ++iHit)
  {
    WCx2[iHit]=good_hits[1][0].hits[iHit].wire;
  }
    for(size_t iHit=0; iHit<good_hits[2][0].hits.size(); ++iHit)
  {
    WCx3[iHit]=good_hits[2][0].hits[iHit].wire;
  }
    for(size_t iHit=0; iHit<good_hits[3][0].hits.size(); ++iHit)
  {
    WCx4[iHit]=good_hits[3][0].hits[iHit].wire;
  }
    for(size_t iHit=0; iHit<good_hits[0][1].hits.size(); ++iHit)
  {
    WCy1[iHit]=good_hits[0][1].hits[iHit].wire;
  }
    for(size_t iHit=0; iHit<good_hits[1][1].hits.size(); ++iHit)
  {
    WCy2[iHit]=good_hits[1][1].hits[iHit].wire;
  }
    for(size_t iHit=0; iHit<good_hits[2][1].hits.size(); ++iHit)
  {
    WCy3[iHit]=good_hits[2][1].hits[iHit].wire;
  }
    for(size_t iHit=0; iHit<good_hits[3][1].hits.size(); ++iHit)
  {
    WCy4[iHit]=good_hits[3][1].hits[iHit].wire;
  }
}
//==================================================================================================
void WCTrackBuilderGeante::createAuxDetStyleVectorsFromHitLists(WCHitList final_track,
								   std::vector<int> & WC_vect,
								   std::vector<float> & hit_wire_vect)
  {
    for( size_t iHit = 0; iHit < final_track.hits.size() ; ++iHit ){
      WC_vect.push_back(int(iHit/2)+1);          //Look at how hits are pushed into the tracks in buildTracksFromHits (alg)

      float the_wire = (final_track.hits.at(iHit).wire*-1)+64+(128*(iHit%2));
      if (bVerbose) { std::cout << "Old WCAxis/Wire: " << iHit << "/" << final_track.hits.at(iHit).wire << ", New WC/Wire: " << int(iHit/2)+1 << "/" << the_wire << std::endl; }
      hit_wire_vect.push_back(the_wire);    
    }
  }
  //===================================================================================
  void WCTrackBuilderGeante::plotTheTrackInformation( std::vector<double> reco_pz_list,
							 std::vector<double> x_face_list,
							 std::vector<double> y_face_list,
							 std::vector<double> theta_list,
							 std::vector<double> phi_list,
							 std::vector<double> y_kink_list,
							 std::vector<double> x_dist_list,
							 std::vector<double> y_dist_list,
							 std::vector<double> z_dist_list)
  {
    //Loop through the tracks and fill
    for( size_t iTrack = 0; iTrack < reco_pz_list.size(); ++iTrack ){
      fReco_Pz->Fill(reco_pz_list.at(iTrack));
      fY_Kink->Fill(y_kink_list.at(iTrack));
      fX_Dist->Fill(x_dist_list.at(iTrack));
      fY_Dist->Fill(y_dist_list.at(iTrack));
      fZ_Dist->Fill(z_dist_list.at(iTrack));
      fX_Face_Dist->Fill(x_face_list.at(iTrack));
      fY_Face_Dist->Fill(y_face_list.at(iTrack));
      fTheta_Dist->Fill(theta_list.at(iTrack));
      fPhi_Dist->Fill(phi_list.at(iTrack));
    }
    
  }
//=========================================================================================
void WCTrackBuilderGeante::beginJob()//fhicl::ParameterSet const & p)
{



  // Implementation of optional member function here.
      // Implementation of optional member function here.
art::ServiceHandle<art::TFileService> tfs;
fWCDist= tfs->make<TH1F>("WCCond","WC Conditions",7,0,7); 
fTree=tfs->make<TTree>("WCTree","WCTree");
fTree->Branch("WCx1",&WCx1,"WCx1[100]/I");
fTree->Branch("WCx2",&WCx2,"WCx2[100]/I");
fTree->Branch("WCx3",&WCx3,"WCx3[100]/I");
fTree->Branch("WCx4",&WCx4,"WCx4[100]/I");
fTree->Branch("WCy1",&WCy1,"WCy1[100]/I");
fTree->Branch("WCy2",&WCy2,"WCy2[100]/I");
fTree->Branch("WCy3",&WCy3,"WCy3[100]/I");
fTree->Branch("WCy4",&WCy4,"WCy4[100]/I");
//Hists that should be used for diagnostics and deleted before production
if(bCheckTracks){
  for(int i=0; i<99; ++i){
    fRecodiff.push_back(tfs->make<TH2F>());
  }
fRecodiff[0]= tfs->make<TH2F>("WC1XWire4v2","WC1XWire4v2",500,-250,250,500,-250,250);
fRecodiff[1]= tfs->make<TH2F>("WC1YWire4v2","WC1YWire4v2",500,-250,250,500,-250,250);
fRecodiff[2]= tfs->make<TH2F>("WC2XWire4v2","WC2XWire4v2",500,-250,250,500,-250,250);
fRecodiff[3]= tfs->make<TH2F>("WC2YWire4v2","WC2YWire4v2",500,-250,250,500,-250,250);
fRecodiff[4]= tfs->make<TH2F>("WC3XWire4v2","WC3XWire4v2",500,-250,250,500,-250,250);
fRecodiff[5]= tfs->make<TH2F>("WC3YWire4v2","WC3YWire4v2",500,-250,250,500,-250,250);
fRecodiff[6]= tfs->make<TH2F>("WC4XWire4v2","WC4XWire4v2",500,-250,250,500,-250,250);
fRecodiff[7]= tfs->make<TH2F>("WC4YWire4v2","WC4YWire4v2",500,-250,250,500,-250,250);


fRecodiff[8]= tfs->make<TH2F>("WC1XWire4v3","WC1XWire4v3",500,-250,250,500,-250,250);
fRecodiff[9]= tfs->make<TH2F>("WC1YWire4v3","WC1YWire4v3",500,-250,250,500,-250,250);
fRecodiff[10]= tfs->make<TH2F>("WC2XWire4v3","WC2XWire4v3",500,-250,250,500,-250,250);
fRecodiff[11]= tfs->make<TH2F>("WC2YWire4v3","WC2YWire4v3",500,-250,250,500,-250,250);
fRecodiff[12]= tfs->make<TH2F>("WC3XWire4v3","WC3XWire4v3",500,-250,250,500,-250,250);
fRecodiff[13]= tfs->make<TH2F>("WC3YWire4v3","WC3YWire4v3",500,-250,250,500,-250,250);
fRecodiff[14]= tfs->make<TH2F>("WC4XWire4v3","WC4XWire4v3",500,-250,250,500,-250,250);
fRecodiff[15]= tfs->make<TH2F>("WC4YWire4v3","WC4YWire4v3",500,-250,250,500,-250,250);

fRecodiff[16]= tfs->make<TH2F>("X14v2","X14v2",4000,0,4000,4000,0,4000);
fRecodiff[17]= tfs->make<TH2F>("X24v2","X24v2",300,550,850,300,550,850);
fRecodiff[18]= tfs->make<TH2F>("X34v2","X34v2",4000,0,4000,4000,0,4000);
fRecodiff[19]= tfs->make<TH2F>("X44v2","X44v2",4000,0,4000,4000,0,4000);

fRecodiff[20]= tfs->make<TH2F>("X14v3","X14v3",4000,0,4000,4000,0,4000);
fRecodiff[21]= tfs->make<TH2F>("X24v3","X24v3",4000,0,4000,4000,0,4000);
fRecodiff[22]= tfs->make<TH2F>("X34v3","X34v3",4000,0,4000,4000,0,4000);
fRecodiff[23]= tfs->make<TH2F>("X44v3","X44v3",4000,0,4000,4000,0,4000);

fRecodiff[24]= tfs->make<TH2F>("Y14v2","Y14v2",200,-100,100,200,-100,100);
fRecodiff[25]= tfs->make<TH2F>("Y24v2","Y24v2",200,-100,100,200,-100,100);
fRecodiff[26]= tfs->make<TH2F>("Y34v2","Y34v2",200,-100,100,200,-100,100);
fRecodiff[27]= tfs->make<TH2F>("Y44v2","Y44v2",200,-100,100,200,-100,100);

fRecodiff[28]= tfs->make<TH2F>("Y14v3","Y14v3",200,-100,100,200,-100,100);
fRecodiff[29]= tfs->make<TH2F>("Y24v3","Y24v3",200,-100,100,200,-100,100);
fRecodiff[30]= tfs->make<TH2F>("Y34v3","Y34v3",200,-100,100,200,-100,100);
fRecodiff[31]= tfs->make<TH2F>("Y44v3","Y44v3",200,-100,100,200,-100,100);

fRecodiff[32]= tfs->make<TH2F>("Z14v2","Z14v2",10000,-10000,0,10000,-10000,0);
fRecodiff[33]= tfs->make<TH2F>("Z24v2","Z24v2",100,-5400,-5300,100,-5400,-5300);
fRecodiff[34]= tfs->make<TH2F>("Z34v2","Z34v2",10000,-10000,0,10000,-10000,0);
fRecodiff[35]= tfs->make<TH2F>("Z44v2","Z44v2",10000,-10000,0,10000,-10000,0);

fRecodiff[36]= tfs->make<TH2F>("Z14v3","Z14v3",10000,-10000,0,10000,-10000,0);
fRecodiff[37]= tfs->make<TH2F>("Z24v3","Z24v3",10000,-10000,0,10000,-10000,0);
fRecodiff[38]= tfs->make<TH2F>("Z34v3","Z34v3",10000,-10000,0,10000,-10000,0);
fRecodiff[39]= tfs->make<TH2F>("Z44v3","Z44v3",10000,-10000,0,10000,-10000,0);

fRecodiff[40]=tfs->make<TH2F>("TPCx4v2","TPCx4v2",800,-400,400,800,-400,400);
fRecodiff[41]=tfs->make<TH2F>("TPCy4v2","TPCy4v2",400,-200,200,400,-200,200);
fRecodiff[42]=tfs->make<TH2F>("TPCx4v3","TPCx4v3",300,100,400,300,100,400);
fRecodiff[43]=tfs->make<TH2F>("TPCy4v3","TPCy4v3",400,-200,200,400,-200,200);

fRecodiff[44]=tfs->make<TH2F>("TPCPhi4v2","TPCPhi4v2",80,-4,4,80,-4,4);
fRecodiff[45]=tfs->make<TH2F>("TPCTheta4v2","TPCTheta4v2",100,-.5,.5,100,-.5,.5);

fRecodiff[46]=tfs->make<TH2F>("TPCPhi4v3","TPCPhi4v3",80,-4,4,80,-4,4);
fRecodiff[47]=tfs->make<TH2F>("TPCTheta4v3","TPCTheta4v3",100,-.5,.5,100,-.5,.5);

fRecodiff[48]=tfs->make<TH2F>("XDist4v2","XDist4v2",500,-250,250,500,-250,250);
fRecodiff[49]=tfs->make<TH2F>("YDist4v2","YDist4v2",100,-50,50,100,-50,50);
fRecodiff[50]=tfs->make<TH2F>("ZDist4v2","ZDist4v2",100,-50,50,100,-50,50);
fRecodiff[51]=tfs->make<TH2F>("YKink4v2","YKink4v2",200,-.1,.1,200,-.1,.1);

fRecodiff[52]=tfs->make<TH2F>("XDist4v3","XDist4v3",500,-250,250,500,-250,250);
fRecodiff[53]=tfs->make<TH2F>("YDist4v3","YDist4v3",100,-50,50,100,-50,50);
fRecodiff[54]=tfs->make<TH2F>("ZDist4v3","ZDist4v3",100,-50,50,100,-50,50);
fRecodiff[55]=tfs->make<TH2F>("YKink4v3","YKink4v3",200,-.1,.1,200,-.1,.1);

fRecodiff[56]=tfs->make<TH2F>("mom4v2","relative error of S2 mom",1000,0,2000,200,-1,1);
fRecodiff[57]=tfs->make<TH2F>("mom4v3","relative error of S3 mom",1000,0,2000,200,-1,1);
fRecodiff[62]=tfs->make<TH2F>("mom4v4","relative error of S4 mom",1000,0,2000,200,-1,1);

fRecodiff[58]=tfs->make<TH2F>("Best residual all four","best residual all four",3000,0,300,3000,0,300);
fRecodiff[59]=tfs->make<TH2F>("Best residual Skip 2","best residual Skip 2",3000,0,300,3000,0,300);
fRecodiff[60]=tfs->make<TH2F>("Best residual Skip 3","best residual Skip 3",3000,0,300,3000,0,300);
fRecodiff[61]=tfs->make<TH2F>("Best residual Skip 4","best residual Skip 4",3000,0,300,3000,0,300);

fRecodiff[63]= tfs->make<TH2F>("X44v4","X44v4",4000,0,4000,4000,0,4000);
fRecodiff[64]= tfs->make<TH2F>("Y44v4","Y44v4",200,-100,100,200,-100,100);
fRecodiff[65]= tfs->make<TH2F>("Z44v4","Z44v4",10000,-10000,0,10000,-10000,0);

fRecodiff[66]=tfs->make<TH2F>("XDist4v4","XDist4v4",500,-250,250,500,-250,250);
fRecodiff[67]=tfs->make<TH2F>("YDist4v4","YDist4v4",100,-50,50,100,-50,50);
fRecodiff[68]=tfs->make<TH2F>("ZDist4v4","ZDist4v4",100,-50,50,100,-50,50);
fRecodiff[69]=tfs->make<TH2F>("YKink4v4","YKink4v4",200,-.1,.1,200,-.1,.1);

fRecodiff[70]=tfs->make<TH2F>("TPCPhi4v4","TPCPhi4v4",80,-4,4,80,-4,4);
fRecodiff[71]=tfs->make<TH2F>("TPCTheta4v4","TPCTheta4v4",100,-.5,.5,100,-.5,.5);

fRecodiff[72]= tfs->make<TH2F>("WC4XWire4v4","WC4XWire4v4",500,-250,250,500,-250,250);
fRecodiff[73]= tfs->make<TH2F>("WC4YWire4v4","WC4YWire4v4",500,-250,250,500,-250,250);

fRecodiff[74]=tfs->make<TH2F>("TPCx4v4","TPCx4v4",800,-400,400,800,-400,400);
fRecodiff[75]=tfs->make<TH2F>("TPCy4v4","TPCy4v4",400,-200,200,400,-200,200);

fRecodiff[76]=tfs->make<TH2F>("Best residual 4v2","best residual 4v2",3000,0,300,3000,0,300);
fRecodiff[77]=tfs->make<TH2F>("Best residual 4v3","best residual 4v3",3000,0,300,3000,0,300);
fRecodiff[78]=tfs->make<TH2F>("Best residual 4v4","best residual 4v4",3000,0,300,3000,0,300);

fRecodiff[79]=tfs->make<TH2F>("XwirediffS3","Difference in Xwire hit in WC3 (Actual-recreated)",600,-300,300,600,-300,300);
fRecodiff[80]=tfs->make<TH2F>("momentum","Reconstructed momentum",2000,0,2000,2000,0,2000);
fRecodiff[81]=tfs->make<TH2F>("WC1Timediff","Difference in time tick of X and Y hit in WC1",300,-150,150,300,-150,150);
fRecodiff[82]=tfs->make<TH2F>("WC2Timediff","Difference in time tick of X and Y hit in WC2",300,-150,150,300,-150,150);
fRecodiff[83]=tfs->make<TH2F>("WC3Timediff","Difference in time tick of X and Y hit in WC3",300,-150,150,300,-150,150);
fRecodiff[84]=tfs->make<TH2F>("WC4Timediff","Difference in time tick of X and Y hit in WC4",300,-150,150,300,-150,150);
fRecodiff[85]=tfs->make<TH2F>("4momvsres"," Residual versus momentum for 4 point tracks",180,0,1800,120,0,12);
fRecodiff[86]=tfs->make<TH2F>("dougsresidualtwo", "Distance WC2 Misses line through WC1 and WC4 (y,z) vs Momentum", 180,0,1800,1000,-500,500);
fRecodiff[87]=tfs->make<TH2F>("dougsresidualthree", "Distance WC3 Misses line through WC1 and WC4 (y,z) vs Momentum", 180,0,1800,1000,-500,500);
fRecodiff[88]=tfs->make<TH2F>("MomentumError","Fractional error of momentum",180,0,1800,200,0,.2);
fRecodiff[89]=tfs->make<TH2F>("mom2minus","Fractional Change in Momentum with -3mm shift in WC2X vs Orginal Momentum",1800,0,1800,500,-.05,.05);
fRecodiff[90]=tfs->make<TH2F>("mom2plus","Fractional Change in Momentum with +3mm shift in WC2X vs Orginal Momentum",1800,0,1800,500,-.05,.05);
fRecodiff[91]=tfs->make<TH2F>("mom3minus","Fractional Change in Momentum with -3mm shift in WC3X vs Orginal Momentum",1800,0,1800,500,-.05,.05);
fRecodiff[92]=tfs->make<TH2F>("mom3plus","Fractional Change in Momentum with +3mm shift in WC3X vs Orginal Momentum",1800,0,1800,500,-.05,.05);
fRecodiff[93]=tfs->make<TH2F>("Momplusplus","Fractional Change with WC 2 +3mm amd WC 3 + 3mm",1800,0,1800,1000,-.1,.1);
fRecodiff[94]=tfs->make<TH2F>("Momplusminus","Fractional Change with WC 2 +3mm amd WC 3 - 3mm",1800,0,1800,1000,-.1,.1);
fRecodiff[95]=tfs->make<TH2F>("Momminusplus","Fractional Change with WC 2 -3mm amd WC 3 + 3mm",1800,0,1800,1000,-.1,.1);
fRecodiff[96]=tfs->make<TH2F>("Momminusminus","Fractional Change with WC 2 -3mm amd WC 3 - 3mm",1800,0,1800,1000,-.1,.1);
fRecodiff[97]=tfs->make<TH2F>("XZMidplane", "XZ point halfway between line of closest approach", 1000,-5000,-4000,1000,0,1000);
fRecodiff[98]=tfs->make<TH2F>("dist","Distance of Closest Approach", 100,0,100,100,0,100);

}

//Hists that should probably stay for the production run.    
    fReco_Pz = tfs->make<TH1F>("Reco_Pz","Reconstructed momentum in XZ plane", 180, 0, 1800);
    fY_Kink = tfs->make<TH1F>("Y_Kink","Angle between US/DS tracks in Y direction (degrees)",200,-10*3.1415926/180,10*3.141592654/180);
    fX_Dist = tfs->make<TH1F>("X_Dist","X distance between US/DS tracks at midplane (mm)",1200,-60,1260);
    fY_Dist = tfs->make<TH1F>("Y_Dist","Y distance between US/DS tracks at midplane (mm)",1200,-600,600);
    fZ_Dist = tfs->make<TH1F>("Z_Dist","Z distance between US/DS tracks at midplane (mm)",1200,-60,1260);
    fX_Face_Dist = tfs->make<TH1F>("X_Face","X Location of Track's TPC Entry (mm)",1600,-200,1400);
    fY_Face_Dist = tfs->make<TH1F>("Y_Face","Y Location of Track's TPC Entry (mm)",800,-400,400);
    fTheta_Dist = tfs->make<TH1F>("Theta","Track Theta (w.r.t. TPC Z axis), (radians),",400,-.4,0.4);
    fPhi_Dist = tfs->make<TH1F>("Phi","Track Phi (w.r.t. TPC X axis), (radians)",2000,-6.28318,6.28318);                   
    fReco_Pz->GetXaxis()->SetTitle("Reconstructed momentum (MeV/c)");
    fReco_Pz->GetYaxis()->SetTitle("Tracks per 10 MeV/c");
    fY_Kink->GetXaxis()->SetTitle("Reconstructed y_kink (radians)");
    fY_Kink->GetYaxis()->SetTitle("Tracks per 0.000872 radians");
    fX_Dist->GetXaxis()->SetTitle("X distance between US and DS track ends");
    fX_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fY_Dist->GetXaxis()->SetTitle("Y distance between US and DS track ends");
    fY_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fZ_Dist->GetXaxis()->SetTitle("Z distance between US and DS track ends");
    fZ_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fX_Face_Dist->GetXaxis()->SetTitle("X (mm)");
    fX_Face_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fY_Face_Dist->GetXaxis()->SetTitle("Y (mm)");
    fY_Face_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fTheta_Dist->GetXaxis()->SetTitle("Theta (radians)");
    fTheta_Dist->GetYaxis()->SetTitle("Tracks per .002 radians");
    fPhi_Dist->GetXaxis()->SetTitle("Phi (radians)");
    fPhi_Dist->GetYaxis()->SetTitle("Tracks per 0.00628 radians");
    
    fTrack_Type = tfs->make<TH1F>("TrackType","WCTrack conditions: 1=missHit,2=uniqueHits,3=lonelyHit,4=socialHits",4,0,4);
    fTrack_Type->GetYaxis()->SetTitle("# Events");
    fTrack_Type->GetXaxis()->SetTitle("Track Conditions");

    hWC3projvsData = tfs->make<TH2F>("hWC3projvsData" , "hWC3projvsData", 200, -150.0, 150.0, 200, -150.0, 150.0); 
    hWC4projvsData = tfs->make<TH2F>("hWC4projvsData" , "hWC4projvsData", 200, -150.0, 150.0, 200, -150.0, 150.0); 

    hRes = tfs->make<TH1F>("Res" ,"Res" ,502, -1.0, 500.0);  
    hStraightness = tfs->make<TH1F>("Straightness" ,"Straightness" ,220, -10.0, 100.0);  

    hWC3Res = tfs->make<TH1F>("hWC3Res" ,"hWC3Res" ,100.0, 0.0, 100.0);  
    hWC4Res = tfs->make<TH1F>("hWC4Res" ,"hWC4Res" ,100.0, 0.0, 100.0);  

    hWC1delT = tfs->make<TH1F>("hWC1delT" ,"hWC1delT" ,200.0, -100.0, 100.0);  
    hWC2delT = tfs->make<TH1F>("hWC2delT" ,"hWC2delT" ,200.0, -100.0, 100.0);  
    hWC3delT = tfs->make<TH1F>("hWC3delT" ,"hWC3delT" ,200.0, -100.0, 100.0);  
    hWC4delT = tfs->make<TH1F>("hWC4delT" ,"hWC4delT" ,200.0, -100.0, 100.0);  

}
//===============================================================================================
  void WCTrackBuilderGeante::convertDigitsToVectors( std::vector<raw::AuxDetDigit> the_digits_1,
						     std::vector<raw::AuxDetDigit> the_digits_2,
						     std::vector<raw::AuxDetDigit> the_digits_3,
						     std::vector<raw::AuxDetDigit> the_digits_4,
						     std::vector<int> & tdc_number_vect,
						     std::vector<float> & hit_channel_vect,
						     std::vector<float> & hit_time_bin_vect )
  {  
    //std::ofstream outfile;
    //outfile.open("rawhits100A.txt", fstream::app);
    //outfile<<"Event number: "<<evtcounter<<std::endl;	
    //int hitcounter=0;

    //if (bVerbose) {  std::cout << "Digits' sizes, 1:2:3:4: " << the_digits_1.size() << ":" << the_digits_2.size() << ":"  << the_digits_3.size() << ":" << the_digits_4.size() << std::endl;}
    //Loop through digits for WC1
    for( size_t iDigit = 0; iDigit < the_digits_1.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_1.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
        //if (bVerbose) { std::cout << "(TDC,channel,time): (" << int(a_digit.Channel()/fNumber_wires_per_tdc)+1 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< ")" << std::endl; }
	hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+1);
	hit_channel_vect.push_back(a_digit.Channel() % 64);
	//outfile<<"TDC: "<<int(a_digit.Channel()/fNumber_wires_per_tdc)+1<<", Wire: "<<a_digit.Channel() % 64<<", Time: "<<a_digit.ADC(iHit)<<std::endl;
	//hitcounter++;
      }
    }

    //Loop through digits for WC2
    for( size_t iDigit = 0; iDigit < the_digits_2.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_2.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
	if( a_digit.ADC(iHit) != 0 ){
	  //if (bVerbose){ std::cout << "(TDC,channel,time): (" << a_digit.Channel()/fNumber_wires_per_tdc + 5 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< "), --> a_digit.Channel(): " << a_digit.Channel() << ", fNumber_wires...: " << fNumber_wires_per_tdc << std::endl;}
	  hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	  tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+5);
	  hit_channel_vect.push_back(a_digit.Channel() % 64);
	  //outfile<<"TDC: "<<int(a_digit.Channel()/fNumber_wires_per_tdc)+5<<", Wire: "<<a_digit.Channel() % 64<<", Time: "<<a_digit.ADC(iHit)<<std::endl;
	  //hitcounter++;
	}
      }
    }

    //Loop through digits for WC3
    for( size_t iDigit = 0; iDigit < the_digits_3.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_3.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
	if( a_digit.ADC(iHit) != 0 ){
	  //if (bVerbose){std::cout << "(TDC,channel,time): (" << int(a_digit.Channel()/fNumber_wires_per_tdc)+9 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< ")" << std::endl;}
	  hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	  tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+9);
	  hit_channel_vect.push_back(a_digit.Channel() % 64);
	  //outfile<<"TDC: "<<int(a_digit.Channel()/fNumber_wires_per_tdc)+9<<", Wire: "<<a_digit.Channel() % 64<<", Time: "<<a_digit.ADC(iHit)<<std::endl;
	  //hitcounter++;
	}
      }
    }

    //Loop through digits for WC4
    for( size_t iDigit = 0; iDigit < the_digits_4.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_4.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
	if( a_digit.ADC(iHit) != 0 ){
	  //if (bVerbose){std::cout << "(TDC,channel,time): (" << int(a_digit.Channel()/fNumber_wires_per_tdc)+13 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< ")" << std::endl;}
	  hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	  tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+13);
	  hit_channel_vect.push_back(a_digit.Channel() % 64);
	  //outfile<<"TDC: "<<int(a_digit.Channel()/fNumber_wires_per_tdc)+13<<", Wire: "<<a_digit.Channel() % 64<<", Time: "<<a_digit.ADC(iHit)<<std::endl;
	  //hitcounter++;
	}
      }
    }
   //outfile<<"Number of Hits for event: "<<hitcounter<<std::endl;
   //outfile.close();
  }

void WCTrackBuilderGeante::beginRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void WCTrackBuilderGeante::beginSubRun(art::SubRun & sr)
{
  
  

  temp_B_field = 0.0;
  if( fWCTrackBuilderAlg.fMCMagneticField == 0 ) {       
    temp_B_field = fWCTrackBuilderAlg.loadXMLDatabaseTableForBField( sr.run(), sr.subRun() );
  }
  if(bVerbose) { std::cout << "B field from database: " << temp_B_field << std::endl; }

  // a debugging thing
  if(temp_B_field == 0.0) {
    fWCTrackBuilderAlg.fB_field_tesla = 0.315;
    temp_B_field = 0.315;
  }

  FieldMapObject->SetBField(temp_B_field);
  
}

void WCTrackBuilderGeante::endJob()
{

  G4ErrorPropagatorManager::GetErrorPropagatorManager()->CloseGeometry();
  // Implementation of optional member function here.
}


std::vector<double> WCTrackBuilderGeante::geanePropagator(double reco_momo, std::vector<double> wc1, std::vector<double> wc2, std::vector<double> wc3, std::vector<double> wc4)
{


  if(wc1.size() != 3 or wc2.size() != 3 or wc3.size() != 3 or wc4.size() != 3) {
    std::vector<double> garbage = {999.9, 999.9, 999.9};
    return garbage; 
  }

  std::vector<double> residuals;

  residuals.push_back(0.0);
  residuals.push_back(0.0);
  residuals.push_back(0.0);

  if(bVerbose) { 
    std::cout << wc1[0] << " " <<  wc1[1] << " " <<  wc1[2] << std::endl;
    std::cout << wc2[0] << " " <<  wc2[1] << " " <<  wc2[2] << std::endl;
    std::cout << wc3[0] << " " <<  wc3[1] << " " <<  wc3[2] << std::endl;
    std::cout << wc4[0] << " " <<  wc4[1] << " " <<  wc4[2] << std::endl;
    std::cout << " \n\n" << std::endl;
  }

  // Set the starting trajectory
  G4ThreeVector pv3;
  pv3.setX(wc2[0]-wc1[0]);
  pv3.setY(wc2[1]-wc1[1]);
  pv3.setZ(wc2[2]-wc1[2]);

  double temp_mag = pv3.mag();
  if(temp_mag == 0.0) {
    std::vector<double> garbage = {999.9, 999.9, 999.9};
    return garbage; 
  }

  pv3.setX(pv3.x() / temp_mag * reco_momo*MeV);
  pv3.setY(pv3.y() / temp_mag * reco_momo*MeV);
  pv3.setZ(pv3.z() / temp_mag * reco_momo*MeV);

  G4Point3D surfPos(0,0,0.);
  G4Normal3D surfNorm(0,0.5,0.5);
  G4ErrorTarget* terget = new G4ErrorPlaneSurfaceTarget(surfNorm, surfPos );

  // Particles to propagate ... no kaon! :(
  std::vector<std::string> parts = {"proton"}; //{"e+", "mu+", "pi+", "proton"};

  for( size_t ii = 0; ii < parts.size(); ii++) {

    G4ThreeVector xv3(wc2[0], wc2[1], wc2[2]);

    if(bVerbose) { 
      std::cout << "Particle: " << parts[ii] << std::endl;
      std::cout << "Start momentum: " << pv3.mag() << "\n" <<  xv3[0] << " " <<  xv3[1] << " " << xv3[2] << std::endl;      
    }

    G4ErrorTrajErr error( 5, 0 );
    G4ErrorPropagatorData* g4edata = G4ErrorPropagatorData::GetErrorPropagatorData();

    g4edata->SetTarget(terget);
    g4emgr->InitTrackPropagation();

    G4UImanager::GetUIpointer()->ApplyCommand("/geant4e/limits/stepLength 5.0");

    G4ErrorFreeTrajState* g4ErrorTrajState = new G4ErrorFreeTrajState(parts[ii], xv3, pv3, error);

    bool updated_wc1 = false, updated_wc2 = false, updated_wc3 = false, updated_wc4 = false;
    int num_wc = 0;

    //while(true){      
    
    size_t max_steps = 6000;
    size_t iStep;
    for(iStep = 0; iStep < max_steps; iStep++) {
      g4emgr->PropagateOneStep( g4ErrorTrajState, G4ErrorMode_PropForwards );     

      //G4Vector3D temp_prop_track = g4ErrorTrajState->GetG4Track()->GetPosition();
      //std::cout << temp_prop_track[0] << " " << temp_prop_track[1] << " " << temp_prop_track[2] << std::endl;	

      if(g4ErrorTrajState->GetG4Track()->GetPosition().z() > wc1[2] and !updated_wc1) {
	updated_wc1 = true;
	num_wc += 1;
      }

      if(g4ErrorTrajState->GetG4Track()->GetPosition().z() > wc2[2] and !updated_wc2) {
	updated_wc2 = true;

	G4Vector3D prop_track = g4ErrorTrajState->GetG4Track()->GetPosition();
	residuals[0] = TMath::Sqrt(pow(wc2[0] - prop_track[0],2) + 
				   pow(wc2[1] - prop_track[1],2) + 
				   pow(wc2[2] - prop_track[2],2));
	num_wc += 1;
	G4UImanager::GetUIpointer()->ApplyCommand("/geant4e/limits/stepLength 0.5");
      }

      if(g4ErrorTrajState->GetG4Track()->GetPosition().z() > wc3[2] and !updated_wc3) {
	updated_wc3 = true;
	G4Vector3D prop_track = g4ErrorTrajState->GetG4Track()->GetPosition();

	residuals[1] = TMath::Sqrt(pow(wc3[0] - prop_track[0] + 4.5,2) + 
				   pow(wc3[1] - prop_track[1] + 1.0,2) + 
				   pow(wc3[2] - prop_track[2],2));
	
	hWC3projvsData->Fill(wc3[0] - prop_track[0] + 4.5, wc3[1] - prop_track[1] + 1.0);
	num_wc += 1;
	G4UImanager::GetUIpointer()->ApplyCommand("/geant4e/limits/stepLength 5.0");
      }

      if(g4ErrorTrajState->GetG4Track()->GetPosition().z() > wc4[2] and !updated_wc4) {
	updated_wc4 = true;

	G4Vector3D prop_track = g4ErrorTrajState->GetG4Track()->GetPosition();

	residuals[2] = TMath::Sqrt(pow(wc4[0] - prop_track[0],2) + 
				   pow(wc4[1] - prop_track[1],2) + 
				   pow(wc4[2] - prop_track[2],2));

	hWC4projvsData->Fill(wc4[0] - prop_track[0], wc4[1] - prop_track[1]);
	num_wc += 1;

	g4emgr->GetPropagator()->InvokePostUserTrackingAction( g4ErrorTrajState->GetG4Track() );	
	break;

      }

      //---- Check if target is reached
      if(g4emgr->GetPropagator()->CheckIfLastStep( g4ErrorTrajState->GetG4Track()) or max_steps-1 == iStep) {

	g4emgr->GetPropagator()->InvokePostUserTrackingAction( g4ErrorTrajState->GetG4Track() );	
	break;
      }
    }

    std::cout << "iStep = " << iStep << std::endl;

  } // end of parts loop

  return residuals;

}


void WCTrackBuilderGeante::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
    fNumber_wire_chambers = p.get<int>("NWC"); //4;  
    fNumber_wires_per_tdc = p.get<int>("NWperTDC"); //64;
    bVerbose = p.get<bool>("Verbose", false);
    fSlicerSourceLabel = p.get<std::string>("SourceLabel");
    bPickyTracks = p.get<bool>("PickyTracks", false);
    bCheckTracks = p.get<bool>("CheckTracks");
    offset = p.get<float>("BFieldOffset");

    bThreePointReco = p.get<bool>("ThreePointReco", false);
    fStraightCut = p.get<float>("StraightCut", 7.0);
    fResWC3Cut = p.get<float>("ResWC3Cut", 20.0);
    fResWC4Cut = p.get<float>("ResWC4Cut", 35.0);


    fBFieldMap = p.get<std::string>("BFieldMapFile", "default");
    fLArIATGeo = p.get<std::string>("LArIATGeoFile", "default");


}

DEFINE_ART_MODULE(WCTrackBuilderGeante)
}//end namespace

#endif //WCTrackBuilderGeante_H
