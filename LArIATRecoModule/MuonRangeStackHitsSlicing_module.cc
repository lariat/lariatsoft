////////////////////////////////////////////////////////////////////////
// Class:       MuonRangeStackHitsSlicing
// Module Type: producer
// File:        MuonRangeStackHitsSlicing_module.cc
//
// Generated at Thu Jun  4 10:04:24 2015 by Greg Pulliam using artmod
// from cetpkgsupport v1_08_05.
////////////////////////////////////////////////////////////////////////
#ifndef MUONRANGESTACKHITSSLICING_H
#define MUONRANGESTACKHITSSLICING_H


#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include <iostream>
#include <TH1F.h>
#include <TH2F.h>
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "RawDataUtilities/TriggerDigitUtility.h"
#include "LArIATDataProducts/MuonRangeStackHits.h"
#include <map>
#include <vector>
#include <memory>
#include <sstream>
namespace lrm{
	class MuonRangeStackHitsSlicing;
}

class MuonRangeStackHitsSlicing : public art::EDProducer {
public:
  explicit MuonRangeStackHitsSlicing(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MuonRangeStackHitsSlicing(MuonRangeStackHitsSlicing const &) = delete;
  MuonRangeStackHitsSlicing(MuonRangeStackHitsSlicing &&) = delete;
  MuonRangeStackHitsSlicing & operator = (MuonRangeStackHitsSlicing const &) = delete;
  MuonRangeStackHitsSlicing & operator = (MuonRangeStackHitsSlicing &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:
std::string fTriggerUtility;
std::string fSlicerSourceLabel;
TH1F* fMuRSHitTiming;
TH1F* fPaddleHits;
TH1F* fTotalPaddleHits;
TH2F* fAmpVsPaddle;
int fThreshold;

std::vector<int> MuRSPaddleHits;
std::map<int, std::vector<int> > fMuonRangeStackMap;
  // Declare member data here.

};


MuonRangeStackHitsSlicing::MuonRangeStackHitsSlicing(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
this->reconfigure(p);
  // Call appropriate produces<>() functions here.
}

void MuonRangeStackHitsSlicing::produce(art::Event & e)
{
  // Implementation of required member function here.
	std::unique_ptr<std::vector<ldp::MuonRangeStackHits> > MuonRangeStackCol(new std::vector<ldp::MuonRangeStackHits>  ) ;	//I call this a map, but it's really a vector with one entry that is a map......hopefully.
 	art::Handle<std::vector<raw::AuxDetDigit>> AuxDetDigitHandle;
	e.getByLabel(fSlicerSourceLabel,AuxDetDigitHandle);
 	std::vector<raw::AuxDetDigit> MuRSDigits;
 	for(size_t iDig=0; iDig<AuxDetDigitHandle->size(); ++iDig){
 		if(AuxDetDigitHandle->at(iDig).AuxDetName()=="MuonRangeStack"){
    		MuRSDigits.push_back(AuxDetDigitHandle->at(iDig));
    		}
    	}
       
	int size=MuRSDigits.size();
	//std::cout<<size<<std::endl;
	
	int TrigMult=size/16;
	   for (int TrigIter=0; TrigIter<TrigMult; ++TrigIter){
	   	for (int nPaddle=TrigIter*16; nPaddle<(TrigIter+1)*16; ++nPaddle){
			auto PaddleDigit=MuRSDigits[nPaddle];
			for (size_t i=0; i<PaddleDigit.NADC(); ++i){
				if(PaddleDigit.ADC(i)<fThreshold){
				MuRSPaddleHits.push_back(i);
				fMuRSHitTiming->Fill(i);
				fAmpVsPaddle->Fill(nPaddle-TrigIter*16,fThreshold-PaddleDigit.ADC(i));
				fTotalPaddleHits->Fill(nPaddle-TrigIter*16);
				fPaddleHits->Fill(nPaddle-TrigIter*16);
				}
			}
			fMuonRangeStackMap.emplace(nPaddle-TrigIter*16,MuRSPaddleHits);
			MuRSPaddleHits.clear();
		}
		ldp::MuonRangeStackHits the_MuRS(fMuonRangeStackMap);
		(*MuonRangeStackCol).push_back(the_MuRS);
		
		fMuonRangeStackMap.clear();
		
	   }
e.put(std::move(MuonRangeStackCol));	   
}//produce()

void MuonRangeStackHitsSlicing::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  fMuRSHitTiming = tfs->make<TH1F>("MuRSHitTicks","MuRSHitTicks", 3073, 0, 3073);
  fPaddleHits=tfs->make<TH1F>("PaddleHits", "PaddleHits",16, 0, 16);
  fTotalPaddleHits=tfs->make<TH1F>("TotalPaddleHits","TotalPaddleHits",16, 0, 16);
  fAmpVsPaddle=tfs->make<TH2F>("AmplitudeVsPaddle", "AmplitudeVsPaddle",16,0,16,2021,0,2021);
  // Implementation of optional member function here.
}

void MuonRangeStackHitsSlicing::beginRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void MuonRangeStackHitsSlicing::beginSubRun(art::SubRun & sr)
{

  // Implementation of optional member function here.
}

void MuonRangeStackHitsSlicing::endJob()
{
  // Implementation of optional member function here.
}

void MuonRangeStackHitsSlicing::endRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void MuonRangeStackHitsSlicing::endSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

void MuonRangeStackHitsSlicing::reconfigure(fhicl::ParameterSet const & p)
{
fSlicerSourceLabel=p.get<std::string>("SourceLabel");
fThreshold=p.get<int>("Threshold");
}

void MuonRangeStackHitsSlicing::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void MuonRangeStackHitsSlicing::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void MuonRangeStackHitsSlicing::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void MuonRangeStackHitsSlicing::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}
#endif 
DEFINE_ART_MODULE(MuonRangeStackHitsSlicing)
