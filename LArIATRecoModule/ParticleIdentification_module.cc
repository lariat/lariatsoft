////////////////////////////////////////////////////////////////////////
// Class:       ParticleIdentification
// Module Type: producer
// File:        ParticleIdentification_module.cc
//
// Generated at Tue Jul 21 10:59:53 2015 by Ryan Linehan using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

//Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Services/Optional/TFileService.h"

//Lariatsoft includes
#include "LArIATDataProducts/WCTrack.h"
#include "LArIATDataProducts/TOF.h"
#include "RawDataUtilities/TriggerDigitUtility.h"

//C++ includes
#include <vector>
#include <memory>
#include <iostream>

//ROOT includes
#include <TH2F.h>
#include <TH1F.h>


class ParticleIdentification;

class ParticleIdentification : public art::EDProducer {
public:
  explicit ParticleIdentification(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ParticleIdentification(ParticleIdentification const &) = delete;
  ParticleIdentification(ParticleIdentification &&) = delete;
  ParticleIdentification & operator = (ParticleIdentification const &) = delete;
  ParticleIdentification & operator = (ParticleIdentification &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
  void endRun(art::Run & r) override;
  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.
  std::string       fWCTrackModuleLabel;
  std::string       fTOFModuleLabel;
  bool              fVerbose;
  bool              fPlotHistograms;

  TH2F*             fPzVsTOF;
  TH1F*             fNTOF;
  TH1F*             fPz;
  TH1F*             fTOF;
  
};


ParticleIdentification::ParticleIdentification(fhicl::ParameterSet const & p)
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
  this->reconfigure(p);

  
}

void ParticleIdentification::produce(art::Event & e)
{
  // Implementation of required member function here.
  


  //Get the collection of WCTracks produced by the WCTrackBuilder module
  art::Handle< std::vector<ldp::WCTrack> > WCTrackColHandle;
  e.getByLabel(fWCTrackModuleLabel,WCTrackColHandle);
  
  //Get the collection of TOF objects produced by the TOF module
  art::Handle< std::vector<ldp::TOF> > TOFColHandle;
  e.getByLabel(fTOFModuleLabel,TOFColHandle);

  std::cout << "Produce has commenced." << std::endl;

  //Getting the associations between triggers-WCTracks and triggers-TOF
  art::FindManyP<raw::Trigger> findTheWCTrackTrig(WCTrackColHandle,e,fWCTrackModuleLabel);
  art::FindManyP<raw::Trigger> findTheTOFTrig(TOFColHandle,e,fTOFModuleLabel);
  
  //Extract information about the triggers and compare the WCTrackTrigs against the TOFTrigs
  if( fVerbose ){
    std::cout << "Size of WCTrackColHandle: " << WCTrackColHandle->size() << std::endl;
    for( size_t iWCTrack = 0; iWCTrack < WCTrackColHandle->size(); ++iWCTrack ){
      std::vector<art::Ptr<raw::Trigger> > trigPtrVect = findTheWCTrackTrig.at(iWCTrack);
      std::cout << "iWCTrack: " << iWCTrack << ", Size of trigPtrVect: " << trigPtrVect.size() << ", TriggerID: " << trigPtrVect.at(0)->TriggerNumber() << std::endl;
    }    
    std::cout << "Size of TOFColHandle: " << TOFColHandle->size() << std::endl;
    for( size_t iTOF = 0; iTOF < TOFColHandle->size(); ++iTOF ){
      std::vector<art::Ptr<raw::Trigger> > trigPtrVect = findTheTOFTrig.at(iTOF);
      std::cout << "iTOF: " << iTOF << ", Size of trigPtrVect: " << trigPtrVect.size() << ", TriggerID: " << trigPtrVect.at(0)->TriggerNumber() << std::endl;
    }
  }

  //Quick-and-dirty method for matching TOF and WCTracks: good WCTracks only have one track per trigger.
  //I think (?) that only one TOF comes out of the TimeOfFlight module, but just in case that's not true, we'll require
  //that only one TOF can correspond to one trigger
  
  //Loop through the WCTracks and get the trigger ID
  for( size_t iWCTrack = 0; iWCTrack < WCTrackColHandle->size(); ++iWCTrack ){
    std::vector<art::Ptr<raw::Trigger> > trigPtrVectWCTrack = findTheWCTrackTrig.at(iWCTrack);
    unsigned int triggerIDWCTrack = trigPtrVectWCTrack.at(0)->TriggerNumber();
    //Loop through the TOF and get the trigger ID
    int matchCounter = 0;
    bool uniqueMatch = false;
    ldp::WCTrack theWCTrack = WCTrackColHandle->at(iWCTrack);
    ldp::TOF theTOF;
    for( size_t iTOF = 0; iTOF < TOFColHandle->size(); ++iTOF ){
      std::vector<art::Ptr<raw::Trigger> > trigPtrVectTOF = findTheTOFTrig.at(iTOF);
      unsigned int triggerIDTOF = trigPtrVectTOF.at(0)->TriggerNumber();
      if( triggerIDWCTrack == triggerIDTOF ){
	matchCounter++;
	uniqueMatch = true;
	theTOF = TOFColHandle->at(iTOF);
      }
      if( matchCounter > 1 ){
	uniqueMatch = false;
	break;
      }
    }
    if( uniqueMatch == true ){
      //Send to histo for cut analysis
      if( fVerbose )
	std::cout << "Number of hits in TOF: " << theTOF.NTOF() << std::endl;
      if( fPlotHistograms ){
	fNTOF->Fill(theTOF.NTOF());
	fPz->Fill(theWCTrack.Momentum());
	fTOF->Fill(theTOF.SingleTOF(0));
	short timeOfFlight = theTOF.SingleTOF(0);
	float pz = theWCTrack.Momentum();
	fPzVsTOF->Fill(pz,timeOfFlight);
      }

      //Send to PIDAlg for identification
    }
  }
  
}

void ParticleIdentification::beginJob()
{
  // Implementation of optional member function here.
  if( fPlotHistograms ){
    art::ServiceHandle<art::TFileService> tfs;
    fPzVsTOF = tfs->make<TH2F>("PzVsTOF","Pz vs. Time of Flight",40,0,1600,40,20,80);
    fNTOF = tfs->make<TH1F>("NTOF","Number of TOF values per TOF object",10,0,10);
    fPz = tfs->make<TH1F>("Reco_Pz","Reconstructed momentum",180,0,1800);
    fTOF = tfs->make<TH1F>("Reco_TOF","Reconstructed Time of Flight",70,20,90);
    
  }
}

void ParticleIdentification::beginRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::beginSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::endJob()
{
  // Implementation of optional member function here.
}

void ParticleIdentification::endRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::endSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
  fWCTrackModuleLabel           =p.get< std::string >("WCTrackModuleLabel");
  fTOFModuleLabel               =p.get< std::string >("TOFModuleLabel");
  fVerbose                      =p.get< bool >("Verbose");
  fPlotHistograms               =p.get< bool >("PlotHistograms");
}

void ParticleIdentification::respondToCloseInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::respondToCloseOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::respondToOpenInputFile(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

void ParticleIdentification::respondToOpenOutputFiles(art::FileBlock const & fb)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(ParticleIdentification)
