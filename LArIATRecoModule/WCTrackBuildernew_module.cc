////////////////////////////////////////////////////////////////////////
// Class:       WCTrackBuildernew
// Module Type: producer
// File:        WCTrackBuildernew_module.cc
//
// Generated at Fri Oct 16 14:58:18 2015 by Greg Pulliam using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#ifndef WCTRACKBUILDERNEW_H
#define WCTRACKBUILDERNEW_H


#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include <iostream>

#include <vector>
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "art/Framework/Services/Optional/TFileService.h"


//ROOT Things
#include <TH1F.h>
#include <TH2F.h>
#include <TTree.h>

//LArIAT Things
#include "RawDataUtilities/TriggerDigitUtility.h"
#include "LArIATRecoAlg/WCTrackBuilderAlg.h"
#include "LArIATRecoAlg/WCHitFinderAlg.h"
#include "LArIATDataProducts/WCTrack.h"
#include "Utilities/DatabaseUtilityT1034.h"

#include <memory>
#include <utility>
#include <string>
#include <fstream>
namespace wct{
class WCTrackBuildernew;

class WCTrackBuildernew : public art::EDProducer {
public:
  explicit WCTrackBuildernew(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  WCTrackBuildernew(WCTrackBuildernew const &) = delete;
  WCTrackBuildernew(WCTrackBuildernew &&) = delete;
  WCTrackBuildernew & operator = (WCTrackBuildernew const &) = delete;
  WCTrackBuildernew & operator = (WCTrackBuildernew &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  //void beginJob(fhicl::ParameterSet const & p);
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
  void endJob() override;
//  void endRun(art::Run & r) override;
//  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
//  void respondToCloseInputFile(art::FileBlock const & fb) override;
//  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
//  void respondToOpenInputFile(art::FileBlock const & fb) override;
//  void respondToOpenOutputFiles(art::FileBlock const & fb) override;
  void convertDigitsToVectors( std::vector<raw::AuxDetDigit> the_digits_1,
			       std::vector<raw::AuxDetDigit> the_digits_2,
			       std::vector<raw::AuxDetDigit> the_digits_3,
			       std::vector<raw::AuxDetDigit> the_digits_4,
			       std::vector<int> & tdc_number_vect,
			       std::vector<float> & hit_channel_vect,
			       std::vector<float> & hit_time_bin_vect );

  void createAuxDetStyleVectorsFromHitLists(WCHitList final_track,
					    std::vector<int> & WC_vect,
					    std::vector<float> & hit_wire_vect);
					    
					    
  void plotTheTrackInformation( std::vector<double> reco_pz_list,
				std::vector<double> x_face_list,
				std::vector<double> y_face_list,
				std::vector<double> theta_list,
				std::vector<double> phi_list,
				std::vector<double> y_kink_list,
				std::vector<double> x_dist_list,
				std::vector<double> y_dist_list,
				std::vector<double> z_dist_list);
				
				
  void MakeSomePlotsFromHits(std::vector<std::vector<WCHitList> > good_hits);
private:

  // Declare member data here.

    //Offset ont he B field
    float offset;


    //Algorithm object for track building
    WCTrackBuilderAlg fWCTrackBuilderAlg;
    std::string       fSlicerSourceLabel;
    WCHitFinderAlg    fWCHitFinderAlg;

    //Hardware constants
    int fNumber_wire_chambers;
    int fNumber_wires_per_tdc;
    
    //int evtcounter = 0;
    //Histograms for plotting
    TH1F* fReco_Pz;
    TH1F* fY_Kink;
    TH1F* fX_Dist;
    TH1F* fY_Dist;
    TH1F* fZ_Dist;
    TH1F* fX_Face_Dist;
    TH1F* fY_Face_Dist;
    TH1F* fTheta_Dist;
    TH1F* fPhi_Dist;
    TH1F* fTrack_Type;
    std::vector<TH2F*> fRecodiff;
    TH1F* fWCDist;
/*    TH1F* fHitErrorWC1;
    TH1F* fHitErrorWC2;    
    TH1F* fHitErrorWC3;
    TH1F* fHitErrorWC4;
    TH1F* fXWireWC1;
    TH1F* fYWireWC1;    
    TH1F* fXWireWC2;
    TH1F* fYWireWC2; 
    TH1F* fXWireWC3;
    TH1F* fYWireWC3; 
    TH1F* fXWireWC4;
    TH1F* fYWireWC4; 
    TH2F* fHitHeatMapWC1;
    TH2F* fHitHeatMapWC2;
    TH2F* fHitHeatMapWC3;
    TH2F* fHitHeatMapWC4;
    TH2F* fHitsAvailable;
 std::vector<TH1F*> fWireHitsGoodTracks;
 std::vector<TH2F*> fWCMult;
 std::vector<TH1F*> fWireHitsTheTrack;
 std::vector<TH1F*> fBadTrackHits;
 TH2F* fTargetXY;
 TH2F* fPickyTracksTargetXY;
 TH1F* fResSquare;
 TH1F* fReco4pt;
 TH2F* fReco4ptdiff;
 std::vector<TH2F*> fTimingXY;
 std::vector<TH2F*> fRegressionPlots;
 TH1F* fMatchedHits;
 std::vector<TH1F*> fRegressionPlots1D;
 std::vector<TH2F*> fRecoplots;
 TH1F* fBfield;   */         
    //Misc
    bool fVerbose;
    bool fPickyTracks;
    bool fHighYield;
    bool fCheckTracks;
    //TTree *tree = new TTree("WCVars", "WCVars");
    
};


WCTrackBuildernew::WCTrackBuildernew(fhicl::ParameterSet const & p)
 : fWCTrackBuilderAlg(p.get< fhicl::ParameterSet > ("WCTrackBuilderAlg")) // these should be initialized
 , fWCHitFinderAlg(p.get< fhicl::ParameterSet >("WCHitFinderAlg"))            // here instead of reconfigure()
{
  // Call appropriate produces<>() functions here.
      this->reconfigure(p);

    // Call appropriate produces<>() functions here.  
    produces<std::vector<ldp::WCTrack> >();
}

void WCTrackBuildernew::produce(art::Event & e)
{
  //evtcounter++; //counting events
  // Implementation of required member function here.
    //Creating the WCTrack Collection
    std::unique_ptr<std::vector<ldp::WCTrack> > WCTrackCol(new std::vector<ldp::WCTrack> );  

    //Retrieving the digits from the sliced event
    art::Handle< std::vector<raw::AuxDetDigit> > AuxDetDigitHandle;
    e.getByLabel(fSlicerSourceLabel,AuxDetDigitHandle);
    
    //Loop through the auxdetdigits and collect those that are from the WCs
    std::vector<raw::AuxDetDigit> WC1Digits;
    std::vector<raw::AuxDetDigit> WC2Digits;
    std::vector<raw::AuxDetDigit> WC3Digits;
    std::vector<raw::AuxDetDigit> WC4Digits;
    for( size_t iDig = 0; iDig < AuxDetDigitHandle->size(); ++iDig ){
      if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC1" )
	WC1Digits.push_back(AuxDetDigitHandle->at(iDig));
      if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC2" )
	WC2Digits.push_back(AuxDetDigitHandle->at(iDig));
      if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC3" )
	WC3Digits.push_back(AuxDetDigitHandle->at(iDig));
      if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC4" )
	WC4Digits.push_back(AuxDetDigitHandle->at(iDig));
    }  
    std::vector<int> tdc_number_vect;
    std::vector<float> hit_channel_vect;
    std::vector<float> hit_time_bin_vect;
    convertDigitsToVectors( WC1Digits,
			    WC2Digits,
			    WC3Digits,
			    WC4Digits,
			    tdc_number_vect,
			    hit_channel_vect,
			    hit_time_bin_vect ); 
			      
   		    		    
    std::vector<double> reco_pz_list;                  //Final reco pz result for full_track_info = true, not indexed by trigger
    std::vector<double> reco_pz2M_list;
    std::vector<double> x_face_list;
    std::vector<double> y_face_list;
    std::vector<double> theta_list;
    std::vector<double> phi_list;
    std::vector<double> y_kink_list;
    std::vector<double> x_dist_list;
    std::vector<double> y_dist_list;
    std::vector<double> z_dist_list;
    std::vector<WCHitList> final_tracks;
    float hit_position_vect[4][3];
    float residual;  
    std::vector<std::vector<WCHitList> > good_hits; //Two vectors: WC#, axis. - Will be cleared for each trigger 
    int WCMissed; //The WC missed for the event, if there is one.
    //Initializing the good hit arrays to a default state - these clear for every trigger
    //Have 2-dimensional array of hitlists:
    //1st Dim: WC
    //2nd Dim: Axis    
    WCHitList hitList;
    std::vector<WCHitList> hitListAxis;
    for( int iAx = 0; iAx < 2; ++iAx ){ hitListAxis.push_back(hitList); }
    for( int iWC = 0; iWC < fNumber_wire_chambers; ++iWC ){ good_hits.push_back(hitListAxis); }
    
    //initialize the position array for the hits in the track put on the event
    for(int i=0; i<4; ++i){
      for(int j=0; j<3; ++j){
       hit_position_vect[i][j]=99999;
       }
     }
    
    //int good_trigger_counter = 0;
    fWCHitFinderAlg.createHits(tdc_number_vect,
    			       hit_channel_vect,
			       hit_time_bin_vect,
			       good_hits,
			       fVerbose);
   // MakeSomePlotsFromHits(good_hits);		
    
    	       
  fTrack_Type->Fill(fWCHitFinderAlg.getTrackType(good_hits));
//std::cout<<"Hit Finding done, going to Track Building"<<std::endl;
  fWCTrackBuilderAlg.reconstructTracks(  reco_pz_list,
                                         reco_pz2M_list,
					 x_face_list,
					 y_face_list,
					 theta_list,
					 phi_list,
					 final_tracks,
					 good_hits,
					 fPickyTracks,
					 fHighYield,
					 fCheckTracks,
					 y_kink_list,
					 x_dist_list,
					 y_dist_list,
					 z_dist_list,
					 WCMissed,
					 fRecodiff,
					 fWCDist,
					 residual,
					 hit_position_vect,
                                         offset);			       
  std::cout<<" reco_pz: "<<reco_pz_list.size()<<std::endl;
  if(reco_pz2M_list.size())  std::cout<<"Checking the filling up of reco_pz2m: "<<reco_pz2M_list.size()<<" "<<reco_pz2M_list[0]<<" "<<reco_pz_list[0]<<std::endl;
//tree->Branch("reco_pz",&reco_pz_list[0],"reco_pz/D");
//tree->Fill();
//fTrack_Type->Fill(fWCHitFinderAlg.getTrackType());    // WCHitFinderAlg::getTrackType() does not exist
//fTrack_Type->Fill(fWCTrackBuildernewAlg.getTrackType()); // neither does WCTrackBuildernewAlg_new::getTrackType()
                                                        // but WCTrackBuildernewAlg::getTrackType() exists!
//std::cout<<"Tracks before: "<<track_count_pre<<"Tracks after "<<track_count<<std::endl;
     //Pick out the tracks created under this current trigger and fill WCTrack objects with info.
    //(This must be done because the track/etc. lists encompass all triggers
    int tracknumber=final_tracks.size();
    for( int iNewTrack = 0; iNewTrack<tracknumber; ++iNewTrack ){
      std::vector<int> WC_vect;
      std::vector<float> hit_wire_vect;
      //std::vector<float> hit_time_vect;
      
      WCHitList final_track = final_tracks[iNewTrack];
      
      
      //Filling as done above, but formats the WC and hit wire vectors in the WCAuxDetDigit style
      createAuxDetStyleVectorsFromHitLists(final_track,
					   WC_vect,
					   hit_wire_vect);
      
      //WCTrack object creation and association with trigger created
if(reco_pz2M_list.size() > 0){      ldp::WCTrack the_track(reco_pz_list[iNewTrack],
	                     reco_pz2M_list[iNewTrack],
                             y_kink_list[iNewTrack],
			     x_dist_list[iNewTrack],
			     y_dist_list[iNewTrack],
			     z_dist_list[iNewTrack],
			     x_face_list[iNewTrack],
			     y_face_list[iNewTrack],
			     theta_list[iNewTrack],
			     phi_list[iNewTrack],
			     WC_vect,
			     hit_wire_vect,
			     hit_position_vect,
			     WCMissed,
			     residual);
      (*WCTrackCol).push_back( the_track );}
else{
ldp::WCTrack the_track(reco_pz_list[iNewTrack],
                             y_kink_list[iNewTrack],
			     x_dist_list[iNewTrack],
			     y_dist_list[iNewTrack],
			     z_dist_list[iNewTrack],
			     x_face_list[iNewTrack],
			     y_face_list[iNewTrack],
			     theta_list[iNewTrack],
			     phi_list[iNewTrack],
			     WC_vect,
			     hit_wire_vect,
			     hit_position_vect,
			     WCMissed,
			     residual);
      (*WCTrackCol).push_back( the_track );

}
    }

    //Plot the reconstructed momentum, y_kink, and delta X, Y, Z in histos
    plotTheTrackInformation(reco_pz_list,
			    x_face_list,
			    y_face_list,
			    theta_list,
			    phi_list,
			    y_kink_list,
			    x_dist_list,
			    y_dist_list,
			    z_dist_list);
    
    
    //Put objects into event (root file)
    e.put(std::move(WCTrackCol)); 
    //hit_position_vect.clear();//clear the position vector for the next event.				
}
  //==================================================================================================
  void WCTrackBuildernew::createAuxDetStyleVectorsFromHitLists(WCHitList final_track,
								   std::vector<int> & WC_vect,
								   std::vector<float> & hit_wire_vect)
  {
    for( size_t iHit = 0; iHit < final_track.hits.size() ; ++iHit ){
      WC_vect.push_back(int(iHit/2)+1);          //Look at how hits are pushed into the tracks in buildTracksFromHits (alg)

      float the_wire = (final_track.hits.at(iHit).wire*-1)+64+(128*(iHit%2));
      if (fVerbose) { std::cout << "Old WCAxis/Wire: " << iHit << "/" << final_track.hits.at(iHit).wire << ", New WC/Wire: " << int(iHit/2)+1 << "/" << the_wire << std::endl; }
      hit_wire_vect.push_back(the_wire);    
    }
  }
//   //=======================================================================================
// /*   void WCTrackBuildernew::MakeSomePlotsFromHits(std::vector<std::vector<WCHitList> > good_hits)
//   {
//   //bool timematch; //Bool needed for Orphan Hits
// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// int error;
// //WC1 Stuff!
//     int iWC=0;
//     int xSize=good_hits.at(iWC).at(0).hits.size();
//     int ySize=good_hits.at(iWC).at(1).hits.size();
//     //std::cout<<"For the first WC the X,Y sizes are "<<xSize<<", "<<ySize<<std::endl;
//     if(xSize !=0 && ySize !=0) {fHitHeatMapWC1->Fill(xSize, ySize); // 2D plot of #of hits
//     error =good_hits.at(iWC).at(0).hits.size()-good_hits.at(iWC).at(1).hits.size(); //Does one axis have more hits?
//     fHitErrorWC1->Fill(error);
//     
//     
//     for(int xIter=0; xIter<xSize; ++xIter){fXWireWC1->Fill(good_hits.at(iWC).at(0).hits.at(xIter).wire);}
//     for(int yIter=0; yIter<ySize; ++yIter){fYWireWC1->Fill(good_hits.at(iWC).at(1).hits.at(yIter).wire);}   
// //If the Y axis has more hits, loop over all the hit times, find a time that isn't matched in the X hit times
//    /*  if(error<0) 
//     { 
//       for(size_t yIter=0; yIter<good_hits.at(iWC).at(1).hits.size(); ++yIter){
//         timematch=false;
//         int yTime=good_hits.at(iWC).at(1).hits.at(yIter).time;
// 	for(size_t xIter=0; xIter<good_hits.at(iWC).at(0).hits.size(); ++xIter){
//           if(fabs(good_hits.at(iWC).at(0).hits.at(xIter).time-yTime)<2){timematch=true;}
// 	  }
// // When the Orphaned Time is found, fill a hist of the Y wire that was orphaned.  For real hits, this should be flat.  For noisy wires that get through DBscan clustering, those wires will peak here.	  
// 	if(timematch==false){fOrphanHitsYWC1->Fill(good_hits.at(iWC).at(1).hits.at(yIter).wire);}
//       }
//     }
// // Do the same method, this time if X is the busier axis, filling the Oprhaned X hit      
//     if(error>0)
//     {
//       for(size_t xIter=0; xIter<good_hits.at(iWC).at(0).hits.size(); ++xIter){
//         timematch=false;
// 	int xTime=good_hits.at(iWC).at(0).hits.at(xIter).time;
// 	for(size_t yIter=0; yIter<good_hits.at(iWC).at(1).hits.size(); ++yIter){
// 	  if(fabs(good_hits.at(iWC).at(1).hits.at(yIter).time-xTime)<2){timematch=true;}
// 	}
// 	if(timematch==false){fOrphanHitsXWC1->Fill(good_hits.at(iWC).at(0).hits.at(xIter).wire);}
//       } */
//       
//      }
// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
// 
// 
// 
//   
// //WC2 Hists    
//     iWC=1;
//      xSize=good_hits.at(iWC).at(0).hits.size();
//      ySize=good_hits.at(iWC).at(1).hits.size();
//     if(xSize !=0 && ySize !=0) {fHitHeatMapWC2->Fill(xSize, ySize); // 2D plot of #of hits
//     error =good_hits.at(iWC).at(0).hits.size()-good_hits.at(iWC).at(1).hits.size(); //Does one axis have more hits?
//     fHitErrorWC2->Fill(error);
//     
//     for(int xIter=0; xIter<xSize; ++xIter){fXWireWC2->Fill(good_hits.at(iWC).at(0).hits.at(xIter).wire);}
//     for(int yIter=0; yIter<ySize; ++yIter){fYWireWC2->Fill(good_hits.at(iWC).at(1).hits.at(yIter).wire);}   
// //WC2: If the Y axis has more hits, loop over all the hit times, find a time that isn't matched in the X hit times
//    /*  if(error<0) 
//     { 
//       for(size_t yIter=0; yIter<good_hits.at(iWC).at(1).hits.size(); ++yIter){
//         timematch=false;
//         int yTime=good_hits.at(iWC).at(1).hits.at(yIter).time;
// 	for(size_t xIter=0; xIter<good_hits.at(iWC).at(0).hits.size(); ++xIter){
//           if(fabs(good_hits.at(iWC).at(0).hits.at(xIter).time-yTime)<2){timematch=true;}
// 	  }
// //When the Orphaned Time is found, fill a hist of the Y wire that was orphaned.  For real hits, this should be flat.  For noisy wires that get through DBscan clustering, those wires will peak here.	  
// 	if(timematch==false){fOrphanHitsYWC2->Fill(good_hits.at(iWC).at(1).hits.at(yIter).wire);}
//       }
//     }
// //Do the same method, this time if X is the busier axis, filling the Oprhaned X hit      
//     if(error>0)
//     {
//       for(size_t xIter=0; xIter<good_hits.at(iWC).at(0).hits.size(); ++xIter){
//         timematch=false;
//         int xTime=good_hits.at(iWC).at(0).hits.at(xIter).time;
// 	for(size_t yIter=0; yIter<good_hits.at(iWC).at(1).hits.size(); ++yIter){
// 	  if(fabs(good_hits.at(iWC).at(1).hits.at(yIter).time-xTime)<2){timematch=true;}
// 	}
// 	if(timematch==false){fOrphanHitsXWC2->Fill(good_hits.at(iWC).at(0).hits.at(xIter).wire);}
//       } */
//     
//     }
// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// 
//     
// //WC3        
//     iWC=2;
//     xSize=good_hits.at(iWC).at(0).hits.size();
//     ySize=good_hits.at(iWC).at(1).hits.size();
//     if(xSize !=0 && ySize !=0) {fHitHeatMapWC3->Fill(xSize, ySize); // 2D plot of #of hits, only if it's not empty
//     error =good_hits.at(iWC).at(0).hits.size()-good_hits.at(iWC).at(1).hits.size(); //Does one axis have more hits?
//     fHitErrorWC3->Fill(error);
//     
//     for(int xIter=0; xIter<xSize; ++xIter){fXWireWC3->Fill(good_hits.at(iWC).at(0).hits.at(xIter).wire);}
//     for(int yIter=0; yIter<ySize; ++yIter){fYWireWC3->Fill(good_hits.at(iWC).at(1).hits.at(yIter).wire);}     
// //If the Y axis has more hits, loop over all the hit times, find a time that isn't matched in the X hit times
// /*     if(error<0) 
//     { 
//       for(size_t yIter=0; yIter<good_hits.at(iWC).at(1).hits.size(); ++yIter){
//         timematch=false;
//         int yTime=good_hits.at(iWC).at(1).hits.at(yIter).time;
// 	for(size_t xIter=0; xIter<good_hits.at(iWC).at(0).hits.size(); ++xIter){
//           if(fabs(good_hits.at(iWC).at(0).hits.at(xIter).time-yTime)<2){timematch=true;}
// 	  }
// //When the Orphaned Time is found, fill a hist of the Y wire that was orphaned.  For real hits, this should be flat.  For noisy wires that get through DBscan clustering, those wires will peak here.	  
// 	if(timematch==false){fOrphanHitsYWC3->Fill(good_hits.at(iWC).at(1).hits.at(yIter).wire);}
//       }
//     }
// //Do the same method, this time if X is the busier axis, filling the Oprhaned X hit      
//     if(error>0)
//     {
//       for(size_t xIter=0; xIter<good_hits.at(iWC).at(0).hits.size(); ++xIter){
//         timematch=false;
// 	int xTime=good_hits.at(iWC).at(0).hits.at(xIter).time;
// 	for(size_t yIter=0; yIter<good_hits.at(iWC).at(1).hits.size(); ++yIter){
// 	  if(fabs(good_hits.at(iWC).at(1).hits.at(yIter).time-xTime)<2){timematch=true;}
// 	}
// 	if(timematch==false){fOrphanHitsXWC3->Fill(good_hits.at(iWC).at(0).hits.at(xIter).wire);}
//       }
//     } */
//     }
// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
// //WC4
//     iWC=3;
//     xSize=good_hits.at(iWC).at(0).hits.size();
//     ySize=good_hits.at(iWC).at(1).hits.size();
//    if(xSize !=0 && ySize !=0) {fHitHeatMapWC4->Fill(xSize, ySize); // 2D plot of #of hits
//     error =good_hits.at(iWC).at(0).hits.size()-good_hits.at(iWC).at(1).hits.size(); //Does one axis have more hits?
//     fHitErrorWC4->Fill(error);
//     for(int xIter=0; xIter<xSize; ++xIter){fXWireWC4->Fill(good_hits.at(iWC).at(0).hits.at(xIter).wire);}
//     for(int yIter=0; yIter<ySize; ++yIter){fYWireWC4->Fill(good_hits.at(iWC).at(1).hits.at(yIter).wire);}     
// /* //If the Y axis has more hits, loop over all the hit times, find a time that isn't matched in the X hit times
//     if(error<0) 
//     { 
//       for(size_t yIter=0; yIter<good_hits.at(iWC).at(1).hits.size(); ++yIter){
//         timematch=false;
//         int yTime=good_hits.at(iWC).at(1).hits.at(yIter).time;
// 	for(size_t xIter=0; xIter<good_hits.at(iWC).at(0).hits.size(); ++xIter){
//           if(fabs(good_hits.at(iWC).at(0).hits.at(xIter).time-yTime)<2){timematch=true;}
// 	  }
// //When the Orphaned Time is found, fill a hist of the Y wire that was orphaned.  For real hits, this should be flat.  For noisy wires that get through DBscan clustering, those wires will peak here.	  
// 	if(timematch==false){fOrphanHitsYWC4->Fill(good_hits.at(iWC).at(1).hits.at(yIter).wire);}
//       }
//     }
// //Do the same method, this time if X is the busier axis, filling the Oprhaned X hit      
//     if(error>0)
//     {
//       for(size_t xIter=0; xIter<good_hits.at(iWC).at(0).hits.size(); ++xIter){
//         timematch=false;
// 	int xTime=good_hits.at(iWC).at(0).hits.at(xIter).time;
// 	for(size_t yIter=0; yIter<good_hits.at(iWC).at(1).hits.size(); ++yIter){
// 	  if(fabs(good_hits.at(iWC).at(1).hits.at(yIter).time-xTime)<2){timematch=true;}
// 	}
// 	if(timematch==false){fOrphanHitsXWC4->Fill(good_hits.at(iWC).at(0).hits.at(xIter).wire);}
//       }
//     } */
//     					 
//     }
// //To see what things we can calculate in track building, Fill a histogram showing how many times there were 3 or 4 WC with X wires vs 3 or 4 WC Y wires.  This will
// //let us know what we can do with 6 or 7 point tracks later on
//     int xPoints=0;
//     int yPoints=0;
//     int XYMatch=0;
//     for(iWC=0;iWC<4;++iWC)
//     {
//       if(good_hits[iWC][0].hits.size() >= 1){++xPoints;}
//       if(good_hits[iWC][1].hits.size() >= 1){++yPoints;}
//       if(good_hits[iWC][0].hits.size() >= 1 && good_hits[iWC][1].hits.size() >=1){++XYMatch;}
//     }
//     
//     fHitsAvailable->Fill(xPoints,yPoints);
//     fMatchedHits->Fill(XYMatch);
//     if(xPoints < 0 || yPoints < 0){std::cout<<"You have negative points available!!!!!!"<<std::endl;}
//     if(xPoints > 4 || yPoints > 4){std::cout<<"There are more than 4 WCs available!!!!!!!!"<<std::endl;}
//   } */
  //===================================================================================
  void WCTrackBuildernew::plotTheTrackInformation( std::vector<double> reco_pz_list,
							 std::vector<double> x_face_list,
							 std::vector<double> y_face_list,
							 std::vector<double> theta_list,
							 std::vector<double> phi_list,
							 std::vector<double> y_kink_list,
							 std::vector<double> x_dist_list,
							 std::vector<double> y_dist_list,
							 std::vector<double> z_dist_list)
  {
    //Loop through the tracks and fill
    for( size_t iTrack = 0; iTrack < reco_pz_list.size(); ++iTrack ){
      fReco_Pz->Fill(reco_pz_list.at(iTrack));
      fY_Kink->Fill(y_kink_list.at(iTrack));
      fX_Dist->Fill(x_dist_list.at(iTrack));
      fY_Dist->Fill(y_dist_list.at(iTrack));
      fZ_Dist->Fill(z_dist_list.at(iTrack));
      fX_Face_Dist->Fill(x_face_list.at(iTrack));
      fY_Face_Dist->Fill(y_face_list.at(iTrack));
      fTheta_Dist->Fill(theta_list.at(iTrack));
      fPhi_Dist->Fill(phi_list.at(iTrack));
    }
    
  }
//=========================================================================================
void WCTrackBuildernew::beginJob()//fhicl::ParameterSet const & p)
{



  // Implementation of optional member function here.
      // Implementation of optional member function here.
    art::ServiceHandle<art::TFileService> tfs;
    
//reconfigure(p);
//Hists that should be used for diagnostics and deleted before production
if(fCheckTracks){
  for(int i=0; i<99; ++i){
    fRecodiff.push_back(tfs->make<TH2F>());
  }
fRecodiff[0]= tfs->make<TH2F>("WC1XWire4v2","WC1XWire4v2",500,-250,250,500,-250,250);
fRecodiff[1]= tfs->make<TH2F>("WC1YWire4v2","WC1YWire4v2",500,-250,250,500,-250,250);
fRecodiff[2]= tfs->make<TH2F>("WC2XWire4v2","WC2XWire4v2",500,-250,250,500,-250,250);
fRecodiff[3]= tfs->make<TH2F>("WC2YWire4v2","WC2YWire4v2",500,-250,250,500,-250,250);
fRecodiff[4]= tfs->make<TH2F>("WC3XWire4v2","WC3XWire4v2",500,-250,250,500,-250,250);
fRecodiff[5]= tfs->make<TH2F>("WC3YWire4v2","WC3YWire4v2",500,-250,250,500,-250,250);
fRecodiff[6]= tfs->make<TH2F>("WC4XWire4v2","WC4XWire4v2",500,-250,250,500,-250,250);
fRecodiff[7]= tfs->make<TH2F>("WC4YWire4v2","WC4YWire4v2",500,-250,250,500,-250,250);


fRecodiff[8]= tfs->make<TH2F>("WC1XWire4v3","WC1XWire4v3",500,-250,250,500,-250,250);
fRecodiff[9]= tfs->make<TH2F>("WC1YWire4v3","WC1YWire4v3",500,-250,250,500,-250,250);
fRecodiff[10]= tfs->make<TH2F>("WC2XWire4v3","WC2XWire4v3",500,-250,250,500,-250,250);
fRecodiff[11]= tfs->make<TH2F>("WC2YWire4v3","WC2YWire4v3",500,-250,250,500,-250,250);
fRecodiff[12]= tfs->make<TH2F>("WC3XWire4v3","WC3XWire4v3",500,-250,250,500,-250,250);
fRecodiff[13]= tfs->make<TH2F>("WC3YWire4v3","WC3YWire4v3",500,-250,250,500,-250,250);
fRecodiff[14]= tfs->make<TH2F>("WC4XWire4v3","WC4XWire4v3",500,-250,250,500,-250,250);
fRecodiff[15]= tfs->make<TH2F>("WC4YWire4v3","WC4YWire4v3",500,-250,250,500,-250,250);

fRecodiff[16]= tfs->make<TH2F>("X14v2","X14v2",4000,0,4000,4000,0,4000);
fRecodiff[17]= tfs->make<TH2F>("X24v2","X24v2",300,550,850,300,550,850);
fRecodiff[18]= tfs->make<TH2F>("X34v2","X34v2",4000,0,4000,4000,0,4000);
fRecodiff[19]= tfs->make<TH2F>("X44v2","X44v2",4000,0,4000,4000,0,4000);

fRecodiff[20]= tfs->make<TH2F>("X14v3","X14v3",4000,0,4000,4000,0,4000);
fRecodiff[21]= tfs->make<TH2F>("X24v3","X24v3",4000,0,4000,4000,0,4000);
fRecodiff[22]= tfs->make<TH2F>("X34v3","X34v3",4000,0,4000,4000,0,4000);
fRecodiff[23]= tfs->make<TH2F>("X44v3","X44v3",4000,0,4000,4000,0,4000);

fRecodiff[24]= tfs->make<TH2F>("Y14v2","Y14v2",200,-100,100,200,-100,100);
fRecodiff[25]= tfs->make<TH2F>("Y24v2","Y24v2",200,-100,100,200,-100,100);
fRecodiff[26]= tfs->make<TH2F>("Y34v2","Y34v2",200,-100,100,200,-100,100);
fRecodiff[27]= tfs->make<TH2F>("Y44v2","Y44v2",200,-100,100,200,-100,100);

fRecodiff[28]= tfs->make<TH2F>("Y14v3","Y14v3",200,-100,100,200,-100,100);
fRecodiff[29]= tfs->make<TH2F>("Y24v3","Y24v3",200,-100,100,200,-100,100);
fRecodiff[30]= tfs->make<TH2F>("Y34v3","Y34v3",200,-100,100,200,-100,100);
fRecodiff[31]= tfs->make<TH2F>("Y44v3","Y44v3",200,-100,100,200,-100,100);

fRecodiff[32]= tfs->make<TH2F>("Z14v2","Z14v2",10000,-10000,0,10000,-10000,0);
fRecodiff[33]= tfs->make<TH2F>("Z24v2","Z24v2",100,-5400,-5300,100,-5400,-5300);
fRecodiff[34]= tfs->make<TH2F>("Z34v2","Z34v2",10000,-10000,0,10000,-10000,0);
fRecodiff[35]= tfs->make<TH2F>("Z44v2","Z44v2",10000,-10000,0,10000,-10000,0);

fRecodiff[36]= tfs->make<TH2F>("Z14v3","Z14v3",10000,-10000,0,10000,-10000,0);
fRecodiff[37]= tfs->make<TH2F>("Z24v3","Z24v3",10000,-10000,0,10000,-10000,0);
fRecodiff[38]= tfs->make<TH2F>("Z34v3","Z34v3",10000,-10000,0,10000,-10000,0);
fRecodiff[39]= tfs->make<TH2F>("Z44v3","Z44v3",10000,-10000,0,10000,-10000,0);

fRecodiff[40]=tfs->make<TH2F>("TPCx4v2","TPCx4v2",800,-400,400,800,-400,400);
fRecodiff[41]=tfs->make<TH2F>("TPCy4v2","TPCy4v2",400,-200,200,400,-200,200);
fRecodiff[42]=tfs->make<TH2F>("TPCx4v3","TPCx4v3",300,100,400,300,100,400);
fRecodiff[43]=tfs->make<TH2F>("TPCy4v3","TPCy4v3",400,-200,200,400,-200,200);

fRecodiff[44]=tfs->make<TH2F>("TPCPhi4v2","TPCPhi4v2",80,-4,4,80,-4,4);
fRecodiff[45]=tfs->make<TH2F>("TPCTheta4v2","TPCTheta4v2",100,-.5,.5,100,-.5,.5);

fRecodiff[46]=tfs->make<TH2F>("TPCPhi4v3","TPCPhi4v3",80,-4,4,80,-4,4);
fRecodiff[47]=tfs->make<TH2F>("TPCTheta4v3","TPCTheta4v3",100,-.5,.5,100,-.5,.5);

fRecodiff[48]=tfs->make<TH2F>("XDist4v2","XDist4v2",500,-250,250,500,-250,250);
fRecodiff[49]=tfs->make<TH2F>("YDist4v2","YDist4v2",100,-50,50,100,-50,50);
fRecodiff[50]=tfs->make<TH2F>("ZDist4v2","ZDist4v2",100,-50,50,100,-50,50);
fRecodiff[51]=tfs->make<TH2F>("YKink4v2","YKink4v2",200,-.1,.1,200,-.1,.1);

fRecodiff[52]=tfs->make<TH2F>("XDist4v3","XDist4v3",500,-250,250,500,-250,250);
fRecodiff[53]=tfs->make<TH2F>("YDist4v3","YDist4v3",100,-50,50,100,-50,50);
fRecodiff[54]=tfs->make<TH2F>("ZDist4v3","ZDist4v3",100,-50,50,100,-50,50);
fRecodiff[55]=tfs->make<TH2F>("YKink4v3","YKink4v3",200,-.1,.1,200,-.1,.1);

fRecodiff[56]=tfs->make<TH2F>("mom4v2","relative error of S2 mom",1000,0,2000,200,-1,1);
fRecodiff[57]=tfs->make<TH2F>("mom4v3","relative error of S3 mom",1000,0,2000,200,-1,1);
fRecodiff[62]=tfs->make<TH2F>("mom4v4","relative error of S4 mom",1000,0,2000,200,-1,1);

fRecodiff[58]=tfs->make<TH2F>("Best residual all four","best residual all four",3000,0,300,3000,0,300);
fRecodiff[59]=tfs->make<TH2F>("Best residual Skip 2","best residual Skip 2",3000,0,300,3000,0,300);
fRecodiff[60]=tfs->make<TH2F>("Best residual Skip 3","best residual Skip 3",3000,0,300,3000,0,300);
fRecodiff[61]=tfs->make<TH2F>("Best residual Skip 4","best residual Skip 4",3000,0,300,3000,0,300);

fRecodiff[63]= tfs->make<TH2F>("X44v4","X44v4",4000,0,4000,4000,0,4000);
fRecodiff[64]= tfs->make<TH2F>("Y44v4","Y44v4",200,-100,100,200,-100,100);
fRecodiff[65]= tfs->make<TH2F>("Z44v4","Z44v4",10000,-10000,0,10000,-10000,0);

fRecodiff[66]=tfs->make<TH2F>("XDist4v4","XDist4v4",500,-250,250,500,-250,250);
fRecodiff[67]=tfs->make<TH2F>("YDist4v4","YDist4v4",100,-50,50,100,-50,50);
fRecodiff[68]=tfs->make<TH2F>("ZDist4v4","ZDist4v4",100,-50,50,100,-50,50);
fRecodiff[69]=tfs->make<TH2F>("YKink4v4","YKink4v4",200,-.1,.1,200,-.1,.1);

fRecodiff[70]=tfs->make<TH2F>("TPCPhi4v4","TPCPhi4v4",80,-4,4,80,-4,4);
fRecodiff[71]=tfs->make<TH2F>("TPCTheta4v4","TPCTheta4v4",100,-.5,.5,100,-.5,.5);

fRecodiff[72]= tfs->make<TH2F>("WC4XWire4v4","WC4XWire4v4",500,-250,250,500,-250,250);
fRecodiff[73]= tfs->make<TH2F>("WC4YWire4v4","WC4YWire4v4",500,-250,250,500,-250,250);

fRecodiff[74]=tfs->make<TH2F>("TPCx4v4","TPCx4v4",800,-400,400,800,-400,400);
fRecodiff[75]=tfs->make<TH2F>("TPCy4v4","TPCy4v4",400,-200,200,400,-200,200);

fRecodiff[76]=tfs->make<TH2F>("Best residual 4v2","best residual 4v2",3000,0,300,3000,0,300);
fRecodiff[77]=tfs->make<TH2F>("Best residual 4v3","best residual 4v3",3000,0,300,3000,0,300);
fRecodiff[78]=tfs->make<TH2F>("Best residual 4v4","best residual 4v4",3000,0,300,3000,0,300);

fRecodiff[79]=tfs->make<TH2F>("XwirediffS3","Difference in Xwire hit in WC3 (Actual-recreated)",600,-300,300,600,-300,300);
fRecodiff[80]=tfs->make<TH2F>("momentum","Reconstructed momentum",2000,0,2000,2000,0,2000);
fRecodiff[81]=tfs->make<TH2F>("WC1Timediff","Difference in time tick of X and Y hit in WC1",300,-150,150,300,-150,150);
fRecodiff[82]=tfs->make<TH2F>("WC2Timediff","Difference in time tick of X and Y hit in WC2",300,-150,150,300,-150,150);
fRecodiff[83]=tfs->make<TH2F>("WC3Timediff","Difference in time tick of X and Y hit in WC3",300,-150,150,300,-150,150);
fRecodiff[84]=tfs->make<TH2F>("WC4Timediff","Difference in time tick of X and Y hit in WC4",300,-150,150,300,-150,150);
fRecodiff[85]=tfs->make<TH2F>("4momvsres"," Residual versus momentum for 4 point tracks",180,0,1800,120,0,12);
fRecodiff[86]=tfs->make<TH2F>("dougsresidualtwo", "Distance WC2 Misses line through WC1 and WC4 (y,z) vs Momentum", 180,0,1800,1000,-500,500);
fRecodiff[87]=tfs->make<TH2F>("dougsresidualthree", "Distance WC3 Misses line through WC1 and WC4 (y,z) vs Momentum", 180,0,1800,1000,-500,500);
fRecodiff[88]=tfs->make<TH2F>("MomentumError","Fractional error of momentum",180,0,1800,200,0,.2);
fRecodiff[89]=tfs->make<TH2F>("mom2minus","Fractional Change in Momentum with -3mm shift in WC2X vs Orginal Momentum",1800,0,1800,500,-.05,.05);
fRecodiff[90]=tfs->make<TH2F>("mom2plus","Fractional Change in Momentum with +3mm shift in WC2X vs Orginal Momentum",1800,0,1800,500,-.05,.05);
fRecodiff[91]=tfs->make<TH2F>("mom3minus","Fractional Change in Momentum with -3mm shift in WC3X vs Orginal Momentum",1800,0,1800,500,-.05,.05);
fRecodiff[92]=tfs->make<TH2F>("mom3plus","Fractional Change in Momentum with +3mm shift in WC3X vs Orginal Momentum",1800,0,1800,500,-.05,.05);
fRecodiff[93]=tfs->make<TH2F>("Momplusplus","Fractional Change with WC 2 +3mm amd WC 3 + 3mm",1800,0,1800,1000,-.1,.1);
fRecodiff[94]=tfs->make<TH2F>("Momplusminus","Fractional Change with WC 2 +3mm amd WC 3 - 3mm",1800,0,1800,1000,-.1,.1);
fRecodiff[95]=tfs->make<TH2F>("Momminusplus","Fractional Change with WC 2 -3mm amd WC 3 + 3mm",1800,0,1800,1000,-.1,.1);
fRecodiff[96]=tfs->make<TH2F>("Momminusminus","Fractional Change with WC 2 -3mm amd WC 3 - 3mm",1800,0,1800,1000,-.1,.1);
fRecodiff[97]=tfs->make<TH2F>("XZMidplane", "XZ point halfway between line of closest approach", 1000,-5000,-4000,1000,0,1000);
fRecodiff[98]=tfs->make<TH2F>("dist","Distance of Closest Approach", 100,0,100,100,0,100);

}
fWCDist= tfs->make<TH1F>("WCCond","WC Conditions",7,0,7);


//fRecodiff[0] = tfs->make<TH2F>("Recofourvsthree","Reco4vs3", 100,0,1000,100,0,1000);
   //fEventPicky=tfs->make<TH1F>("event with picky", "event with picky", 25000,0,25000);
//     fResSquare = tfs->make<TH1F>("Sum of Square of Residuals from Y points to Linear Regression","Sum of Square of Residuals from Y points to Linear Regression", 150,0,150);
//     fReco4pt = tfs->make<TH1F>("Doug's 4 point reco", "Doug's 4 point reco", 200,0,2000);
//     fReco4ptdiff = tfs->make<TH2F>("Doug's 4 point reco difference", "Doug's 4 point reco difference", 800,-4000,4000, 400,-2000,2000);
//     fHitsAvailable = tfs->make<TH2F>("WCs Available per axis for a track", "WCs available per axis for a track", 5,0,5,5,0,5);
//     fHitsAvailable->GetXaxis()->SetTitle("Number of WCX axes available");
//     fHitsAvailable->GetYaxis()->SetTitle("Number of WCY axes available");
//     fMatchedHits = tfs->make<TH1F>("Total Pairs Available", "Total Pairs Available", 5,0,5);
//     fHitHeatMapWC1 = tfs->make<TH2F>("WC1 Hit Map","Number of Hits on each Axis in WC1", 10,0,10,10,0,10);
//     fHitHeatMapWC2 = tfs->make<TH2F>("WC2 Hit Map","Number of Hits on each Axis in WC2", 10,0,10,10,0,10);
//     fHitHeatMapWC3 = tfs->make<TH2F>("WC3 Hit Map","Number of Hits on each Axis in WC3", 10,0,10,10,0,10);
//     fHitHeatMapWC4 = tfs->make<TH2F>("WC4 Hit Map","Number of Hits on each Axis in WC4", 10,0,10,10,0,10);
//     fHitHeatMapWC1->GetXaxis()->SetTitle("Number of Hits on X Axis");
//     fHitHeatMapWC2->GetXaxis()->SetTitle("Number of Hits on X Axis");
//     fHitHeatMapWC3->GetXaxis()->SetTitle("Number of Hits on X Axis");
//     fHitHeatMapWC4->GetXaxis()->SetTitle("Number of Hits on X Axis");
//     fHitHeatMapWC1->GetYaxis()->SetTitle("Number of Hits on Y Axis");
//     fHitHeatMapWC2->GetYaxis()->SetTitle("Number of Hits on Y Axis");
//     fHitHeatMapWC3->GetYaxis()->SetTitle("Number of Hits on Y Axis");
//     fHitHeatMapWC4->GetYaxis()->SetTitle("Number of Hits on Y Axis");
//     fHitErrorWC1 = tfs->make<TH1F>("WC1 Orphan Hits", "Hits in X axis - Hits in Y axis in WC1", 14,-7.5,6.5);
//     fHitErrorWC2 = tfs->make<TH1F>("WC2 Orphan Hits", "Hits in X axis - Hits in Y axis in WC2", 14,-7.5,6.5);
//     fHitErrorWC3 = tfs->make<TH1F>("WC3 Orphan Hits", "Hits in X axis - Hits in Y axis in WC3", 14,-7.5,6.5);
//     fHitErrorWC4 = tfs->make<TH1F>("WC4 Orphan Hits", "Hits in X axis - Hits in Y axis in WC4", 14,-7.5,6.5);
//     fHitErrorWC1->GetXaxis()->SetTitle("Hit difference");
//     fHitErrorWC2->GetXaxis()->SetTitle("Hit difference");
//     fHitErrorWC3->GetXaxis()->SetTitle("Hit difference");
//     fHitErrorWC4->GetXaxis()->SetTitle("Hit difference");
//     fXWireWC1 = tfs->make<TH1F>("WC1 XWire Hits", "WC1 X Wire for Good Hits", 128,-64,64);
//     fXWireWC2 = tfs->make<TH1F>("WC2 XWire Hits", "WC2 X Wire for Good Hits", 128,-64,64); 
//     fXWireWC3 = tfs->make<TH1F>("WC3 XWire Hits", "WC3 X Wire for Good Hits", 128,-64,64); 
//     fXWireWC4 = tfs->make<TH1F>("WC4 XWire Hits", "WC4 X Wire for Good Hits", 128,-64,64); 
//     fYWireWC1 = tfs->make<TH1F>("WC1 YWire Hits", "WC1 Y Wire for Good Hits", 128,-64,64); 
//     fYWireWC2 = tfs->make<TH1F>("WC2 YWire Hits", "WC2 Y Wire for Good Hits", 128,-64,64); 
//     fYWireWC3 = tfs->make<TH1F>("WC3 YWire Hits", "WC3 Y Wire for Good Hits", 128,-64,64); 
//     fYWireWC4 = tfs->make<TH1F>("WC4 YWire Hits", "WC4 Y Wire for Good Hits", 128,-64,64);
//     fXWireWC1->GetXaxis()->SetTitle("wire #");
//     fXWireWC2->GetXaxis()->SetTitle("wire #");
//     fXWireWC3->GetXaxis()->SetTitle("wire #");
//     fXWireWC4->GetXaxis()->SetTitle("wire #");
//     fYWireWC1->GetXaxis()->SetTitle("wire #");
//     fYWireWC2->GetXaxis()->SetTitle("wire #");
//     fYWireWC3->GetXaxis()->SetTitle("wire #");
//     fYWireWC4->GetXaxis()->SetTitle("wire #");
//     fBfield = tfs->make<TH1F>("B Field", "B Field", 40,0,.40);
//     fTargetXY=tfs->make<TH2F>("XY Projection of Target from US WC","XY Projection of Target from US WC", 10000,-5000,5000,400,-200,200);
//     fPickyTracksTargetXY=tfs->make<TH2F>("XY Projection of Target from US WC for Picky Tracks","XY Projection of Target from US WC for Picky Tracks", 500,800,1300,200,-100,100);
//     
//     for(size_t iter=0; iter<8; ++iter){
//     fWireHitsGoodTracks.push_back(tfs->make<TH1F>());
//     fWCMult.push_back(tfs->make<TH2F>());
//     fWireHitsTheTrack.push_back(tfs->make<TH1F>());
//     fBadTrackHits.push_back(tfs->make<TH1F>());
//     }
//     
//     for(size_t iter=0; iter<4; ++iter){
//     fTimingXY.push_back(tfs->make<TH2F>());
//     }
//     fTimingXY[0] = tfs->make<TH2F>("WC 1 Picky tracks timing","WC1 Picky Tracks Timing", 1000,0,1000,1000,0,1000);
//     fTimingXY[1] = tfs->make<TH2F>("WC 2 Picky tracks timing","WC2 Picky Tracks Timing", 1000,0,1000,1000,0,1000);
//     fTimingXY[2] = tfs->make<TH2F>("WC 3 Picky tracks timing","WC3 Picky Tracks Timing", 1000,0,1000,1000,0,1000);
//     fTimingXY[3] = tfs->make<TH2F>("WC 4 Picky tracks timing","WC4 Picky Tracks Timing", 1000,0,1000,1000,0,1000);
//     
//     for(size_t iter=0; iter<3; ++iter){
//     fRegressionPlots.push_back(tfs->make<TH2F>());
//     fRegressionPlots1D.push_back(tfs->make<TH1F>());
//     }
//     for(size_t iter=0; iter<12; ++iter){    
//     fRecoplots.push_back(tfs->make<TH2F>());
//     }
//     fRecoplots[0] = tfs->make<TH2F>("ALL (4ptmom-skip second)/skip second vs skip second","ALL (4ptmom-skip second)/skip second versus skip second",200,0,2000,400,-2,2);
//     fRecoplots[1] = tfs->make<TH2F>("ALL (4ptmom-skip third)/skip third vs skip third","(4ptmom-skip third)/skip third versus skip third",200,0,2000,400,-2,2);
//     fRecoplots[2] = tfs->make<TH2F>("60 A (4ptmom-skip second)/skip second vs skip second","(4ptmom-skip second)/skip second versus skip second",200,0,2000,400,-2,2);
//     fRecoplots[3] = tfs->make<TH2F>("60 A (4ptmom-skip third)/skip third vs skip third","(4ptmom-skip third)/skip third versus skip third",200,0,2000,400,-2,2);
//     fRecoplots[4] = tfs->make<TH2F>("100 A (4ptmom-skip second)/skip second vs skip second","ALL (4ptmom-skip second)/skip second versus skip second",200,0,2000,400,-2,2);
//     fRecoplots[5] = tfs->make<TH2F>("100 A (4ptmom-skip third)/skip third vs skip third","(4ptmom-skip third)/skip third versus skip third",200,0,2000,400,-2,2);
//     fRecoplots[6] = tfs->make<TH2F>("ALL  4pt mom vs S2 momentum", "ALL  4pt mom vs S2 momentum", 2000,0,2000,2000,0,2000);
//     fRecoplots[7] = tfs->make<TH2F>("ALL  4pt mom vs S3 momentum", "ALL  4pt mom vs S3 momentum", 2000,0,2000,2000,0,2000);
  //   fRecoplots[8] = tfs->make<TH2F>("60 A  4pt mom vs S2 momentum", "ALL  4pt mom vs S2 momentum", 2000,0,2000,2000,0,2000);
    // fRecoplots[9] = tfs->make<TH2F>("60 A  4pt mom vs S3 momentum", "ALL  4pt mom vs S3 momentum", 2000,0,2000,2000,0,2000);
 //    fRecoplots[10] = tfs->make<TH2F>("100 A  4pt mom vs S2 momentum", "ALL  4pt mom vs S2 momentum", 2000,0,2000,2000,0,2000);
 //    fRecoplots[11] = tfs->make<TH2F>("100A  4pt mom vs S3 momentum", "ALL  4pt mom vs S3 momentum", 2000,0,2000,2000,0,2000);            
//     fRecoplots[0]->GetXaxis()->SetTitle("Skipping Second momentum (MeV)");
//     fRecoplots[1]->GetXaxis()->SetTitle("Skipping Third momentum (MeV)");    
//     fRecoplots[2]->GetXaxis()->SetTitle("Skipping Second momentum (MeV)");
//     fRecoplots[3]->GetXaxis()->SetTitle("Skipping Third momentum (MeV)");    
//     fRecoplots[4]->GetXaxis()->SetTitle("Skipping Second momentum (MeV)");
//     fRecoplots[5]->GetXaxis()->SetTitle("Skipping Third momentum (MeV)"); 
//     fRecoplots[6]->GetXaxis()->SetTitle("4 point momentum (MeV)");   
//     fRecoplots[7]->GetXaxis()->SetTitle("4 point momentum (MeV)");  
 //    fRecoplots[8]->GetXaxis()->SetTitle("4 point momentum (MeV)");  
//     fRecoplots[9]->GetXaxis()->SetTitle("4 point momentum (MeV)");  
//     fRecoplots[10]->GetXaxis()->SetTitle("4 point momentum (MeV)");  
//     fRecoplots[11]->GetXaxis()->SetTitle("4 point momentum (MeV)"); 
//                            
//     fRecoplots[0]->GetYaxis()->SetTitle("(4pt-S2)/S2");
//     fRecoplots[1]->GetYaxis()->SetTitle("(4pt-S3)/S3");  
//     fRecoplots[2]->GetYaxis()->SetTitle("(4pt-S2)/S2");  
//     fRecoplots[3]->GetYaxis()->SetTitle("(4pt-S3)/S3");  
//     fRecoplots[4]->GetYaxis()->SetTitle("(4pt-S2)/S2");  
//     fRecoplots[5]->GetYaxis()->SetTitle("(4pt-S3)/S3");   
//     fRecoplots[6]->GetYaxis()->SetTitle("Skipping Second momentum (MeV)");
//     fRecoplots[7]->GetYaxis()->SetTitle("Skipping Third momentum (MeV)");    
//     fRecoplots[8]->GetYaxis()->SetTitle("Skipping Second momentum (MeV)");
//     fRecoplots[9]->GetYaxis()->SetTitle("Skipping Third momentum (MeV)");    
//     fRecoplots[10]->GetYaxis()->SetTitle("Skipping Second momentum (MeV)");
//     fRecoplots[11]->GetYaxis()->SetTitle("Skipping Third momentum (MeV)");      
//     fRegressionPlots[0]= tfs->make<TH2F>("Regression no 2", "4 point regression vs 3 point, skipping WC2", 150,0,150,150,0,150);
//     fRegressionPlots[1]= tfs->make<TH2F>("Regression no 3", "4 point regression vs 3 point, skipping WC3", 150,0,150,150,0,150);
//     fRegressionPlots[2]= tfs->make<TH2F>("Regression no 3 vs no 2", "Three Point No WC3 vs Three Point No WC2", 150,0,150,150,0,150);
//     fRegressionPlots1D[0] = tfs->make<TH1F>("4Pt-S2", "4Pt-S2", 300,-150,150);
//     fRegressionPlots1D[1] = tfs->make<TH1F>("4Pt-S3", "4Pt-S3", 300,-150,150);
//     fRegressionPlots1D[2] = tfs->make<TH1F>("S3-S2", "S3-S2", 300,-150,150);
//     fWireHitsGoodTracks[0] = tfs->make<TH1F>("WC1 X Wire Hits for Good Tracks", "WC1 X Wire Hits for Good Tracks", 128,-64,64);
//     fWireHitsGoodTracks[1] = tfs->make<TH1F>("WC1 Y Wire Hits for Good Tracks", "WC1 Y Wire Hits for Good Tracks", 128,-64,64);
//     fWireHitsGoodTracks[2] = tfs->make<TH1F>("WC2 X Wire Hits for Good Tracks", "WC2 X Wire Hits for Good Tracks", 128,-64,64);
//     fWireHitsGoodTracks[3] = tfs->make<TH1F>("WC2 Y Wire Hits for Good Tracks", "WC2 Y Wire Hits for Good Tracks", 128,-64,64);
//     fWireHitsGoodTracks[4] = tfs->make<TH1F>("WC3 X Wire Hits for Good Tracks", "WC3 X Wire Hits for Good Tracks", 128,-64,64);
//     fWireHitsGoodTracks[5] = tfs->make<TH1F>("WC3 Y Wire Hits for Good Tracks", "WC3 Y Wire Hits for Good Tracks", 128,-64,64);
//     fWireHitsGoodTracks[6] = tfs->make<TH1F>("WC4 X Wire Hits for Good Tracks", "WC4 X Wire Hits for Good Tracks", 128,-64,64);
//     fWireHitsGoodTracks[7] = tfs->make<TH1F>("WC4 Y Wire Hits for Good Tracks", "WC4 Y Wire Hits for Good Tracks", 128,-64,64);
//     fWireHitsGoodTracks[0]->GetXaxis()->SetTitle("wire #");
//     fWireHitsGoodTracks[1]->GetXaxis()->SetTitle("wire #");
//     fWireHitsGoodTracks[2]->GetXaxis()->SetTitle("wire #");
//     fWireHitsGoodTracks[3]->GetXaxis()->SetTitle("wire #");
//     fWireHitsGoodTracks[4]->GetXaxis()->SetTitle("wire #");
//     fWireHitsGoodTracks[5]->GetXaxis()->SetTitle("wire #");
//     fWireHitsGoodTracks[6]->GetXaxis()->SetTitle("wire #");
//     fWireHitsGoodTracks[7]->GetXaxis()->SetTitle("wire #");
//     fBadTrackHits[0]=tfs->make<TH1F>("WC1X Bad Track Hits","WC1X Wire Hits for Tracks Not Used", 128,-64,64);
//     fBadTrackHits[1]=tfs->make<TH1F>("WC1Y Bad Track Hits","WC1Y Wire Hits for Tracks Not Used", 128,-64,64);
//     fBadTrackHits[2]=tfs->make<TH1F>("WC2X Bad Track Hits","WC2X Wire Hits for Tracks Not Used", 128,-64,64);
//     fBadTrackHits[3]=tfs->make<TH1F>("WC2Y Bad Track Hits","WC2Y Wire Hits for Tracks Not Used", 128,-64,64);
//     fBadTrackHits[4]=tfs->make<TH1F>("WC3X Bad Track Hits","WC3X Wire Hits for Tracks Not Used", 128,-64,64);
//     fBadTrackHits[5]=tfs->make<TH1F>("WC3Y Bad Track Hits","WC3Y Wire Hits for Tracks Not Used", 128,-64,64);
//     fBadTrackHits[6]=tfs->make<TH1F>("WC4X Bad Track Hits","WC4X Wire Hits for Tracks Not Used", 128,-64,64);
//     fBadTrackHits[7]=tfs->make<TH1F>("WC4Y Bad Track Hits","WC4Y Wire Hits for Tracks Not Used", 128,-64,64);
//     fBadTrackHits[0]->GetXaxis()->SetTitle("wire #");
//     fBadTrackHits[1]->GetXaxis()->SetTitle("wire #");
//     fBadTrackHits[2]->GetXaxis()->SetTitle("wire #");
//     fBadTrackHits[3]->GetXaxis()->SetTitle("wire #");
//     fBadTrackHits[4]->GetXaxis()->SetTitle("wire #");
//     fBadTrackHits[5]->GetXaxis()->SetTitle("wire #");
//     fBadTrackHits[6]->GetXaxis()->SetTitle("wire #");
//     fBadTrackHits[7]->GetXaxis()->SetTitle("wire #");
//     fWCMult[0]= tfs->make<TH2F>("Wire Multiplicity for WC1X used in tracks", "Wire Multiplicity for WC1X used in tracks", 128,-64,64,50,0,50);
//     fWCMult[1]= tfs->make<TH2F>("Wire Multiplicity for WC1Y used in tracks", "Wire Multiplicity for WC1Y used in tracks", 128,-64,64,50,0,50);
//     fWCMult[2]= tfs->make<TH2F>("Wire Multiplicity for WC2X used in tracks", "Wire Multiplicity for WC2X used in tracks", 128,-64,64,50,0,50);
//     fWCMult[3]= tfs->make<TH2F>("Wire Multiplicity for WC2Y used in tracks", "Wire Multiplicity for WC2Y used in tracks", 128,-64,64,50,0,50);
//     fWCMult[4]= tfs->make<TH2F>("Wire Multiplicity for WC3X used in tracks", "Wire Multiplicity for WC3X used in tracks", 128,-64,64,50,0,50);
//     fWCMult[5]= tfs->make<TH2F>("Wire Multiplicity for WC3Y used in tracks", "Wire Multiplicity for WC3Y used in tracks", 128,-64,64,50,0,50);
//     fWCMult[6]= tfs->make<TH2F>("Wire Multiplicity for WC4X used in tracks", "Wire Multiplicity for WC4X used in tracks", 128,-64,64,50,0,50);
//     fWCMult[7]= tfs->make<TH2F>("Wire Multiplicity for WC4Y used in tracks", "Wire Multiplicity for WC4Y used in tracks", 128,-64,64,50,0,50);
//     fWCMult[0]->GetXaxis()->SetTitle("wire #");
//     fWCMult[1]->GetXaxis()->SetTitle("wire #");
//     fWCMult[2]->GetXaxis()->SetTitle("wire #");
//     fWCMult[3]->GetXaxis()->SetTitle("wire #");
//     fWCMult[4]->GetXaxis()->SetTitle("wire #");
//     fWCMult[5]->GetXaxis()->SetTitle("wire #");
//     fWCMult[6]->GetXaxis()->SetTitle("wire #");
//     fWCMult[7]->GetXaxis()->SetTitle("wire #");
//     fWCMult[0]->GetYaxis()->SetTitle("Times Wire was used to make a Track");
//     fWCMult[1]->GetYaxis()->SetTitle("Times Wire was used to make a Track");
//     fWCMult[2]->GetYaxis()->SetTitle("Times Wire was used to make a Track");
//     fWCMult[3]->GetYaxis()->SetTitle("Times Wire was used to make a Track");
//     fWCMult[4]->GetYaxis()->SetTitle("Times Wire was used to make a Track");
//     fWCMult[5]->GetYaxis()->SetTitle("Times Wire was used to make a Track");
//     fWCMult[6]->GetYaxis()->SetTitle("Times Wire was used to make a Track");
//     fWCMult[7]->GetYaxis()->SetTitle("Times Wire was used to make a Track");
//     fWireHitsTheTrack[0] = tfs->make<TH1F>("WC1 X Wire Hits for Final Tracks", "WC1 X Wire Hits for Final Tracks", 128,-64,64);
//     fWireHitsTheTrack[1] = tfs->make<TH1F>("WC1 Y Wire Hits for Final Tracks", "WC1 Y Wire Hits for Final Tracks", 128,-64,64);
//     fWireHitsTheTrack[2] = tfs->make<TH1F>("WC2 X Wire Hits for Final Tracks", "WC2 X Wire Hits for Final Tracks", 128,-64,64);
//     fWireHitsTheTrack[3] = tfs->make<TH1F>("WC2 Y Wire Hits for Final Tracks", "WC2 Y Wire Hits for Final Tracks", 128,-64,64);
//     fWireHitsTheTrack[4] = tfs->make<TH1F>("WC3 X Wire Hits for Final Tracks", "WC3 X Wire Hits for Final Tracks", 128,-64,64);
//     fWireHitsTheTrack[5] = tfs->make<TH1F>("WC3 Y Wire Hits for Final Tracks", "WC3 Y Wire Hits for Final Tracks", 128,-64,64);
//     fWireHitsTheTrack[6] = tfs->make<TH1F>("WC4 X Wire Hits for Final Tracks", "WC4 X Wire Hits for Final Tracks", 128,-64,64);
//     fWireHitsTheTrack[7] = tfs->make<TH1F>("WC4 Y Wire Hits for Final Tracks", "WC4 Y Wire Hits for Final Tracks", 128,-64,64);
//     fWireHitsTheTrack[0]->GetXaxis()->SetTitle("wire #"); 
//     fWireHitsTheTrack[1]->GetXaxis()->SetTitle("wire #");
//     fWireHitsTheTrack[2]->GetXaxis()->SetTitle("wire #");
//     fWireHitsTheTrack[3]->GetXaxis()->SetTitle("wire #");
//     fWireHitsTheTrack[4]->GetXaxis()->SetTitle("wire #");
//     fWireHitsTheTrack[5]->GetXaxis()->SetTitle("wire #");
//     fWireHitsTheTrack[6]->GetXaxis()->SetTitle("wire #");
//     fWireHitsTheTrack[7]->GetXaxis()->SetTitle("wire #");  
//Hists that should probably stay for the production run.    
    fReco_Pz = tfs->make<TH1F>("Reco_Pz","Reconstructed momentum in XZ plane", 180, 0, 1800);
    fY_Kink = tfs->make<TH1F>("Y_Kink","Angle between US/DS tracks in Y direction (degrees)",200,-10*3.1415926/180,10*3.141592654/180);
    fX_Dist = tfs->make<TH1F>("X_Dist","X distance between US/DS tracks at midplane (mm)",1200,-60,1260);
    fY_Dist = tfs->make<TH1F>("Y_Dist","Y distance between US/DS tracks at midplane (mm)",1200,-600,600);
    fZ_Dist = tfs->make<TH1F>("Z_Dist","Z distance between US/DS tracks at midplane (mm)",1200,-60,1260);
    fX_Face_Dist = tfs->make<TH1F>("X_Face","X Location of Track's TPC Entry (mm)",1600,-200,1400);
    fY_Face_Dist = tfs->make<TH1F>("Y_Face","Y Location of Track's TPC Entry (mm)",800,-400,400);
    fTheta_Dist = tfs->make<TH1F>("Theta","Track Theta (w.r.t. TPC Z axis), (radians),",400,-.4,0.4);
    fPhi_Dist = tfs->make<TH1F>("Phi","Track Phi (w.r.t. TPC X axis), (radians)",2000,-6.28318,6.28318);                   
    fReco_Pz->GetXaxis()->SetTitle("Reconstructed momentum (MeV/c)");
    fReco_Pz->GetYaxis()->SetTitle("Tracks per 10 MeV/c");
    fY_Kink->GetXaxis()->SetTitle("Reconstructed y_kink (radians)");
    fY_Kink->GetYaxis()->SetTitle("Tracks per 0.000872 radians");
    fX_Dist->GetXaxis()->SetTitle("X distance between US and DS track ends");
    fX_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fY_Dist->GetXaxis()->SetTitle("Y distance between US and DS track ends");
    fY_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fZ_Dist->GetXaxis()->SetTitle("Z distance between US and DS track ends");
    fZ_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fX_Face_Dist->GetXaxis()->SetTitle("X (mm)");
    fX_Face_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fY_Face_Dist->GetXaxis()->SetTitle("Y (mm)");
    fY_Face_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fTheta_Dist->GetXaxis()->SetTitle("Theta (radians)");
    fTheta_Dist->GetYaxis()->SetTitle("Tracks per .002 radians");
    fPhi_Dist->GetXaxis()->SetTitle("Phi (radians)");
    fPhi_Dist->GetYaxis()->SetTitle("Tracks per 0.00628 radians");
    
    fTrack_Type = tfs->make<TH1F>("TrackType","WCTrack conditions: 1=missHit,2=uniqueHits,3=lonelyHit,4=socialHits",4,0,4);
    fTrack_Type->GetYaxis()->SetTitle("# Events");
    fTrack_Type->GetXaxis()->SetTitle("Track Conditions");
}
//===============================================================================================
  void WCTrackBuildernew::convertDigitsToVectors( std::vector<raw::AuxDetDigit> the_digits_1,
						     std::vector<raw::AuxDetDigit> the_digits_2,
						     std::vector<raw::AuxDetDigit> the_digits_3,
						     std::vector<raw::AuxDetDigit> the_digits_4,
						     std::vector<int> & tdc_number_vect,
						     std::vector<float> & hit_channel_vect,
						     std::vector<float> & hit_time_bin_vect )
  {  
    //std::ofstream outfile;
    //outfile.open("rawhits100A.txt", fstream::app);
    //outfile<<"Event number: "<<evtcounter<<std::endl;	
    //int hitcounter=0;
    if (fVerbose) {  std::cout << "Digits' sizes, 1:2:3:4: " << the_digits_1.size() << ":" << the_digits_2.size() << ":"  << the_digits_3.size() << ":" << the_digits_4.size() << std::endl;}
    //Loop through digits for WC1
    for( size_t iDigit = 0; iDigit < the_digits_1.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_1.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
        if (fVerbose) { std::cout << "(TDC,channel,time): (" << int(a_digit.Channel()/fNumber_wires_per_tdc)+1 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< ")" << std::endl; }
	hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+1);
	hit_channel_vect.push_back(a_digit.Channel() % 64);
	//outfile<<"TDC: "<<int(a_digit.Channel()/fNumber_wires_per_tdc)+1<<", Wire: "<<a_digit.Channel() % 64<<", Time: "<<a_digit.ADC(iHit)<<std::endl;
	//hitcounter++;
      }
    }

    //Loop through digits for WC2
    for( size_t iDigit = 0; iDigit < the_digits_2.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_2.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
	if( a_digit.ADC(iHit) != 0 ){
	  if (fVerbose){ std::cout << "(TDC,channel,time): (" << a_digit.Channel()/fNumber_wires_per_tdc + 5 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< "), --> a_digit.Channel(): " << a_digit.Channel() << ", fNumber_wires...: " << fNumber_wires_per_tdc << std::endl;}
	  hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	  tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+5);
	  hit_channel_vect.push_back(a_digit.Channel() % 64);
	  //outfile<<"TDC: "<<int(a_digit.Channel()/fNumber_wires_per_tdc)+5<<", Wire: "<<a_digit.Channel() % 64<<", Time: "<<a_digit.ADC(iHit)<<std::endl;
	  //hitcounter++;
	}
      }
    }

    //Loop through digits for WC3
    for( size_t iDigit = 0; iDigit < the_digits_3.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_3.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
	if( a_digit.ADC(iHit) != 0 ){
	  if (fVerbose){std::cout << "(TDC,channel,time): (" << int(a_digit.Channel()/fNumber_wires_per_tdc)+9 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< ")" << std::endl;}
	  hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	  tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+9);
	  hit_channel_vect.push_back(a_digit.Channel() % 64);
	  //outfile<<"TDC: "<<int(a_digit.Channel()/fNumber_wires_per_tdc)+9<<", Wire: "<<a_digit.Channel() % 64<<", Time: "<<a_digit.ADC(iHit)<<std::endl;
	  //hitcounter++;
	}
      }
    }

    //Loop through digits for WC4
    for( size_t iDigit = 0; iDigit < the_digits_4.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_4.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
	if( a_digit.ADC(iHit) != 0 ){
	  if (fVerbose){std::cout << "(TDC,channel,time): (" << int(a_digit.Channel()/fNumber_wires_per_tdc)+13 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< ")" << std::endl;}
	  hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	  tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+13);
	  hit_channel_vect.push_back(a_digit.Channel() % 64);
	  //outfile<<"TDC: "<<int(a_digit.Channel()/fNumber_wires_per_tdc)+13<<", Wire: "<<a_digit.Channel() % 64<<", Time: "<<a_digit.ADC(iHit)<<std::endl;
	  //hitcounter++;
	}
      }
    }
   //outfile<<"Number of Hits for event: "<<hitcounter<<std::endl;
   //outfile.close();
  }

void WCTrackBuildernew::beginRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void WCTrackBuildernew::beginSubRun(art::SubRun & sr)
{
   std::cout<<"Module B: "<<fWCTrackBuilderAlg.fMCMagneticField<<std::endl;
    // If the field override is not set, get the actual magnetic field value for the alg
    if( fWCTrackBuilderAlg.fMCMagneticField == 0 ){ 
    	fWCTrackBuilderAlg.loadXMLDatabaseTableForBField( sr.run(), sr.subRun() );}
}

void WCTrackBuildernew::endJob()
{
  // Implementation of optional member function here.
}

// void WCTrackBuildernew::endRun(art::Run & r)
// {
//   // Implementation of optional member function here.
// }
// 
// void WCTrackBuildernew::endSubRun(art::SubRun & sr)
// {
//   // Implementation of optional member function here.
// }

void WCTrackBuildernew::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
    fNumber_wire_chambers = p.get<int>("NWC"); //4;  
    fNumber_wires_per_tdc = p.get<int>("NWperTDC"); //64;
    fVerbose = p.get<bool>("Verbose", false);
    fSlicerSourceLabel = p.get<std::string>("SourceLabel");
    std::cout<<"Label WC: "<<fSlicerSourceLabel<<std::endl;
    fPickyTracks=p.get<bool>("PickyTracks");
    fHighYield=p.get<bool>("HighYield");
    fCheckTracks=p.get<bool>("CheckTracks");
    offset = p.get<float>("BFieldOffset");


}
// 
// void WCTrackBuildernew::respondToCloseInputFile(art::FileBlock const & fb)
// {
//   // Implementation of optional member function here.
// }
// 
// void WCTrackBuildernew::respondToCloseOutputFiles(art::FileBlock const & fb)
// {
//   // Implementation of optional member function here.
// }
// 
// void WCTrackBuildernew::respondToOpenInputFile(art::FileBlock const & fb)
// {
//   // Implementation of optional member function here.
// }
// 
// void WCTrackBuilder::respondToOpenOutputFiles(art::FileBlock const & fb)
// {
//   // Implementation of optional member function here.
// }

DEFINE_ART_MODULE(WCTrackBuildernew)
}//end namespace
#endif //WCTrackBuildernew_H
