////////////////////////////////////////////////////////////////////////
// Class:       WCTrackBuilder
// Module Type: producer
// File:        WCTrackBuilder_module.cc
//
// Generated at Fri Oct 16 14:58:18 2015 by Greg Pulliam using artmod
// from cetpkgsupport v1_08_06.
////////////////////////////////////////////////////////////////////////

#ifndef WCTRACKBUILDERSLICING_H
#define WCTRACKBUILDERSLICING_H

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include <iostream>
#include <fstream>
#include <vector>
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "Utilities/AssociationUtil.h"
#include "art/Framework/Services/Optional/TFileService.h"

//ROOT Things
#include <TH1F.h>

//LArIAT Things
#include "RawDataUtilities/TriggerDigitUtility.h"
#include "LArIATRecoAlg/WCTrackBuilderAlg.h"
#include "LArIATDataProducts/WCTrack.h"
#include "Utilities/DatabaseUtilityT1034.h"

#include <memory>
#include <utility>
#include <string>

namespace wct{
class WCTrackBuilder;

class WCTrackBuilder : public art::EDProducer {
public:
  explicit WCTrackBuilder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  WCTrackBuilder(WCTrackBuilder const &) = delete;
  WCTrackBuilder(WCTrackBuilder &&) = delete;
  WCTrackBuilder & operator = (WCTrackBuilder const &) = delete;
  WCTrackBuilder & operator = (WCTrackBuilder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run & r) override;
  void beginSubRun(art::SubRun & sr) override;
//  void endJob() override;
//  void endRun(art::Run & r) override;
//  void endSubRun(art::SubRun & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
//  void respondToCloseInputFile(art::FileBlock const & fb) override;
//  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
//  void respondToOpenInputFile(art::FileBlock const & fb) override;
//  void respondToOpenOutputFiles(art::FileBlock const & fb) override;
  void convertDigitsToVectors( std::vector<raw::AuxDetDigit> the_digits_1,
			       std::vector<raw::AuxDetDigit> the_digits_2,
			       std::vector<raw::AuxDetDigit> the_digits_3,
			       std::vector<raw::AuxDetDigit> the_digits_4,
			       std::vector<int> & tdc_number_vect,
			       std::vector<float> & hit_channel_vect,
			       std::vector<float> & hit_time_bin_vect );

  void createAuxDetStyleVectorsFromHitLists(WCHitList final_track,
					    std::vector<int> & WC_vect,
					    std::vector<float> & hit_wire_vect,
					    std::vector<float> & hit_time_vect);
  void plotTheTrackInformation( std::vector<double> reco_pz_list,
				std::vector<double> y_kink_list,
				std::vector<double> x_dist_list,
				std::vector<double> y_dist_list,
				std::vector<double> z_dist_list,
				std::vector<double> x_face_list,
				std::vector<double> y_face_list,
				std::vector<double> theta_list,
				std::vector<double> phi_list );
private:

  // Declare member data here.

    //Algorithm object for track building
    WCTrackBuilderAlg fWCTrackBuilderAlg;
    std::string       fSlicerSourceLabel;
    //WCHitFilterAlg    fWCHitFilterAlg;

    //Hardware constants
    int fNumber_wire_chambers;
    int fNumber_wires_per_tdc;

    //Histograms for plotting
    TH1F* fReco_Pz;
    TH1F* fY_Kink;
    TH1F* fX_Dist;
    TH1F* fY_Dist;
    TH1F* fZ_Dist;
    TH1F* fX_Face_Dist;
    TH1F* fY_Face_Dist;
    TH1F* fTheta_Dist;
    TH1F* fPhi_Dist;
    TH1F* fTrack_Type;

 
    //Misc
    bool fVerbose;
};


WCTrackBuilder::WCTrackBuilder(fhicl::ParameterSet const & p) :fWCTrackBuilderAlg(p.get< fhicl::ParameterSet > ("WCTrackBuilderAlg"))
// :
// Initialize member data here.
{
  // Call appropriate produces<>() functions here.
      this->reconfigure(p);

    // Call appropriate produces<>() functions here.  
    produces<std::vector<ldp::WCTrack> >();
}

void WCTrackBuilder::produce(art::Event & e)
{
  // Implementation of required member function here.
    //Creating the WCTrack Collection
    std::unique_ptr<std::vector<ldp::WCTrack> > WCTrackCol(new std::vector<ldp::WCTrack> );  

    //Retrieving the digits from the sliced event
    art::Handle< std::vector<raw::AuxDetDigit> > AuxDetDigitHandle;
    e.getByLabel(fSlicerSourceLabel,AuxDetDigitHandle);
    
    //Loop through the auxdetdigits and collect those that are from the WCs
    std::vector<raw::AuxDetDigit> WC1Digits;
    std::vector<raw::AuxDetDigit> WC2Digits;
    std::vector<raw::AuxDetDigit> WC3Digits;
    std::vector<raw::AuxDetDigit> WC4Digits;
    for( size_t iDig = 0; iDig < AuxDetDigitHandle->size(); ++iDig ){
      if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC1" )
	WC1Digits.push_back(AuxDetDigitHandle->at(iDig));
      if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC2" )
	WC2Digits.push_back(AuxDetDigitHandle->at(iDig));
      if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC3" )
	WC3Digits.push_back(AuxDetDigitHandle->at(iDig));
      if( AuxDetDigitHandle->at(iDig).AuxDetName() == "MWPC4" )
	WC4Digits.push_back(AuxDetDigitHandle->at(iDig));
    }  
    std::vector<int> tdc_number_vect;
    std::vector<float> hit_channel_vect;
    std::vector<float> hit_time_bin_vect;
    convertDigitsToVectors( WC1Digits,
			    WC2Digits,
			    WC3Digits,
			    WC4Digits,
			    tdc_number_vect,
			    hit_channel_vect,
			    hit_time_bin_vect );   
			    
    //int track_count=0;			    
    std::vector<double> reco_pz_list;                  //Final reco pz result for full_track_info = true, not indexed by trigger
    std::vector<double> y_kink_list;
    std::vector<double> x_dist_list;
    std::vector<double> y_dist_list;
    std::vector<double> z_dist_list;
    std::vector<double> x_face_list;
    std::vector<double> y_face_list;
    std::vector<double> theta_list;
    std::vector<double> phi_list;
    std::vector<WCHitList> final_tracks;  
    std::vector<std::vector<WCHitList> > good_hits; //Two vectors: WC#, axis. - Will be cleared for each trigger 
    //Initializing the good hit arrays to a default state - these clear for every trigger
    //Have 2-dimensional array of hitlists:
    //1st Dim: WC
    //2nd Dim: Axis    
    WCHitList hitList;
    std::vector<WCHitList> hitListAxis;
    for( int iAx = 0; iAx < 2; ++iAx ){ hitListAxis.push_back(hitList); }
    for( int iWC = 0; iWC < fNumber_wire_chambers; ++iWC ){ good_hits.push_back(hitListAxis); }
    //int good_trigger_counter = 0;
    //int track_count_pre = track_count;
}

void WCTrackBuilder::beginJob()
{
  // Implementation of optional member function here.
      // Implementation of optional member function here.
    art::ServiceHandle<art::TFileService> tfs;
    fReco_Pz = tfs->make<TH1F>("Reco_Pz","Reconstructed momentum in XZ plane", 180, 0, 1800);
    fY_Kink = tfs->make<TH1F>("Y_Kink","Angle between US/DS tracks in Y direction (degrees)",100,-5*3.1415926/180,5*3.141592654/180);
    fX_Dist = tfs->make<TH1F>("X_Dist","X distance between US/DS tracks at midplane (mm)",120,-60,60);
    fY_Dist = tfs->make<TH1F>("Y_Dist","Y distance between US/DS tracks at midplane (mm)",120,-60,60);
    fZ_Dist = tfs->make<TH1F>("Z_Dist","Z distance between US/DS tracks at midplane (mm)",120,-60,60);
    fX_Face_Dist = tfs->make<TH1F>("X_Face","X Location of Track's TPC Entry (mm)",800,-200,600);
    fY_Face_Dist = tfs->make<TH1F>("Y_Face","Y Location of Track's TPC Entry (mm)",800,-400,400);
    fTheta_Dist = tfs->make<TH1F>("Theta","Track Theta (w.r.t. TPC Z axis), (radians),",100,0,0.2);
    fPhi_Dist = tfs->make<TH1F>("Phi","Track Phi (w.r.t. TPC X axis), (radians)",100,0,6.28318);

    
    fReco_Pz->GetXaxis()->SetTitle("Reconstructed momentum (MeV/c)");
    fReco_Pz->GetYaxis()->SetTitle("Tracks per 10 MeV/c");
    fY_Kink->GetXaxis()->SetTitle("Reconstructed y_kink (radians)");
    fY_Kink->GetYaxis()->SetTitle("Tracks per 0.000872 radians");
    fX_Dist->GetXaxis()->SetTitle("X distance between US and DS track ends");
    fX_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fY_Dist->GetXaxis()->SetTitle("Y distance between US and DS track ends");
    fY_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fZ_Dist->GetXaxis()->SetTitle("Z distance between US and DS track ends");
    fZ_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fX_Face_Dist->GetXaxis()->SetTitle("X (mm)");
    fX_Face_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fY_Face_Dist->GetXaxis()->SetTitle("Y (mm)");
    fY_Face_Dist->GetYaxis()->SetTitle("Tracks per 1 mm");
    fTheta_Dist->GetXaxis()->SetTitle("Theta (radians)");
    fTheta_Dist->GetYaxis()->SetTitle("Tracks per .002 radians");
    fPhi_Dist->GetXaxis()->SetTitle("Phi (radians)");
    fPhi_Dist->GetYaxis()->SetTitle("Tracks per 0.0628 radians");

    fTrack_Type = tfs->make<TH1F>("TrackType","WCTrack conditions: 1=missHit,2=uniqueHits,3=lonelyHit,4=socialHits",4,0,4);
    fTrack_Type->GetYaxis()->SetTitle("# Events");
    fTrack_Type->GetXaxis()->SetTitle("Track Conditions");
}
//===============================================================================================
  void WCTrackBuilder::convertDigitsToVectors( std::vector<raw::AuxDetDigit> the_digits_1,
						     std::vector<raw::AuxDetDigit> the_digits_2,
						     std::vector<raw::AuxDetDigit> the_digits_3,
						     std::vector<raw::AuxDetDigit> the_digits_4,
						     std::vector<int> & tdc_number_vect,
						     std::vector<float> & hit_channel_vect,
						     std::vector<float> & hit_time_bin_vect )
  {  
    if (fVerbose) {  std::cout << "Digits' sizes, 1:2:3:4: " << the_digits_1.size() << ":" << the_digits_2.size() << ":"  << the_digits_3.size() << ":" << the_digits_4.size() << std::endl;}
    
    //Loop through digits for WC1
    for( size_t iDigit = 0; iDigit < the_digits_1.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_1.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
        if (fVerbose) { std::cout << "(TDC,channel,time): (" << int(a_digit.Channel()/fNumber_wires_per_tdc)+1 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< ")" << std::endl; }
	hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+1);
	hit_channel_vect.push_back(a_digit.Channel() % 64);
      }
    }

    //Loop through digits for WC2
    for( size_t iDigit = 0; iDigit < the_digits_2.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_2.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
	if( a_digit.ADC(iHit) != 0 ){
	  if (fVerbose){ std::cout << "(TDC,channel,time): (" << a_digit.Channel()/fNumber_wires_per_tdc + 5 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< "), --> a_digit.Channel(): " << a_digit.Channel() << ", fNumber_wires...: " << fNumber_wires_per_tdc << std::endl;}
	  hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	  tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+5);
	  hit_channel_vect.push_back(a_digit.Channel() % 64);
	}
      }
    }

    //Loop through digits for WC3
    for( size_t iDigit = 0; iDigit < the_digits_3.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_3.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
	if( a_digit.ADC(iHit) != 0 ){
	  if (fVerbose){std::cout << "(TDC,channel,time): (" << int(a_digit.Channel()/fNumber_wires_per_tdc)+9 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< ")" << std::endl;}
	  hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	  tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+9);
	  hit_channel_vect.push_back(a_digit.Channel() % 64);
	}
      }
    }

    //Loop through digits for WC4
    for( size_t iDigit = 0; iDigit < the_digits_4.size() ; ++iDigit ){
      raw::AuxDetDigit a_digit = (the_digits_4.at(iDigit));
      for( size_t iHit = 0; iHit < a_digit.NADC() ; ++iHit ){
	if( a_digit.ADC(iHit) != 0 ){
	  if (fVerbose){std::cout << "(TDC,channel,time): (" << int(a_digit.Channel()/fNumber_wires_per_tdc)+13 << "," << a_digit.Channel() % 64 << "," << a_digit.ADC(iHit)<< ")" << std::endl;}
	  hit_time_bin_vect.push_back(a_digit.ADC(iHit));
	  tdc_number_vect.push_back(int(a_digit.Channel()/fNumber_wires_per_tdc)+13);
	  hit_channel_vect.push_back(a_digit.Channel() % 64);
	}
      }
    }
  }

void WCTrackBuilder::beginRun(art::Run & r)
{
  // Implementation of optional member function here.
}

void WCTrackBuilder::beginSubRun(art::SubRun & sr)
{
  // Implementation of optional member function here.
}

//void WCTrackBuilder::endJob()
//{
  // Implementation of optional member function here.
//}

// void WCTrackBuilder::endRun(art::Run & r)
// {
//   // Implementation of optional member function here.
// }
// 
// void WCTrackBuilder::endSubRun(art::SubRun & sr)
// {
//   // Implementation of optional member function here.
// }

void WCTrackBuilder::reconfigure(fhicl::ParameterSet const & p)
{
  // Implementation of optional member function here.
      fNumber_wire_chambers = p.get<int>("NWC"); //4;  
    fNumber_wires_per_tdc = p.get<int>("NWperTDC"); //64;
    fVerbose = p.get<bool>("Verbose", false);
    fSlicerSourceLabel = p.get<std::string>("SourceLabel");
}
// 
// void WCTrackBuilder::respondToCloseInputFile(art::FileBlock const & fb)
// {
//   // Implementation of optional member function here.
// }
// 
// void WCTrackBuilder::respondToCloseOutputFiles(art::FileBlock const & fb)
// {
//   // Implementation of optional member function here.
// }
// 
// void WCTrackBuilder::respondToOpenInputFile(art::FileBlock const & fb)
// {
//   // Implementation of optional member function here.
// }
// 
// void WCTrackBuilder::respondToOpenOutputFiles(art::FileBlock const & fb)
// {
//   // Implementation of optional member function here.
// }

DEFINE_ART_MODULE(WCTrackBuilder)
}//end namespace
#endif //WCTRACKBUILDER_H
