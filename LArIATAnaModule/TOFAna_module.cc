////////////////////////////////////////////////////////////////////////
// Class:       TOFAna
// Module Type: analyzer
// File:        TOFAna_module.cc
//
// Generated at Thu Jul 21 14:08:38 2016 by Lucas Mendes Santos using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h" 
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"


// LArSoft Libraries
#include "lardataobj/RawData/AuxDetDigit.h"
#include "LArIATDataProducts/TOF.h"
#include "LArIATAnaModule/WaveformAnalysis.h"


//ROOT Library

#include "TF1.h"
#include "TFile.h"
#include "TTree.h"

class TOFAna;

class TOFAna : public art::EDAnalyzer {
public:
  explicit TOFAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TOFAna(TOFAna const &) = delete;
  TOFAna(TOFAna &&) = delete;
  TOFAna & operator = (TOFAna const &) = delete;
  TOFAna & operator = (TOFAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void  reconfigure(fhicl::ParameterSet const & p) override;
  void  beginJob();
  double* FittingWaveform(std::vector <short> wvform); 
  std::string fTOFModuleLabel;
  std::string fAuxDetModule;
  
private:

  // Declare member data here.

  double paramu0[4];
  double paramu1[4];
  double paramd0[4];
  double paramd1[4];
  
  double chi2normu0;
  double chi2normu1;
  double chi2normd0;
  double chi2normd1;

  double pareau0;
  double pareau1;
  double paread0;
  double paread1;
  
  TTree *fTree;

};


TOFAna::TOFAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{

 this->reconfigure(p);

}


void TOFAna::reconfigure(fhicl::ParameterSet const & p)
{
  fTOFModuleLabel = p.get<std::string>("TOF", "tof");
  fAuxDetModule = p.get<std::string>("DAQ", "daq");
}

void  TOFAna::beginJob()
{

  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("tofana","TOF Ana");
  fTree->Branch("wvparamu0", &paramu0, "wvparamu0[4]/D");
  fTree->Branch("chi2normu0", &chi2normu0,"chi2normu0/D");
  fTree->Branch("wvparamu1", &paramu1, "wvparamu1[4]/D");
  fTree->Branch("chi2normu1", &chi2normu1,"chi2normu1/D");
  fTree->Branch("wvparamd0", &paramd0, "wvparamd0[4]/D");
  fTree->Branch("chi2normd0", &chi2normd0,"chi2normd0/D");
  fTree->Branch("wvparamd1", &paramd1, "wvparamd1[4]/D");
  fTree->Branch("chi2normd1", &chi2normd1,"chi2normd1/D");
   
  

}


void TOFAna::analyze(art::Event const & e)
{
  // Implementation of required member function here.

  
  art::Handle< std::vector<raw::AuxDetDigit> > AuxDetDigitHandle;	
  e.getByLabel(fAuxDetModule,AuxDetDigitHandle);

  art::Handle< std::vector<ldp::TOF> > tofHandle;	
  e.getByLabel(fTOFModuleLabel,tofHandle);



  std::vector<const raw::AuxDetDigit*> USTOF;
  std::vector<const raw::AuxDetDigit*> DSTOF;

  std::vector<short> usdet0;
  std::vector<short> usdet1;
  std::vector<short> dsdet0;
  std::vector<short> dsdet1;

  double* fitting;
 
if(tofHandle->size() > 0 && tofHandle->at(0).NTOF() > 0){
   
       for( size_t iDig = 0; iDig < AuxDetDigitHandle->size() ; ++iDig ){

         if( AuxDetDigitHandle->at(iDig).AuxDetName() == "TOFUS" ) USTOF.push_back(&(AuxDetDigitHandle->at(iDig)));
	
         if( AuxDetDigitHandle->at(iDig).AuxDetName() == "TOFDS" ) DSTOF.push_back(&(AuxDetDigitHandle->at(iDig)));
      }
           for(size_t iADC = 0; iADC < USTOF.at(0)->NADC(); ++iADC)
  	   {
              usdet0.push_back(USTOF.at(0)->ADC(iADC));
           }

           std::cout<<*std::min_element(usdet0.begin(),usdet0.end())<<std::endl;
           fitting = FittingWaveform(usdet0);
 	   if(fitting){
           for(int i =0; i < 3; i++)
	   {
		paramu0[i] = *(fitting+i);

           }

           chi2normu0 = *(fitting+4);}
           
           
           for(size_t iADC = 0; iADC < USTOF.at(1)->NADC(); ++iADC)
  	   {
              usdet1.push_back(USTOF.at(1)->ADC(iADC));
           }

           fitting = FittingWaveform(usdet1);

           if(fitting){
           for(int i =0; i < 3; i++)
	   {
		paramu1[i] = *(fitting+i);

           }

           chi2normu1 = *(fitting+4);}

           for(size_t iADC = 0; iADC < DSTOF.at(0)->NADC(); ++iADC)
  	   {
              dsdet0.push_back(DSTOF.at(0)->ADC(iADC));
           }

           fitting = FittingWaveform(dsdet0);


           if(fitting){
           for(int i =0; i < 3; i++)
	   {
		paramd0[i] = *(fitting+i);

           }

           chi2normd0 = *(fitting+4);}


           
           for(size_t iADC = 0; iADC < DSTOF.at(1)->NADC(); ++iADC)
  	   {
              dsdet1.push_back(DSTOF.at(1)->ADC(iADC));
           }

           fitting = FittingWaveform(dsdet1);

           if(fitting){
           for(int i =0; i < 3; i++)
	   {
		paramd1[i] = *(fitting+i);

           }

           chi2normd1 = *(fitting+4);
           }

           fTree->Fill();
	
	   
       }	

	
}  





double* TOFAna::FittingWaveform(std::vector <short> wvform)
{

std::vector <double> peakstime;
double peak_area;
std::vector <short> peaks;
short risetime;
short decaytime;
int begin_sample, end_sample;
double* tempo;
bool found;
double* value;
double baseline, base_diff, mpv, sigma;
TGraph *gr;
double param[5];
double *fparam;

int ndf;
double chi;
TF1 *fit = new TF1("fit","[0] - [1]*TMath::Landau(x,[2],[3])", 0, 1000);

WaveformAnalysis *wv = new WaveformAnalysis();

found = wv->FindPeaks(200,wvform,100,"negative");

if(found){
		peaks = wv->GetPeaks();
		//cout<<"Peaks: "<<peaks[0]<<endl;
          
		peakstime = wv->GetPeaksTime();
                peak_area = wv->GetPulseArea(wvform,peakstime[0]);
		std::cout<<"Pulse Area "<<peak_area<<" "<<peakstime[0]/1e-9<<std::endl;
		risetime = wv->GetRiseTime();
		decaytime = wv->GetDecayTime();
                begin_sample = int(peakstime[0]/1e-9 - decaytime*5);
                end_sample =   int(peakstime[0]/1e-9 + risetime*5);

		std::vector <double> wv_sample(&wvform[begin_sample], &wvform[end_sample]);
		baseline = wv->GetBaseline();
		base_diff = baseline - peaks[0];
		//cout<<"Constant: "<<base_diff<<endl;
		mpv = peakstime[0]/1e-9;
                sigma = 2;
                tempo = new double[wv_sample.size()];
                value = new double[wv_sample.size()];
                for( int j = 0; j < (int)wv_sample.size(); j++){tempo[j] = begin_sample + j; value[j] = wv_sample[j];}
	        gr = new TGraph(wv_sample.size(), tempo, value);
                fit->SetRange((double)begin_sample, (double)end_sample);
		double par[4] = {baseline, base_diff, mpv, sigma};
		fit->SetParameters(par);
		gr->Fit("fit","QNM");
		fit->GetParameters(&param[0]);
 		chi = fit->GetChisquare();
		ndf = fit->GetNDF();
	        param[5] = chi/(double)ndf;
		
		gr->Clear();
                gr->Delete();
		wv_sample.clear();	        		
	
		fparam = param;

                
}
else{std::cout<<"Found No Peaks!!"<<std::endl; fparam = nullptr;}
return fparam;
}

DEFINE_ART_MODULE(TOFAna)
