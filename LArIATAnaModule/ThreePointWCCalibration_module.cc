////////////////////////////////////////////////////////////////////////
// Class:       ThreePointWCCalibration
// Module Type: analyzer
// File:        ThreePointWCCalibration_module.cc
//
// Generated at Tue Aug 29 12:39:36 2017 by Greg Pulliam using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h" 
#include "art/Framework/Principal/Event.h" 
#include "fhiclcpp/ParameterSet.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Principal/Handle.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Services/Registry/ServiceHandle.h" 
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "canvas/Persistency/Common/FindOneP.h" 
#include "canvas/Persistency/Common/FindManyP.h"
#include "messagefacility/MessageLogger/MessageLogger.h" 
#include "larcorealg/Geometry/AuxDetGeo.h"
#include "larcore/Geometry/Geometry.h"

//=====ROOT includes=====
#include "TTree.h"
#include <TMath.h>

//=====LArIAT includes=====
#include "LArIATDataProducts/WCTrack.h"

class ThreePointWCCalibration;

class ThreePointWCCalibration : public art::EDAnalyzer {
public:
  explicit ThreePointWCCalibration(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ThreePointWCCalibration(ThreePointWCCalibration const &) = delete;
  ThreePointWCCalibration(ThreePointWCCalibration &&) = delete;
  ThreePointWCCalibration & operator = (ThreePointWCCalibration const &) = delete;
  ThreePointWCCalibration & operator = (ThreePointWCCalibration &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  
private:
  void ResetVars();
  void Skip2Analysis(double (&hits)[4][3]);
  void Skip3Analysis(double (&hits)[4][3]);  
  double UseHitsToFindB(double (&hits)[4][3], double p);
  TTree* fTree;
  double m_mp=tan(TMath::Pi()/180*82); //Midplane: x=mz+b with m=tan(82) deg
  double b_mp=3106.57; //Midplane intercept in cm
  double L_Eff=1204; //Effective length of one magnet approx in mm
  
  double Reco_Pz;
  double Residual_4pt;
  double Residual_4pt_redo;
  double Reco_Pz_S2;
  double MissedWC;
  double Residual_S2;
  double X_tpc_face_4pt;
  double Y_tpc_face_4pt;
  double theta_tpc_face_4pt;
  double phi_tpc_face_4pt;
  double WCHitPosition[4][3];
  bool WCTrackExist;
  double slope;
  double intercept;
  double B_Field; //As this isn't saved to the event, we have to find it using the hits in the event and the momentum.
  double x_missed_WC2;
  double z_missed_WC2;
  double Scaled_us_slope;
  
 
  double Reco_Pz_S3;
  double Residual_S3;
  double x_missed_WC3;
  double z_missed_WC3;
  double Scaled_ds_slope;
  std::string fWCTrackLabel;
  double fWC2Scale; //How to scale the 3 Pt momentum to a 4 pt momentum for WC2-missed tracks
  double fWC3Scale; //Ditto for WC3-Missed Tracks
  float fX_cntr[4];
  float fY_cntr[4];
  float fZ_cntr[4];
  art::ServiceHandle<geo::Geometry> fGeo; 
};


ThreePointWCCalibration::ThreePointWCCalibration(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p) 
{
  this->reconfigure(p);
  double centerOfDet[3] = {0,0,0};
  for( size_t iDet = 0; iDet < fGeo->NAuxDets() ; ++iDet ){
    geo::AuxDetGeo const& anAuxDetGeo = fGeo->AuxDet(iDet);
    std::string detName = anAuxDetGeo.Name();
    size_t wcnum = 999;
    if( detName == "volAuxDetSensitiveWC1") wcnum = 1;
    if( detName == "volAuxDetSensitiveWC2") wcnum = 2;
    if( detName == "volAuxDetSensitiveWC3") wcnum = 3;
    if( detName == "volAuxDetSensitiveWC4") wcnum = 4;
    if( wcnum != 999 ){
      anAuxDetGeo.GetCenter(centerOfDet);
      fX_cntr[wcnum-1] = centerOfDet[0] * CLHEP::cm;
      fY_cntr[wcnum-1] = centerOfDet[1] * CLHEP::cm;
      fZ_cntr[wcnum-1] = centerOfDet[2] * CLHEP::cm;
    }
  }
}
//==========================================================================
void ThreePointWCCalibration::analyze(art::Event const & e)
{
 std::cout<<"Starting ana"<<std::endl;
  ResetVars();
  art::Handle< std::vector<ldp::WCTrack> > wctrackHandle;
  std::vector<art::Ptr<ldp::WCTrack> > wctrack;
   
  if(e.getByLabel(fWCTrackLabel, wctrackHandle))
    {art::fill_ptr_vector(wctrack, wctrackHandle);}
    
  if(wctrack.size()==0){return;}//Skip event if there is no WCTrack
   std::cout<<"WCTracksize?"<<wctrack.size()<<std::endl;
  for(size_t wct_count=0; wct_count<wctrack.size(); ++wct_count)
  {
    WCTrackExist=true;
    Reco_Pz=wctrack[wct_count]->Momentum();
    Residual_4pt=wctrack[wct_count]->Residual();
    X_tpc_face_4pt=wctrack[wct_count]->XYFace(0);
    Y_tpc_face_4pt=wctrack[wct_count]->XYFace(1);
    theta_tpc_face_4pt=wctrack[wct_count]->Theta();
    phi_tpc_face_4pt=wctrack[wct_count]->Phi();
    MissedWC=wctrack[wct_count]->WCMissed();
    for(int i=0; i<4; ++i)
    {
      for(int j=0; j<3; ++j)
      {
        WCHitPosition[i][j]=wctrack[wct_count]->HitPosition(i,j);
      } //j loop
    } //i loop
  }// wct_count loop
  B_Field = UseHitsToFindB(WCHitPosition,Reco_Pz);
  Skip2Analysis(WCHitPosition);
  Skip3Analysis(WCHitPosition);
  
  fTree->Fill();
}//analyze
//===========================================================================
double ThreePointWCCalibration::UseHitsToFindB(double (&hits)[4][3], double p)
{
  // Residual to line of best fit. 
  int Npoints=4;
  double sum_z=0;
  double sum_zz=0;
  double sum_y=0;
  double sum_yz=0;
  double residual=0;
  double residualsquare=0;
  for(int i=0;i<4;++i)
  {
    sum_y  += hits[i][1];
    sum_zz += hits[i][2]*hits[i][2];
    sum_z  += hits[i][2];
    sum_yz += hits[i][1]*hits[i][2]; 
  }
  intercept=(sum_y*sum_zz-sum_z*sum_yz)/(Npoints*sum_zz-sum_z*sum_z);
  slope=(Npoints*sum_yz-sum_z*sum_y)/(Npoints*sum_zz-sum_z*sum_z); //According to Doug Jensen, momentum needs this...only a .03% difference, at most, on Pz, given the distribution of this variable. But lets be complete.
  for(int i=0; i<4;++i){
    residual= (hits[i][1]-slope*hits[i][2]-intercept)/std::sqrt(1+slope*slope);
    residualsquare += (residual)*(residual); 
  }
  Residual_4pt_redo=pow(residualsquare,.5)/(Npoints-2); 
  double dx_ds=hits[3][0]-hits[2][0];
  double dz_ds=hits[3][2]-hits[2][2];
  double dx_us=hits[1][0]-hits[0][0];
  double dz_us=hits[1][2]-hits[0][2];
  double ds_slope=dx_ds/dz_ds;
  double us_slope=dx_us/dz_us;
  double theta_x_us=atan(us_slope);
  double theta_x_ds=atan(ds_slope);
  double B=(p*3.3*(sin(theta_x_ds)-sin(theta_x_us))*cos(atan(slope)))/L_Eff;
  return B;
   
}
//===========================================================================
void ThreePointWCCalibration::Skip2Analysis(double (&hits)[4][3])
{
 // Residual to line of best fit 
  int Npoints=3;
  double sum_z=0;
  double sum_zz=0;
  double sum_y=0;
  double sum_yz=0;
  double intercept_S2=0;
  double slope_S2=0;
  double residual=0;
  double residualsquare=0;
  for(int i=0;i<4;++i)
  {
    if(i!=1)
    {
      sum_y  += hits[i][1];
      sum_zz += hits[i][2]*hits[i][2];
      sum_z  += hits[i][2];
      sum_yz += hits[i][1]*hits[i][2]; 
    }
  }
  intercept_S2=(sum_y*sum_zz-sum_z*sum_yz)/(Npoints*sum_zz-sum_z*sum_z);
  slope_S2=(Npoints*sum_yz-sum_z*sum_y)/(Npoints*sum_zz-sum_z*sum_z);
  for(int i=0; i<4;++i){
    if(i != 1){
    residual= (hits[i][1]-slope_S2*hits[i][2]-intercept_S2)/std::sqrt(1+slope_S2*slope_S2);
    residualsquare += (residual)*(residual); 
    }
  }
  Residual_S2=pow(residualsquare,.5)/(Npoints-2);
  
  
// Calculate momentum using midplane

  double dx_ds=hits[3][0]-hits[2][0];
  double dz_ds=hits[3][2]-hits[2][2];
  double ds_slope=dx_ds/dz_ds;
  double ds_int=hits[2][0]-ds_slope*hits[2][2];
  double z_ds=(b_mp-ds_int)/(ds_slope-m_mp);
  double x_ds=ds_slope*z_ds+ds_int;
  double dx_us=x_ds-hits[0][0];
  double dz_us=z_ds-hits[0][2];
  double theta_x_us=atan(dx_us/dz_us);
  double theta_x_ds=atan(dx_ds/dz_ds);
  Reco_Pz_S2=B_Field*L_Eff/((3.3*(sin(theta_x_ds) - sin(theta_x_us)))*cos(atan(slope_S2)));
// As a check, scale the S2 momentum to a 4pt momentum and find the "missed" hit.
  
  double Scaled_Pz=Reco_Pz_S2/(1+fWC2Scale);
  Scaled_us_slope=tan(asin(sin(theta_x_ds)-(B_Field*L_Eff/(3.3*Scaled_Pz*cos(atan(slope_S2)))))); //Rearranging Momentum equation to solve for Theta_us. Take tangent of that to get us_slope
  double Scaled_us_int=hits[0][0]-Scaled_us_slope*hits[0][2]; // Using point-slope form with (x1,z1) and rearranging to slope-interecept form to get the intercept. Now have the equation of track through WC1 and WC2 in form x=mz+b
  
  //Need the equation of the line defining WC2, which requires knowing one point in the WC to use with the slope, tan(13deg). Using the REAL Hit in WC2 as that point. In the producer, this point would be the WC2 center from geometry
  double WC2_int=hits[1][0]-tan(77*TMath::Pi()/180)*hits[1][2];
  z_missed_WC2=(WC2_int-Scaled_us_int)/(Scaled_us_slope-tan(77*TMath::Pi()/180)); //Z position of hit in WC2
  x_missed_WC2=Scaled_us_slope*z_missed_WC2+Scaled_us_int;   //X position of hit in WC2.
  
  
       
}
//===========================================================================
void ThreePointWCCalibration::Skip3Analysis(double (&hits)[4][3])
{
 // Residual to line of best fit 
  int Npoints=3;
  double sum_z=0;
  double sum_zz=0;
  double sum_y=0;
  double sum_yz=0;
  double intercept_S3=0;
  double slope_S3=0;
  double residual=0;
  double residualsquare=0;
  for(int i=0;i<4;++i)
  {
    if(i!=2)
    {
      sum_y  += hits[i][1];
      sum_zz += hits[i][2]*hits[i][2];
      sum_z  += hits[i][2];
      sum_yz += hits[i][1]*hits[i][2]; 
    }
  }
  intercept_S3=(sum_y*sum_zz-sum_z*sum_yz)/(Npoints*sum_zz-sum_z*sum_z);
  slope_S3=(Npoints*sum_yz-sum_z*sum_y)/(Npoints*sum_zz-sum_z*sum_z);
  for(int i=0; i<4;++i){
    if(i != 1){
    residual= (hits[i][1]-slope_S3*hits[i][2]-intercept_S3)/std::sqrt(1+slope_S3*slope_S3);
    residualsquare += (residual)*(residual); 
    }
  }
  Residual_S3=pow(residualsquare,.5)/(Npoints-2);
  
  
// Calculate momentum using midplane

  double dx_us=hits[1][0]-hits[0][0];
  double dz_us=hits[1][2]-hits[0][2];
  double us_slope=dx_us/dz_us;
  double us_int=hits[1][0]-us_slope*hits[1][2];
  double z_us=(b_mp-us_int)/(us_slope-m_mp);
  double x_us=us_slope*z_us+us_int;
  double dx_ds=-(x_us-hits[3][0]);
  double dz_ds=-(z_us-hits[3][2]);
  double theta_x_us=atan(dx_us/dz_us);
  double theta_x_ds=atan(dx_ds/dz_ds);
  Reco_Pz_S3=B_Field*L_Eff/((3.3*(sin(theta_x_ds) - sin(theta_x_us)))*cos(atan(slope_S3)));
// As a check, scale the S2 momentum to a 4pt momentum and find the "missed" hit.
  
  double Scaled_Pz=Reco_Pz_S3/(1+fWC3Scale);
  Scaled_ds_slope=tan(asin(sin(theta_x_ds)-(B_Field*L_Eff/(3.3*Scaled_Pz*cos(atan(slope_S3)))))); //Rearranging Momentum equation to solve for Theta_us. Take tangent of that to get ds_slope
  double Scaled_ds_int=hits[3][0]-Scaled_ds_slope*hits[3][2]; // Using point-slope form with (x1,z1) and rearranging to slope-interecept form to get the intercept. Now have the equation of track through WC1 and WC2 in form x=mz+b
  
  //Need the equation of the line defining WC2, which requires knowing one point in the WC to use with the slope, tan(13deg). Using the REAL Hit in WC2 as that point. In the producer, this point would be the WC2 center from geometry
  double WC3_int=hits[2][0]-tan(87*TMath::Pi()/180)*hits[2][2];
  z_missed_WC3=(WC3_int-Scaled_ds_int)/(Scaled_ds_slope-tan(87*TMath::Pi()/180)); //Z position of hit in WC2
  x_missed_WC3=Scaled_ds_slope*z_missed_WC3+Scaled_ds_int;   //X position of hit in WC2.
  
  
       
}
//===========================================================================
void ThreePointWCCalibration::beginJob()
{
 art::ServiceHandle<art::TFileService> tfs;
 fTree = tfs->make<TTree>("WCTree","WCAnaTree");
 
 fTree->Branch("WCTrackExist",&WCTrackExist,"WCTrackExist/O");
 fTree->Branch("WCHitPosition",&WCHitPosition,"WCHitPosition[4][3]/D");
 fTree->Branch("Reco_Pz",&Reco_Pz,"Reco_Pz/D");
 fTree->Branch("Residual_4pt",&Residual_4pt,"Residual_4pt/D");
 fTree->Branch("Residual_4pt_redo",&Residual_4pt_redo,"Residual_4pt_redo/D");
 fTree->Branch("X_tpc_face_4pt",&X_tpc_face_4pt,"X_tpc_face_4pt/D");
 fTree->Branch("Y_tpc_face_4pt",&Y_tpc_face_4pt,"Y_tpc_face_4pt/D");
 fTree->Branch("Reco_Pz_S2",&Reco_Pz_S2,"Reco_Pz_S2/D");
 fTree->Branch("Residual_S2",&Residual_S2,"Residual_S2/D");
 fTree->Branch("theta_tpc_face_4pt",&theta_tpc_face_4pt,"theta_tpc_face_4pt/D");
 fTree->Branch("phi_tpc_face_4pt",&phi_tpc_face_4pt,"phi_tpc_face_4pt/D");
 fTree->Branch("slope",&slope,"slope/D");
 fTree->Branch("intercept",&intercept,"intercept/D");
 fTree->Branch("B_Field",&B_Field,"B_Field/D");
 fTree->Branch("x_missed_WC2",&x_missed_WC2,"x_missed_WC2/D");
 fTree->Branch("z_missed_WC2",&z_missed_WC2,"z_missed_WC2/D");
 fTree->Branch("Scaled_us_slope",&Scaled_us_slope,"Scaled_us_slope/D");
 fTree->Branch("MissedWC", &MissedWC,"MissedWC/D");

 fTree->Branch("Reco_Pz_S3",&Reco_Pz_S3,"Reco_Pz_S3/D");
 fTree->Branch("Residual_S3",&Residual_S3,"Residual_S3/D");
 fTree->Branch("x_missed_WC3",&x_missed_WC3,"x_missed_WC3/D");
 fTree->Branch("z_missed_WC3",&z_missed_WC3,"z_missed_WC3/D");
 fTree->Branch("Scaled_ds_slope",&Scaled_ds_slope,"Scaled_ds_slope/D");
}
//===========================================================================
void ThreePointWCCalibration::reconfigure(fhicl::ParameterSet const & p)
{
  fWCTrackLabel 		= p.get< std::string >("WCTrackLabel");
  fWC2Scale                     = p.get< double >("Miss2Scale",.108);
  fWC3Scale                     = p.get< double >("Miss3Scale",-.1);
}
//===========================================================================
void ThreePointWCCalibration::ResetVars()
{
  for(int i=0; i<4; ++i)
  {
    for(int j=0; j<3; ++j)
    {
      WCHitPosition[i][j]=-99999;
    }
  }
  WCTrackExist=false;
  Reco_Pz=-99999;
  Residual_4pt=-99999;
  Residual_4pt_redo=-99999;
  X_tpc_face_4pt=-99999;
  Y_tpc_face_4pt=-99999;
  Residual_S2=-99999;
  Residual_S3=-99999;
  theta_tpc_face_4pt=-99999;
  phi_tpc_face_4pt=-99999;
  slope=-99999;
  intercept=-99999;
  B_Field=-99999;
  Reco_Pz_S2=-99999;
  x_missed_WC2=-99999;
  z_missed_WC2=-99999;
  Scaled_us_slope=-99999;
  MissedWC=-99999;
  Reco_Pz_S3=-99999;
  Residual_S3=-99999;
  x_missed_WC3=-99999;
  z_missed_WC3=-99999;
  Scaled_ds_slope=-99999;
  
}


DEFINE_ART_MODULE(ThreePointWCCalibration)
