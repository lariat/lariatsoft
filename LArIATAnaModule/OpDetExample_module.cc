////////////////////////////////////////////////////////////////////////
// Class:       OpDetExample
// Module Type: analyzer
// File:        OpDetExample_module.cc
//
// This module provides a simple example of accessing and manipulating
// photodetector data objects.  The input file can be either digit or 
// reco-level.
//
// Generated Wed Apr 27 14:57:47 2016
// William Foreman, wforeman@uchicago.edu 
// Pawel Kryczynski, pkryczyn@fnal.gov 
////////////////////////////////////////////////////////////////////////

// Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// ROOT includes
#include <TF1.h>
#include <TH1F.h>
#include <TCanvas.h>
#include <TLine.h>

//LAriatSoft Includes
#include "LArIATRecoAlg/OpHitBuilderAlg.h"

class OpDetExample;

// -----------------------------------------------------------------------
class OpDetExample : public art::EDAnalyzer {
public:
  explicit OpDetExample(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  OpDetExample(OpDetExample const &) = delete;
  OpDetExample(OpDetExample &&) = delete;
  OpDetExample & operator = (OpDetExample const &) = delete;
  OpDetExample & operator = (OpDetExample &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:
  
  // Parameters to be read in from the fhicl script
  std::string       fDAQModuleLabel;
  std::string       fDAQModuleInstanceName;
  size_t            fOpDetChannel;
  short             fBaselineWindowSize;
  size_t            fNWaveformSamples;
  bool              fPrintWvforms;
  size_t            fMaxSavedWaveforms;
  
  // Variables
  size_t            SavedWaveformCount;
  int               eventnr;
  int               runnr;
  int               subrunnr;
  char              fHistName[50];

  // Opens up the file service used to make and save histograms
  art::ServiceHandle<art::TFileService> tfs;
  
  // Declare pointers to histograms we want (these are initialized
  // in the OpDetExample::beginJob method below)
  TH1F* h_eventTimestamps;
  TH1I* h_nOpHits;
  TH1I* h_hitTimes;
  TH1F* h_hitAmplitudes;
  TH1F* h_hitPromptLight;
  TH1F* h_AverageWaveform;
  TH1F* h_wvhist;

  // Create the algorithm object of the OpHitBuilderAlg class.
  // We'll be using functions from this class to do hit-finding
  // and integration of pulses.  Feel free to take a look at the
  // algorithms themselves for a detailed look at what's going
  // on: LArIATRecoAlg/OpHitBuilderAlg.cxx
  OpHitBuilderAlg     fOpHitBuilderAlg;

};

// -----------------------------------------------------------------------
OpDetExample::OpDetExample(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  fOpHitBuilderAlg(p)
{
  // Read in fhicl parameters
  this->reconfigure(p);

  // Set waved waveform count to 0
  SavedWaveformCount = 0;
   
}

// -----------------------------------------------------------------------
void OpDetExample::analyze(art::Event const & e)
{
  // This function will run over each event individually.  The event
  // itself is accessible as an art::Event object "e" here.
  // Let's start by saving information relevant to this event (run #, 
  // subrun #, event #) in case we need to use it at any point:
  eventnr   = e.id().event();
  runnr     = e.run();
  subrunnr  = e.subRun();
  
  // Optical data is stored by LArSoft as raw::OpDetPulse objects, which
  // can be accessed from the event the same way as most other data types.
  //
  // Define an ART handle to point to a vector of OpDetPulse objects
  // and then tell the event to fill the vector with all the objects
  // of that type.  "fDAQModuleLabel" indicates the producer that added 
  // these objects to the event in the previous stage.  This is set in
  // the fhicl file.  (You can always run eventdump.fcl on a file to 
  // check what data products it contains).
  art::Handle< std::vector< raw::OpDetPulse >> opdetHandle;
  e.getByLabel(fDAQModuleLabel, fDAQModuleInstanceName, opdetHandle);
  

  // We now have an art::Handle pointing to a vector of raw::OpDetPulse
  // objects.  We can check the size of opdetHandle to verify that this 
  // event actually contains data from the photosystem.  If empty, we use
  // 'return' to exit the function and move to next event.
  if( (size_t)opdetHandle->size() == 0 ){
    std::cout << "No optical detector data found; skipping event.\n";
    return;
  
  } else {
  
  // Otherwise, if photosystem data exists, let's loop through the vector 
  // of OpDetPulse objects stored in the handle.
    for (size_t i_pulse = 0; i_pulse < opdetHandle->size(); i_pulse ++ ){
 
      // Do some art magic to extract the raw::OpDetPulse object from
      // the handle.
      art::Ptr< raw::OpDetPulse > ThePulsePtr(opdetHandle,i_pulse); 
      raw::OpDetPulse pulse = *ThePulsePtr;

      // Each OpDetPulse object has a public member "OpChannel" which tells
      // us which photodetector it is.  For both Run 1 and 2, the ETL PMT
      // is channel "1", so this is the default for now.  You can look at
      // other detectors by changing this parameter in the fhicl.
      if( pulse.OpChannel() == fOpDetChannel ){
        
        // Great, we found data from the detector of interest!
        // The waveform of the pulse itself is stored as a std::vector<short> 
        // in pulse.Waveform().  Let's save this to another variable to make
        // the next steps less cumbersome..
        std::vector<short> wfm = pulse.Waveform();
	
        // If option fPrintWvforms is turned on in fhicl, save individual waveforms
        // as separate histograms in the output file.  We will only save a max of 
        // "fMaxSavedWaveforms" of these (if you want to save ALL waveforms, just set
        // this to some ridiculously high number like 1e10).
        if(fPrintWvforms && SavedWaveformCount < fMaxSavedWaveforms){
          // Setting name of the histogram so it would be unique 
          // in each run subrun, event and channel
	  sprintf(fHistName, "OpDet_%i_r%i_sr%i_e%i", int(pulse.OpChannel()),runnr,subrunnr, eventnr);
	  h_wvhist  = tfs->make<TH1F>(fHistName, ";t (ns);", wfm.size(), 0, wfm.size());
          for (int ii=0; ii<(int)wfm.size(); ++ii) h_wvhist->SetBinContent(ii,(float)wfm.at(ii));
          SavedWaveformCount++;
        }// endif wvforms are printed
	
        // Let's print stuff to the screen to demonstrate how to interpert the
        // OpDetPulse members variables.  Remember: the timestamp tells us 
        // where in the supercycle the event took place (beam spill usually
        // is seconds 1-5, with everything beyond ~5s being cosmic or Michel data).
        float timeStamp = ((float)pulse.PMTFrame()*8.)/1.0e09;
        std::cout
        <<"-----------------------------------------------------------\n"
        <<"Photodetector " << pulse.OpChannel() << " found in event " << e.event()    << "\n"
        <<"   timestamp               : " << timeStamp  << " sec\n"
        <<"   # of samples            : " << wfm.size() << "\n"
        <<"   trigger T0 is at sample : " << pulse.FirstSample() << "\n";

        // Fill the timestamp histogram:
        h_eventTimestamps->Fill(timeStamp);

        // Let's check out the baseline and RMS first using OpHitBuilderAlg::
        // GetBaselineAndRMS().  This takes the waveform as input (std::vector) as 
        // well as the limits to be used for the baseline calculation window, and
        // returns a std::vector of size 2 containing the baseline (0) and RMS (1).
        std::vector<float> tmp  = fOpHitBuilderAlg.GetBaselineAndRMS( wfm, 0, fBaselineWindowSize);
        float baseline          = tmp[0];
        float rms               = tmp[1];

        std::cout
        <<"Baseline: "<<baseline<<" ADC\n" 
        <<"RMS     : "<<rms<<" ADC \n";

        // Now let's do some hit-finding!
        //
        // We'll use the function OpHitBuilderAlg::GetHits to do this.  This process 
        // uses either the waveform itself or its gradient to look for points where a 
        // threshold is exceeded.  You can specify which mode to use in the fhicl 
        // (HitFindingMode: "grad" or "signal").  GetHits returns a std::vector<short> 
        // containing all the samples where hits were detected.
        std::vector<short> hitTimes = fOpHitBuilderAlg.GetHits( pulse );
        
        // Print out the found hits and fill some histograms.
        std::cout<< "Found "<<hitTimes.size()<<" hits in this waveform: \n";
        h_nOpHits->Fill(hitTimes.size());
        for(size_t i = 0; i < hitTimes.size(); i++){
          std::cout<< "   hit " << i << ", sample "<<hitTimes[i]<<"\n"; 
          h_hitTimes->Fill(hitTimes[i]);
        }

        // Calculate amplitude and integral of each of these hits with
        // OpHitBuilderAlg::GetHitInfo.  This function takes in the waveform (vector of 
        // floats/shorts), the hit sample, the "previous" hit, and a vector<short> of 
        // integration windows.  We can specify this list in the fhicl (by default it is 
        // [100,7000]), which is then stored in the variable fIntegrationWindows.  For clarity, 
        // we'll just define a new vector here.
        std::vector<short> intWindows{ 100, 7000 };

        // The function GetHitInfo returns vector<float> = (amplitude, intWindow1, intWindow2, ... ).
        // Amplitude is in mV, while the integrals are each in ADCs.  We'll loop over all the
        // hits that were found and do the calculation for each.  (Also note that since we have 
        // turned on "AddHitsToAverageWaveform" in the fhicl for the hit-finding alg, it will save 
        // each hit into a summed waveform which we will access and normalize in the endJob method.)
        for(size_t i=0; i<hitTimes.size(); i++ ){
          
          // For demonstrative purposes, let's skip any events outside the beam spill. Let's also 
          // exclude pulses occurring more than 500ns prior to the trigger T0.  This is activity 
          // in the TPC that happens prior to the beam or cosmic event we're actually interested in.  
          // For the triggered Michel events, these pulses are from the initial stopping muon. 
          if( timeStamp > 5.2 || hitTimes[i] < (short)pulse.FirstSample() - 500 ) continue;

          short prev_hit;
          if(i==0) prev_hit = 0;
          if(i>=1) prev_hit = hitTimes[i-1];
          
          std::vector<float> hitInfo 
	    = fOpHitBuilderAlg.GetHitInfo( wfm, hitTimes[i], prev_hit, intWindows );
          float hit_amp             = hitInfo[0];
          float hit_integral_100ns  = hitInfo[1];
          float hit_integral_7us    = hitInfo[2];

          std::cout<<"Amplitude of hit "<<i<<" = "<<hit_amp<<" mV\n";
          std::cout<<"Integral (100ns) of hit "<<i<<" = "<<hit_integral_100ns<<" ADC\n";
          std::cout<<"Integral (7us) of hit "<<i<<" = "<<hit_integral_7us<<" ADC\n";
          
          // Fill some histograms
          h_hitAmplitudes->Fill(hit_amp);
          h_hitPromptLight->Fill(hit_integral_100ns);
        }

      } // end if OpChannel = fOpDetChannel
    } // end loop over opdetpulses
  } // end if opdetHandle->size() != 0

  // White-space to separate events in printout
  std::cout<<"\n";
}

// -----------------------------------------------------------------------
void OpDetExample::beginJob()
{
  // Use TFileService to create all the histograms we made pointers to
  // in the constructor above.  This way, they'll automatically be written
  // to the output histogram file when the job finishes.
  h_eventTimestamps       = tfs->make<TH1F>("eventTimestamps","Event supercycle timestamps (sec)", 120, 0, 60);
  h_nOpHits               = tfs->make<TH1I>("nOpHits", "Optical hits per event", 10, 0, 10); 
  h_hitTimes              = tfs->make<TH1I>("hitTimes", "Times of optical hits within waveforms", 200, 0, fNWaveformSamples); 
  h_hitAmplitudes         = tfs->make<TH1F>("hitAmplitudes","Optical hit amplitudes (mV)", 110, 0, 220);
  h_hitPromptLight        = tfs->make<TH1F>("hitPromptLight" ,"Optical hit prompt light <100ns (ADC)", 200, 0, 3000);
  
  int AveWfmBins = fOpHitBuilderAlg.AveWfmBins;
  h_AverageWaveform       = tfs->make<TH1F>("AverageWaveform","Average waveform;sample [ns];amplitude [mV]",AveWfmBins,0.,AveWfmBins); 

}

// -----------------------------------------------------------------------
void OpDetExample::beginRun(art::Run const & r)
{
}

// -----------------------------------------------------------------------
void OpDetExample::beginSubRun(art::SubRun const & sr)
{
}

// -----------------------------------------------------------------------
void OpDetExample::endJob()
{
  // At the end of the job, grab the summed waveform from all the hits that
  // were fed into OpHitBuilderAlg::GetHitInfo and normalize it.
  size_t N_entries = fOpHitBuilderAlg.AverageWaveform_count;
  if( N_entries > 0 ){
    for(size_t i = 1; i <= fOpHitBuilderAlg.AverageWaveform.size(); i++) {
      h_AverageWaveform->Fill(i, fOpHitBuilderAlg.AverageWaveform.at(i-1) / float(N_entries)  );
    }
    std::cout<<"Average waveform saved.\n"; 
  }

}

// -----------------------------------------------------------------------
void OpDetExample::endRun(art::Run const & r)
{
}

// -----------------------------------------------------------------------
void OpDetExample::endSubRun(art::SubRun const & sr)
{
}

// -----------------------------------------------------------------------
void OpDetExample::reconfigure(fhicl::ParameterSet const & p)
{
  // Read in fhicl parameters defined at the bottom of OpDetExample.fcl
  fDAQModuleLabel               = p.get< std::string >  ("DAQModule","daq");
  fDAQModuleInstanceName        = p.get< std::string >  ("DAQInstanceName","");
  fOpDetChannel                 = p.get< size_t >       ("OpDetChannel",1);
  fBaselineWindowSize           = p.get< short >        ("BaselineWindowSize",1000);
  fNWaveformSamples             = p.get< size_t >       ("NWaveformSamples",28672);
  fPrintWvforms			= p.get< bool >		("PrintWvforms",false);
  fMaxSavedWaveforms            = p.get< size_t >       ("MaxSavedWaveforms",10);
  
  // Tell the OpHitBuilderAlg to grab its configuration parameters
  // from a special sub-parameterset defined in the fhicl
  fOpHitBuilderAlg.reconfigure(p.get<fhicl::ParameterSet>("OpHitBuilderAlg"));
}


DEFINE_ART_MODULE(OpDetExample)
