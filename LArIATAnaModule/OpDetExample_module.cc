////////////////////////////////////////////////////////////////////////
// Class:       OpDetExample
// Module Type: analyzer
// File:        OpDetExample_module.cc
//
// This module provides a simple example of accessing and manipulating
// photodetector data objects.  The input file can be either digit or 
// reco-level.
//
// Generated Wed Apr 27 14:57:47 2016
// William Foreman, wforeman@uchicago.edu 
// Pawel Kryczynski, pkryczyn@fnal.gov 
////////////////////////////////////////////////////////////////////////

// Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// ROOT includes
#include <TF1.h>
#include <TH1F.h>

//LAriatSoft Includes
#include "LArIATRecoAlg/OpHitBuilderAlg.h"

class OpDetExample;

class OpDetExample : public art::EDAnalyzer {
public:
  explicit OpDetExample(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  OpDetExample(OpDetExample const &) = delete;
  OpDetExample(OpDetExample &&) = delete;
  OpDetExample & operator = (OpDetExample const &) = delete;
  OpDetExample & operator = (OpDetExample &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:
  
  // Parameters to be read in from the fhicl script
  std::string       fDAQModuleLabel;
  std::string       fDAQModuleInstanceName;
  size_t            fOpDetChannel;
  short             fBaselineWindowSize;

  // Histograms
  TH1D* nOpHits;
  TH1D* hitTimes;
  TH1D* hitAmplitudes;
  TH1D* hitIntegrals;
  
  // TO DO:
  // - individual waveform histograms?
  // - average waveform?

  // Create the algorithm object of the OpHitBuilderAlg class.
  // We'll be using functions from this class to do hit-finding
  // and integration of pulses.  Feel free to take a look at the
  // algorithms themselves for a detailed look at what's going
  // on: LArIATRecoAlg/OpHitBuilderAlg.cxx
  OpHitBuilderAlg     fOpHitBuilderAlg;

};

OpDetExample::OpDetExample(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  fOpHitBuilderAlg(p)
{
  // Read in fhicl parameters
  this->reconfigure(p);  
}

void OpDetExample::analyze(art::Event const & e)
{
  // This function will run over each event individually.  The event
  // itself is accessible as an art::Event object "e" here.
  //
  // Optical data is stored by LArSoft as raw::OpDetPulse objects, which
  // can be accessed from the event the same way as most other data types.
  //
  // Define an ART handle to point to a vector of OpDetPulse objects
  // and then tell the event to fill the vector with all the objects
  // of that type.  "fDAQModuleLabel" indicates the producer that added 
  // these objects to the event in the previous stage.  This is set in
  // the fhicl file.  (You can always run eventdump.fcl on a file to 
  // check what data products it contains).
  art::Handle< std::vector< raw::OpDetPulse >> opdetHandle;
  e.getByLabel(fDAQModuleLabel, fDAQModuleInstanceName, opdetHandle);

  // We now have an art::Handle pointing to a vector of raw::OpDetPulse
  // objects.  We can check the size of opdetHandle to verify that this 
  // event actually contains data from the photosystem.  If empty, we use
  // 'return' to exit the function and move to next event.
  if( (size_t)opdetHandle->size() == 0 ){
    std::cout << "No optical detector data found; skipping event.\n";
    return;
  
  } else {
  
  // Otherwise, if photosystem data exists, let's loop through the vector 
  // of OpDetPulse objects stored in the handle.
    for (size_t i_pulse = 0; i_pulse < opdetHandle->size(); i_pulse ++ ){
 
      // Do some art magic to extract the raw::OpDetPulse object from
      // the handle.
      art::Ptr< raw::OpDetPulse > ThePulsePtr(opdetHandle,i_pulse); 
      raw::OpDetPulse pulse = *ThePulsePtr;

      // Each OpDetPulse object has a public member "OpChannel" which tells
      // us which photodetector it is.  For both Run 1 and 2, the ETL PMT
      // is channel "1", so this is the default for now.  You can look at
      // other detectors by changing this parameter in the fhicl.
      if( pulse.OpChannel() == fOpDetChannel ){
        
        // Great, we found data from the detector of interest!
        // The waveform of the pulse itself is stored as a std::vector<short> 
        // in pulse.Waveform().  Let's save this to another variable to make
        // the next steps less cumbersome..
        std::vector<short> wfm = pulse.Waveform();
      
        // Let's print stuff to the screen to demonstrate how to interpert the
        // OpDetPulse members variables.  Remember: the timestamp tells us 
        // where in the supercycle the event took place (beam spill usually
        // is seconds 1-5, with everything beyond ~5s being cosmic or Michel data).
        std::cout
        <<"Photodetector " << pulse.OpChannel() << " found in event " << e.event()    << "\n"
        <<"   timestamp               : " << ((float)pulse.PMTFrame()*8.)/1.0e09  << " sec\n"
        <<"   # of samples            : " << wfm.size()                           << "\n"
        <<"   trigger T0 is at sample : " << pulse.FirstSample()                  << "\n";


        // Let's check out the baseline and RMS first using OpHitBuilderAlg::
        // GetBaselineAndRMS().  This takes the waveform as input (std::vector) as 
        // well as the limits to be used for the baseline calculation window, and
        // returns a std::vector of size 2 containing the baseline (0) and RMS (1).
        std::vector<float> tmp  = fOpHitBuilderAlg.GetBaselineAndRMS( wfm, 0, fBaselineWindowSize);
        float baseline          = tmp[0];
        float rms               = tmp[1];

        std::cout<<"Baseline: "<<baseline<<" ADC,    RMS: "<<rms<<" ADC \n";

        // Now let's do some hit-finding!
        //
        // We'll use the function OpHitBuilderAlg::GetHits to do this.  This process 
        // uses either the waveform itself or its gradient to look for points where a 
        // threshold is exceeded.  You can specify which mode to use in the fhicl 
        // (HitFindingMode: "grad" or "signal").  GetHits returns a std::vector<short> 
        // containing all the samples where hits were detected.
        std::vector<short> hitTimes = fOpHitBuilderAlg.GetHits( pulse );

        std::cout<< "Found "<<hitTimes.size()<<" hits in this waveform: \n";
        for(size_t i = 0; i < hitTimes.size(); i++){
        std::cout<< "   hit " << i << ", sample\n"; 
        }

        // Now let's get integrals


      } // end if OpChannel = fOpDetChannel
    } // end loop over opdetpulses
  } // end if opdetHandle->size() != 0
}

void OpDetExample::beginJob()
{
  // Implementation of optional member function here.
}

void OpDetExample::beginRun(art::Run const & r)
{
}

void OpDetExample::beginSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void OpDetExample::endJob()
{
  // Implementation of optional member function here.
}

void OpDetExample::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void OpDetExample::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void OpDetExample::reconfigure(fhicl::ParameterSet const & p)
{
  // Tell the OpHitBuilderAlg to grab its configuration parameters
  // from a special parameterset defined in the fhicl
  fOpHitBuilderAlg.reconfigure(p.get<fhicl::ParameterSet>("OpHitBuilderAlg"));

  fDAQModuleLabel               = p.get< std::string >  ("DAQModule","daq");
  fDAQModuleInstanceName        = p.get< std::string >  ("DAQInstanceName","");
  fOpDetChannel                 = p.get< size_t >       ("OpDetChannel",1);
  fBaselineWindowSize           = p.get< short >        ("BaselineWindowSize",1000);
}


DEFINE_ART_MODULE(OpDetExample)
