////////////////////////////////////////////////////////////////////////
// Class:       MichelMCAna
// Module Type: analyzer
// File:        MichelMCAna_module.cc
//
// Generated at Mon Apr 18 16:22:58 2016 by William Foreman using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"


//C++ Includes
#include <iostream>
#include <fstream>

//ROOT Includes
#include <TF1.h>
#include <TH1D.h>
#include <TH1I.h>
#include <TH2D.h>
#include <TH3D.h>
#include <TTree.h>
#include "TVector3.h"
#include "TLorentzVector.h"

// LArSoft Includes
#include "larsim/Simulation/SimChannel.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "SimulationBase/MCParticle.h"
#include "SimulationBase/MCTruth.h"
#include "lardata/RawData/TriggerData.h"
#include "lardata/RecoBase/Track.h"
#include "lardata/RecoBase/Hit.h"
#include "lardata/RecoBase/Cluster.h"
#include "lardata/AnalysisBase/Calorimetry.h"
#include "lardata/AnalysisBase/ParticleID.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/AnalysisBase/Calorimetry.h"

//LAriatSoft Includes
//#include "Utilities/DatabaseUtilityT1034.h"


class MichelMCAna;

class MichelMCAna : public art::EDAnalyzer {
public:
  explicit MichelMCAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  MichelMCAna(MichelMCAna const &) = delete;
  MichelMCAna(MichelMCAna &&) = delete;
  MichelMCAna & operator = (MichelMCAna const &) = delete;
  MichelMCAna & operator = (MichelMCAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  
  // Custom functions
  int IsPointInFiducialVolume(TVector3,double,double,double);

private:

  // Fhicl parameters
  std::string         fSimProducerLabel;
  std::string         fTrackProducerLabel;
  std::string         fHitProducerLabel;
  std::string         fParticleIDModule;
  std::string         fTrackCalModule;
  double               fFiducialMargin_X;      
  double               fFiducialMargin_Y;      
  double               fFiducialMargin_Z;      

  // TPC dimensions
  double               TPC_Range_X[2];
  double               TPC_Range_Y[2];
  double               TPC_Range_Z[2];

  // Variables
  int                 NTracks;
  int                 IsStoppingMuon;
  int                 NStoppingMuons;
  int                 fPDG;
  int                 fTrackID;
  double              MuonP0_truth;
  double              MuonX0_truth;
  double              MuonY0_truth;
  double              MuonZ0_truth;
  double              MuonXend_truth;
  double              MuonYend_truth;
  double              MuonZend_truth;
  std::vector<double> vTrackVertex_X;
  std::vector<double> vTrackVertex_Y;
  std::vector<double> vTrackVertex_Z;
  std::vector<double> vTrackEnd_X;
  std::vector<double> vTrackEnd_Y;
  std::vector<double> vTrackEnd_Z;
  double              MuonXend_reco;
  double              MuonYend_reco;
  double              MuonZend_reco;
  
  // Arrays for 4-vectors: (x,y,z,t) and (Px,Py,Pz,E).
  // Note: old-style C++ arrays are considered obsolete. However,
  // to create simple n-tuples, we still need to use them. 
  double fStartXYZT[4];
  double fEndXYZT[4];
  double fStartPE[4];
  double fEndPE[4];

  // Root TTree
  TTree* SimulationTree;
  TTree* MichelMCTree;

  // Histograms
  TH1D* h_PDGCodeHist;
  TH1D* h_NTracks;
  TH1D* h_MichelEnergy_truth;
  TH1D* h_MichelEnergy_reco;
  TH1D* h_MuonP0;
  TH2D* h_MuonEnd_truth_ZX;
  TH2D* h_MuonEnd_truth_ZY;
  TH2D* h_MuonEnd_reco_ZX;
  TH2D* h_MuonEnd_reco_ZY;
  TH1D* h_MuonEnd_dX;
  TH1D* h_MuonEnd_dY;
  TH1D* h_MuonEnd_dZ;
};


MichelMCAna::MichelMCAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  // Read in fhicl parameters
  this->reconfigure(p);

  // TPC dimensions in cm
  TPC_Range_X[0]  =  0.00;
  TPC_Range_X[1]  =  47.5;
  TPC_Range_Y[0]  = -20.0;
  TPC_Range_Y[1]  =  20.0;
  TPC_Range_Z[0]  =  0.00;
  TPC_Range_Z[1]  =  90.0;
}

void MichelMCAna::analyze(art::Event const & e)
{
  // Initialize variables
  NTracks         = -9;
  IsStoppingMuon  =  0;
  MuonP0_truth    = -9;
  MuonX0_truth    = -99;
  MuonY0_truth    = -99;
  MuonZ0_truth    = -99;
  MuonXend_truth  = -99;
  MuonYend_truth  = -99;
  MuonZend_truth  = -99;
  bool foundMuon  = false;
  
  // Define a handle to point to a vector of simb::MCParticle objects,
  // and then tell the event to fill the vector with all the objects
  // of that type produced by a particular producer.
  art::Handle< std::vector<simb::MCParticle> > particleHandle;
  e.getByLabel(fSimProducerLabel, particleHandle);
  
  // The MCParticle objects are not necessarily in any particular
  // order. Since we may have to search the list of particles, let's
  // put them into a sorted map that will make searching fast and
  // easy. To save both space and time, the map will not contain a
  // copy of the MCParticle, but a pointer to it.
  std::map< int, const simb::MCParticle* > particleMap;
  for ( auto const& particle : (*particleHandle) )
  {
    fTrackID = particle.TrackId();
    particleMap[fTrackID] = &particle; 

    // Histogram the PDG code of every particle in the event.
    fPDG = particle.PdgCode();
    h_PDGCodeHist->Fill( fPDG );

    std::cout<<"Looping through MC particles...\n";

    // Pick out the primary cosmic muons
    if ( !foundMuon && particle.Process() == "primary"  &&  abs(fPDG) == 13 )
    {
      std::cout<<"Found muon!\n";
      foundMuon = true;

      // A particle has a trajectory, consisting of a set of
      // 4-positions and 4-mommenta.
      size_t numberTrajectoryPoints = particle.NumberTrajectoryPoints();


      // For trajectories, as for vectors and arrays, the
      // first point is #0, not #1.
      int last = numberTrajectoryPoints - 1;
      const TLorentzVector& positionStart = particle.Position(0);
      const TLorentzVector& positionEnd   = particle.Position(last);
      const TLorentzVector& momentumStart = particle.Momentum(0);
      //const TLorentzVector& momentumEnd   = particle.Momentum(last);
      
      MuonP0_truth    = momentumStart.P();
      MuonX0_truth    = positionStart.X();
      MuonY0_truth    = positionStart.Y();
      MuonZ0_truth    = positionStart.Z();
      MuonXend_truth  = positionEnd.X();
      MuonYend_truth  = positionEnd.Y();
      MuonZend_truth  = positionEnd.Z();

      // Test if stops in volume
      TVector3 endpoint(MuonXend_truth, MuonYend_truth, MuonZend_truth);
      IsStoppingMuon = IsPointInFiducialVolume(endpoint, fFiducialMargin_X, fFiducialMargin_Y, fFiducialMargin_Z ); 

      // Make a histogram of the starting momentum.
      h_MuonP0->Fill( MuonP0_truth );
      if (IsStoppingMuon) {
        h_MuonEnd_truth_ZX->Fill(MuonZend_truth, MuonXend_truth);
        h_MuonEnd_truth_ZY->Fill(MuonZend_truth, MuonYend_truth);
      }

    } // if primary and PDG selected by user
  } // loop over all particles in the event. 
 
  std::cout<<"Done with particle loop.\n"; 
  
  // Now get the recob::Track and recob::Hit objects
  art::Handle< std::vector< recob::Track >> trackHandle;
  e.getByLabel(fTrackProducerLabel,trackHandle);
  std::vector< art::Ptr< recob::Track >> trackList; 
  art::Handle< std::vector<recob::Hit> > hitHandle;
  e.getByLabel(fHitProducerLabel, hitHandle);
  
  // Count number of reconstructed tracks in this event
  NTracks = trackHandle->size();
  h_NTracks->Fill(NTracks);

  LOG_VERBATIM("MichelMCAna") << "Number of tracks: "<<NTracks;

  
  // Now loop through the reconstructed tracks and look for 
  // those that have an endpoint within the fiducial volume
  // and the opposite endpoint at the margin of the volume.
  // First step: plot all endpoints of reco tracks and note 
  // how concentrated at the edges they are.


  MichelMCTree->Fill();

}

void MichelMCAna::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  
  // TTree 
  MichelMCTree  = tfs->make<TTree>("MichelMCTree","MichelMCTree");
  MichelMCTree  -> Branch("NTracks",&NTracks,"NTracks/I");      
  MichelMCTree  -> Branch("IsStoppingMuon",&IsStoppingMuon,"IsStoppingMuon/I");
  MichelMCTree  -> Branch("vTrackVertex_X",&vTrackVertex_X);
  MichelMCTree  -> Branch("vTrackVertex_Y",&vTrackVertex_Y);
  MichelMCTree  -> Branch("vTrackVertex_Z",&vTrackVertex_Z);
  MichelMCTree  -> Branch("vTrackEnd_X",&vTrackEnd_X);
  MichelMCTree  -> Branch("vTrackEnd_Y",&vTrackEnd_Y);
  MichelMCTree  -> Branch("vTrackEnd_Z",&vTrackEnd_Z);
  MichelMCTree  -> Branch("MuonX0_truth",&MuonX0_truth,"MuonX0_truth/D");
  MichelMCTree  -> Branch("MuonY0_truth",&MuonY0_truth,"MuonY0_truth/D");
  MichelMCTree  -> Branch("MuonZ0_truth",&MuonZ0_truth,"MuonZ0_truth/D");
  MichelMCTree  -> Branch("MuonXend_truth",&MuonXend_truth,"MuonXend_truth/D");
  MichelMCTree  -> Branch("MuonYend_truth",&MuonYend_truth,"MuonYend_truth/D");
  MichelMCTree  -> Branch("MuonZend_truth",&MuonZend_truth,"MuonZend_truth/D");
  MichelMCTree  -> Branch("MuonXend_reco",&MuonXend_reco,"MuonXend_reco/D");
  MichelMCTree  -> Branch("MuonYend_reco",&MuonYend_reco,"MuonYend_reco/D");
  MichelMCTree  -> Branch("MuonZend_reco",&MuonZend_reco,"MuonZend_reco/D");
   
  // Histograms
  h_PDGCodeHist         = tfs->make<TH1D>("pdgcodes",";PDG Code;",                  5000, -2500, 2500);
  h_NTracks             = tfs->make<TH1D>("NTracks","Cosmic #mu MC (LArIAT);Number of reconstructed tracks",10,0,10);
  h_MichelEnergy_truth  = tfs->make<TH1D>("MichelEnergy_truth","Cosmic #mu MC (LArIAT);True Michel electron energy [MeV]",160,0,80);
  h_MichelEnergy_reco   = tfs->make<TH1D>("MichelEnergy_reco","Cosmic #mu MC (LArIAT);Reconstructed Michel electron energy [MeV]",160,0,80);
  h_MuonP0              = tfs->make<TH1D>("MuonP0","Generated muon momentum (GeV)",100,0.,0.600);
  h_MuonEnd_truth_ZX     = tfs->make<TH2D>("MuonEnd_truth_ZX","Truth cosmic #mu endpoint (LArIAT MC);Z [cm];X [cm]",
    180,TPC_Range_Z[0],TPC_Range_Z[1],
    95,TPC_Range_X[0],TPC_Range_X[1]);
  h_MuonEnd_truth_ZX->SetOption("colz");
  h_MuonEnd_truth_ZY     = tfs->make<TH2D>("MuonEnd_truth_ZY","Truth cosmic #mu endpoint (LArIAT MC);Z [cm];Y [cm]",
    180,TPC_Range_Z[0],TPC_Range_Z[1],
    80,TPC_Range_Y[0],TPC_Range_Y[1]);
  h_MuonEnd_truth_ZY->SetOption("colz");
  h_MuonEnd_reco_ZX     = tfs->make<TH2D>("MuonEnd_reco_ZX","Reconstructed cosmic #mu endpoint (LArIAT MC);Z [cm];X [cm]",
    180,TPC_Range_Z[0],TPC_Range_Z[1],
    95,TPC_Range_X[0],TPC_Range_X[1]);
  h_MuonEnd_reco_ZX->SetOption("colz");
  h_MuonEnd_reco_ZY     = tfs->make<TH2D>("MuonEnd_reco_ZY","Reconstructed cosmic #mu endpoint (LArIAT MC);Z [cm];Y [cm]",
    180,TPC_Range_Z[0],TPC_Range_Z[1],
    80,TPC_Range_Y[0],TPC_Range_Y[1]);
  h_MuonEnd_reco_ZY->SetOption("colz");
  h_MuonEnd_dX          = tfs->make<TH1D>("MuonEnd_dX","Stopping #mu+ endpoint resolution (LArIAT MC);#DeltaX [cm]",100,0,10);
  h_MuonEnd_dY          = tfs->make<TH1D>("MuonEnd_dY","Stopping #mu+ endpoint resolution (LArIAT MC);#DeltaY [cm]",100,0,10);
  h_MuonEnd_dZ          = tfs->make<TH1D>("MuonEnd_dZ","Stopping #mu+ endpoint resolution (LArIAT MC);#DeltaZ [cm]",100,0,10);
}

void MichelMCAna::beginRun(art::Run const & r)
{
}

void MichelMCAna::beginSubRun(art::SubRun const & sr)
{
}

void MichelMCAna::endJob()
{
}

void MichelMCAna::endRun(art::Run const & r)
{
}

void MichelMCAna::endSubRun(art::SubRun const & sr)
{
}

void MichelMCAna::reconfigure(fhicl::ParameterSet const & p)
{
  fTrackProducerLabel     = p.get< std::string >("TrackProducer","pmtrack");
  fSimProducerLabel       = p.get< std::string >("SimProducer","largeant");
  fHitProducerLabel       = p.get< std::string >("HitProducer","gaushit");
  fParticleIDModule       = p.get< std::string >("ParticleIDModule","pid");
  fTrackCalModule         = p.get< std::string >("TrackCalModule","calo");
  fFiducialMargin_X       = p.get< double >      ("FiducialMargin_X",0);
  fFiducialMargin_Y       = p.get< double >      ("FiducialMargin_Y",0);
  fFiducialMargin_Z       = p.get< double >      ("FiducialMargin_Z",0);
}

// Function for determining if a point is inside or outside
// predefined fiducial volume
int MichelMCAna::IsPointInFiducialVolume(TVector3 p, double fX, double fY, double fZ)
{
  if(    (p.X() >= TPC_Range_X[0] + fX) && (p.X() <= TPC_Range_X[1] - fX)
      && (p.Y() >= TPC_Range_Y[0] + fY) && (p.Y() <= TPC_Range_Y[1] - fY)
      && (p.Z() >= TPC_Range_Z[0] + fZ) && (p.Z() <= TPC_Range_Z[1] - fZ) )
  {
    return 1;
  } else {
    return 0;
  }
}

DEFINE_ART_MODULE(MichelMCAna)
