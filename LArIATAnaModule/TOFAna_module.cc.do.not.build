////////////////////////////////////////////////////////////////////////
// Class:       TOFAna
// Module Type: analyzer
// File:        TOFAna_module.cc
//
// Generated at Thu Jul 21 14:08:38 2016 by Lucas Mendes Santos using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h" 
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"


// LArSoft Libraries
#include "lardataobj/RawData/AuxDetDigit.h"
#include "LArIATDataProducts/TOF.h"
#include "LArIATDataProducts/WCTrack.h"
#include "LArIATAnaModule/WaveformAnalysis.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/AuxDetGeo.h"
#include "larcore/Geometry/AuxDetGeometry.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"

//ROOT Library

#include "TF1.h"
#include "TFile.h"
#include "TTree.h"

class TOFAna;

class TOFAna : public art::EDAnalyzer {
public:
  explicit TOFAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TOFAna(TOFAna const &) = delete;
  TOFAna(TOFAna &&) = delete;
  TOFAna & operator = (TOFAna const &) = delete;
  TOFAna & operator = (TOFAna &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void  reconfigure(fhicl::ParameterSet const & p) override;
  void  beginJob();
  double* FittingWaveform(std::vector <short> wvform); 
  std::string fTOFModuleLabel;
  std::string fWCModuleLabel;
  std::string fAuxDetModule;
  std::string fG4ModuleLabel;

private:

  // Declare member data here.

  double paramu0[4];
  double paramu1[4];
  double paramd0[4];
  double paramd1[4];
  
  double chi2normu0;
  double chi2normu1;
  double chi2normd0;
  double chi2normd1;

  double pareau0;
  double pareau1;
  double paread0;
  double paread1;

  short delta_t;
  double toft0, toftf;

  double simt0, simtf;
  
  TTree *fTree;

  double peak_height;

  double peak_area;

  double wc_momentum;

};


TOFAna::TOFAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{

 this->reconfigure(p);

}


void TOFAna::reconfigure(fhicl::ParameterSet const & p)
{
  fTOFModuleLabel = p.get<std::string>("TOF", "tof");
  fWCModuleLabel =  p.get<std::string>("WC", "wctrack");
  fAuxDetModule = p.get<std::string>("DAQ", "daq");
  fG4ModuleLabel = p.get<std::string>("G4ModuleLabel");
}

void  TOFAna::beginJob()
{

  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("tofana","TOF Ana");
  fTree->Branch("wvparamu0", &paramu0, "wvparamu0[4]/D");
  fTree->Branch("chi2normu0", &chi2normu0,"chi2normu0/D");
  fTree->Branch("wvparamu1", &paramu1, "wvparamu1[4]/D");
  fTree->Branch("chi2normu1", &chi2normu1,"chi2normu1/D");
  fTree->Branch("wvparamd0", &paramd0, "wvparamd0[4]/D");
  fTree->Branch("chi2normd0", &chi2normd0,"chi2normd0/D");
  fTree->Branch("wvparamd1", &paramd1, "wvparamd1[4]/D");
  fTree->Branch("chi2normd1", &chi2normd1,"chi2normd1/D");
  fTree->Branch("tof", &delta_t,"tof/S");
  fTree->Branch("recot0", &toft0, "recot0/D");
  fTree->Branch("recotf", &toftf, "recotf/D");
  fTree->Branch("simt0", &simt0, "simt0/D");
  fTree->Branch("simtf", &simtf, "simtf/D");
  fTree->Branch("wcmomentum", &wc_momentum, "wcmomentum/D");

}


void TOFAna::analyze(art::Event const & e)
{
  // Implementation of required member function here.

  //art::Handle< std::vector<sim::AuxDetSimChannel> > AuxDetHandle;
  //e.getByLabel(fG4ModuleLabel, AuxDetHandle);

  art::Handle< std::vector<raw::AuxDetDigit> > AuxDetDigitHandle;	
  e.getByLabel(fAuxDetModule,AuxDetDigitHandle);

  art::Handle< std::vector<ldp::TOF> > tofHandle;	
  e.getByLabel(fTOFModuleLabel,tofHandle);

  art::Handle< std::vector<ldp::WCTrack> > wcHandle;	
  e.getByLabel(fWCModuleLabel,wcHandle);

  std::vector<const raw::AuxDetDigit*> USTOF;
  std::vector<const raw::AuxDetDigit*> DSTOF;

  std::vector<short> usdet0;
  std::vector<short> usdet1;
  std::vector<short> dsdet0;
  std::vector<short> dsdet1;

  double* fitting;

//  int t0, tf;

//  short fHitThreshold;


 
if(tofHandle->size() > 0 && tofHandle->at(0).NTOF() > 0 && wcHandle->size() > 0){


     wc_momentum = wcHandle->at(0).Momentum();

     /*int ID;

     for(std::vector<sim::AuxDetSimChannel>::const_iterator auxiter = AuxDetHandle->begin(); auxiter!=AuxDetHandle->end(); ++auxiter){
     const sim::AuxDetSimChannel & aux = *auxiter;
    
     ID=aux.AuxDetID();
     art::ServiceHandle<geo::Geometry> adGeoServ;
     std::vector<sim::AuxDetIDE> SimIDE=aux.AuxDetIDEs();
     if(ID == 0 || ID == 6){
     double entryT, exitT;
     switch(ID)
     {
       case 0:
       entryT = (double)SimIDE.at(0).entryT;
       exitT = (double)SimIDE.at(0).exitT;   
       simt0 = (entryT + exitT)/2;
       break;
   
       case 6:
       entryT = (double)SimIDE.at(0).entryT;
       exitT = (double)SimIDE.at(0).exitT;   
       simtf = (entryT + exitT)/2;
       break;
      
     }

     }

     }*/   
       for( size_t iDig = 0; iDig < AuxDetDigitHandle->size() ; ++iDig ){

         if( AuxDetDigitHandle->at(iDig).AuxDetName() == "TOFUS" ) USTOF.push_back(&(AuxDetDigitHandle->at(iDig)));
	
         if( AuxDetDigitHandle->at(iDig).AuxDetName() == "TOFDS" ) DSTOF.push_back(&(AuxDetDigitHandle->at(iDig)));
      }
           for(size_t iADC = 0; iADC < USTOF.at(0)->NADC(); ++iADC)
  	   {
              usdet0.push_back(USTOF.at(0)->ADC(iADC));
           }

           fitting = FittingWaveform(usdet0);

 	   if(fitting){
           for(int i =0; i < 4; i++)
	   {
		paramu0[i] = *(fitting+i);

           }
           chi2normu0 = *(fitting+4);}
           std::cout<<paramu0[0]<<" "<<paramu0[1]<<" "<<paramu0[2]<<" "<<paramu0[3]<<std::endl;

	             
           for(size_t iADC = 0; iADC < USTOF.at(1)->NADC(); ++iADC)
  	   {
              usdet1.push_back(USTOF.at(1)->ADC(iADC));
           }

           fitting = FittingWaveform(usdet1);

           if(fitting){
           for(int i =0; i < 4; i++)
	   {
		paramu1[i] = *(fitting+i);

           }
	   std::cout<<paramu1[0]<<" "<<paramu1[1]<<" "<<paramu1[2]<<" "<<paramu1[3]<<std::endl;
           chi2normu1 = *(fitting+4);}

           if(paramu1[2] < paramu0[2])
           { //t0 = std::find(usdet1.begin(),usdet1.end(),*std::min_element(usdet1.begin(),usdet1.end())) - usdet1.begin();
/*	    int j = 0;
	    while(j < (int)usdet1.size())
	    {
		fHitThreshold = usdet1[j+1] - usdet1[j];
		if(fHitThreshold < -40){ t0 = j; break;}	
		else j++;
	    }
*/
	   toft0 = paramu1[2];

           }
           else{ //t0 = std::find(usdet0.begin(),usdet0.end(),*std::min_element(usdet0.begin(),usdet0.end())) - usdet0.begin();
/*	    int j = 0;	
            while(j < (int)usdet0.size())
	    {
		fHitThreshold = usdet0[j+1] - usdet0[j];
		if(fHitThreshold < -40){ t0 = j; break;}	
		else j++;
	    }
*/
	   toft0 = paramu0[2];
	   }

           for(size_t iADC = 0; iADC < DSTOF.at(0)->NADC(); ++iADC)
  	   {
              dsdet0.push_back(DSTOF.at(0)->ADC(iADC));
           }

           fitting = FittingWaveform(dsdet0);
            

           if(fitting){
           for(int i =0; i < 4; i++)
	   {
		paramd0[i] = *(fitting+i);
           }
	   
//           std::cout<<paramd0[0]<<" "<<paramd0[1]<<" "<<paramd0[2]<<" "<<paramd0[3]<<std::endl;
//         std::cout<<" This is the fitting variable: "<<*(fitting + 3)<<std::endl;       
           chi2normd0 = *(fitting+4);}
           
           for(size_t iADC = 0; iADC < DSTOF.at(1)->NADC(); ++iADC)
  	   {
              dsdet1.push_back(DSTOF.at(1)->ADC(iADC));
           }

           fitting = FittingWaveform(dsdet1);

           if(fitting){
           for(int i =0; i < 4; i++)
	   {
		paramd1[i] = *(fitting+i);

           }
           std::cout<<paramd1[0]<<" "<<paramd1[1]<<" "<<paramd1[2]<<" "<<paramd1[3]<<std::endl;
           chi2normd1 = *(fitting+4);
           }

           if(paramd1[2] < paramd0[2]){// tf = std::find(dsdet1.begin(),dsdet1.end(),*std::min_element(dsdet1.begin(),dsdet1.end())) - dsdet1.begin();

	   toftf = paramd1[2];
           /*int j = 0;
	    while(j < (int)dsdet1.size())
	    {
		fHitThreshold = dsdet0[j+1] - dsdet0[j];
		if(fHitThreshold < -40){ tf = j; break;}	
		else j++;
	    }*/

           }
           else{ //tf = std::find(dsdet0.begin(),dsdet0.end(),*std::min_element(dsdet0.begin(),dsdet0.end())) - dsdet0.begin();
/*
            int j = 0;
	    while(j < (int)dsdet0.size())
	    {
		fHitThreshold = dsdet1[j+1] - dsdet1[j];
		if(fHitThreshold < -40){ tf = j; break;}	
		else j++;
	    }

*/
           }



	   toftf = paramd0[2];
	   //toftf = (double)tf;
	   //toft0 = (double)t0;
//           delta_t = tofHandle->at(0).SingleTOF(0);
	     delta_t = toftf - toft0;
 	   std::cout<<"Time of Flight: "<<delta_t<<std::endl;

           fTree->Fill();
	
	   
       }	

	
}  





double* TOFAna::FittingWaveform(std::vector <short> wvform)
{

std::vector <double> peakstime;
double peak_area;
std::vector <short> peaks;
short risetime;
short decaytime;
int begin_sample, end_sample;
double* tempo;
bool found;
double* value;
double baseline, base_diff, mpv, sigma;
TGraph *gr;
double param[5];
double *fparam;

int ndf;
double chi;
TF1 *fit = new TF1("fit","[0] - [1]*TMath::Landau(x,[2],[3])", 0, 1000);

WaveformAnalysis *wv = new WaveformAnalysis();

found = wv->FindPeaks(200,wvform,100,"negative");

if(found){
		peaks = wv->GetPeaks();
		//cout<<"Peaks: "<<peaks[0]<<endl;
          
		peakstime = wv->GetPeaksTime();
                peak_area = wv->GetPulseArea(wvform,peakstime[0]);
		std::cout<<"Pulse Area "<<peak_area<<" "<<peakstime[0]/1e-9<<std::endl;
		risetime = wv->GetRiseTime();
		decaytime = wv->GetDecayTime();
                begin_sample = int(peakstime[0]/1e-9 - decaytime*5);
                end_sample =   int(peakstime[0]/1e-9 + risetime*5);

		std::vector <double> wv_sample(&wvform[begin_sample], &wvform[end_sample]);
		baseline = wv->GetBaseline();
		base_diff = baseline - peaks[0];
		//cout<<"Constant: "<<base_diff<<endl;
		mpv = peakstime[0]/1e-9;
                sigma = 2;
                tempo = new double[wv_sample.size()];
                value = new double[wv_sample.size()];
                for( int j = 0; j < (int)wv_sample.size(); j++){tempo[j] = begin_sample + j; value[j] = wv_sample[j];}
	        gr = new TGraph(wv_sample.size(), tempo, value);
                fit->SetRange((double)begin_sample, (double)end_sample);
		double par[4] = {baseline, base_diff, mpv, sigma};
		fit->SetParameters(par);
		gr->Fit("fit","QNM");
		fit->GetParameters(&param[0]);
 		chi = fit->GetChisquare();
		ndf = fit->GetNDF();
	        param[5] = chi/(double)ndf;
//		std::cout<<"This is the param fitting: "<<param[3]<<std::endl;
		
		gr->Clear();
                gr->Delete();
		wv_sample.clear();	        		
	
		fparam = param;
                

                
}
else{std::cout<<"Found No Peaks!!"<<std::endl; fparam = nullptr;}
return fparam;
}

DEFINE_ART_MODULE(TOFAna)
